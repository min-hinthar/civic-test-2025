---
phase: 32-celebration-system-elevation
plan: 06
type: execute
wave: 3
depends_on:
  - 32-04
  - 32-05
files_modified:
  - src/components/results/TestResultsScreen.tsx
autonomous: true
requirements:
  - CELB-04

must_haves:
  truths:
    - "Test results screen plays a multi-stage choreography: card scale-in -> count-up -> pass/fail reveal -> confetti -> sound -> action buttons stagger"
    - "Each stage is visibly sequenced, not simultaneous"
    - "Confetti teaser burst fires when score crosses pass threshold during count-up, full burst at pass/fail reveal"
    - "Pass gets snappy celebratory (~2.5-3s total), fail gets slower/gentler reveal"
    - "Action buttons cascade in one-by-one with ~100ms gaps"
    - "Background shifts to warm celebratory gradient during reveal"
    - "100% perfect score triggers unique ultimate choreography"
    - "Replay button shows on return visit; choreography only plays once by default"
    - "Haptic fires at each choreography stage: light at card, medium at count-up land, heavy at pass/fail"
  artifacts:
    - path: "src/components/results/TestResultsScreen.tsx"
      provides: "Multi-stage choreographed results screen"
      contains: "runChoreography"
  key_links:
    - from: "src/components/results/TestResultsScreen.tsx"
      to: "src/hooks/useCelebration.ts"
      via: "celebrate() call for confetti + sound + haptics"
      pattern: "celebrate"
    - from: "src/components/results/TestResultsScreen.tsx"
      to: "src/components/celebrations/CountUpScore.tsx"
      via: "Enhanced count-up with dramatic easing"
      pattern: "CountUpScore"
    - from: "src/components/results/TestResultsScreen.tsx"
      to: "src/lib/audio/celebrationSounds.ts"
      via: "Stage-specific sounds during choreography"
      pattern: "playCelebrationSequence"
---

<objective>
Rewrite TestResultsScreen with multi-stage choreographed celebration that sequences card entrance, score count-up, pass/fail reveal, confetti, sound, and action buttons.

Purpose: CELB-04 is the flagship celebration experience -- the moment users see their test results should feel emotionally satisfying, with tension building through the count-up and releasing at the pass/fail reveal. This ties together all the celebration pieces built in previous plans.
Output: Rewritten TestResultsScreen.tsx with promise-based sequential choreography.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-celebration-system-elevation/32-RESEARCH.md

@.planning/phases/32-celebration-system-elevation/32-04-SUMMARY.md
@.planning/phases/32-celebration-system-elevation/32-05-SUMMARY.md

@src/components/results/TestResultsScreen.tsx
@src/components/celebrations/CountUpScore.tsx
@src/components/celebrations/CelebrationOverlay.tsx
@src/hooks/useCelebration.ts
@src/lib/audio/celebrationSounds.ts
@src/lib/haptics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite TestResultsScreen header with multi-stage choreography</name>
  <files>src/components/results/TestResultsScreen.tsx</files>
  <action>
Rewrite the results screen header section (trophy, score, pass/fail badge, action buttons) with sequenced choreography (CELB-04):

**1. Choreography state machine:**
Create a `ChoreographyStage` type:
```typescript
type ChoreographyStage = 'idle' | 'card-enter' | 'count-up' | 'pass-fail' | 'confetti' | 'buttons' | 'complete';
```
Use `useState<ChoreographyStage>('idle')` to track current stage. Each stage transition triggers the next after its duration.

**2. Card entrance (Stage 1):**
- Replace the existing `motion.div` for trophy with a choreography-controlled version
- Initial: `{ y: 60, scale: 0.85, opacity: 0 }` (card slides up from below + scales in)
- Animate to: `{ y: 0, scale: 1, opacity: 1 }` with spring (stiffness 200, damping 20)
- Duration: ~500ms
- Haptic: `hapticLight()` at animation start
- Sound: `playCelebrationSequence('card-enter')` -- subtle whoosh
- On complete: advance to 'count-up' stage

**3. Score count-up (Stage 2):**
- Use the enhanced `CountUpScore` from Plan 04 with dramatic easing
- Duration: ~1.5s for pass, ~2s for fail (slower per user decision "fail = slower/gentler reveal")
- During count-up, if score crosses pass threshold (12/20 for mock test, 60% for practice):
  - Fire a teaser confetti burst: `celebrate({ level: 'sparkle', source: 'threshold-tease' })`
  - This creates the "two-act celebration arc" per user decision
- Sound: `playCelebrationSequence('count-up-tick')` fires count-up tick sounds (rising pitch)
  - Use `CountUpScore`'s `onUpdate` (or `formattingFn`) to sync tick sounds with displayed number changes
  - Tick frequency increases as count accelerates (dramatic easing)
- Haptic: `hapticMedium()` when count-up lands (at onComplete)
- Sound: `playCelebrationSequence('count-up-land')` at landing
- On complete: advance to 'pass-fail' stage after 100ms gap (per user decision "immediate ~100ms")

**4. Pass/fail reveal (Stage 3):**
- Badge animates in with pop + bounce: `scale: [0, 1.15, 1]` spring
- Pass badge: green styling, unchanged text
- Fail badge: warm amber/orange, same pop+bounce animation (per user decision)
- Haptic: `hapticHeavy()` at badge pop
- Gap: 100ms from count-up end (per user decision)
- Duration: ~300ms for badge animation
- On complete: advance to 'confetti' stage

**5. Confetti + sound (Stage 4, simultaneous):**
- For passing:
  - `celebrate({ level: isPerfect ? 'ultimate' : 'celebration', source: isPerfect ? '100-percent' : 'test-pass', isFirstTime: isFirstTimeCelebration('test-pass'), isDarkMode })`
  - This triggers CelebrationOverlay which handles confetti + sound + haptics
- For failing:
  - No confetti (per user decision "no confetti for fail")
  - `playCelebrationSequence('fail-reveal')` -- soft, warm, encouraging tone
  - `hapticLight()` -- gentle
- On complete: advance to 'buttons' stage after ~200ms

**6. Action buttons stagger (Stage 5):**
- Buttons appear one-by-one with ~100ms gaps (per user decision "quick cascade, 100ms gaps, total 300-400ms")
- Each button: `initial={{ y: 20, opacity: 0 }}`, `animate={{ y: 0, opacity: 1 }}`
- Transition: spring with stiffness 300, damping 20
- Stagger by index: delay = index * 100ms
- On all buttons visible: advance to 'complete'

**7. Background gradient shift:**
- During confetti stage, apply a subtle gradient overlay:
  - Pass: warm golden gradient `from-amber-500/5 via-transparent to-transparent`
  - Fail: soft amber gradient `from-orange-500/5 via-transparent to-transparent`
- Fade in over 500ms, persist for 3s, then fade out
- Use a motion.div with AnimatePresence for the gradient

**8. 100% perfect score ultimate choreography:**
- When `correctCount === totalCount`:
  - Golden palette everywhere (badge, gradient, confetti)
  - `celebrate({ level: 'ultimate', source: '100-percent' })` triggers ultimate in CelebrationOverlay
  - This includes multi-burst fireworks + screen shake + unique fanfare (handled by CelebrationOverlay)

**9. Fail state choreography:**
- Slower count-up (2s instead of 1.5s)
- No confetti
- Soft warm sound (`playFailReveal()`)
- Gentle haptic (light, not heavy)
- Warm amber tones, no green
- Encouraging -- not punishing

**10. Practice mode:**
- Light celebration: mini count-up (~800ms faster) + checkmark DotLottie (via celebrate sparkle) + light sound
- No confetti for practice (per user decision "light celebration")
- `celebrate({ level: 'sparkle', source: 'practice-complete' })`

**11. Replay functionality:**
- Track `hasPlayedChoreography` in a `useRef(false)` -- set to `true` after first choreography completes
- On return visit (or if component is rendered with `hasPlayedChoreography.current === true`), show static final state + "Replay" button
- "Replay" button resets choreography stage to 'idle' and `hasPlayedChoreography.current = false`, then triggers choreography again
- Replay button: small, secondary styling, positioned after action buttons

**12. Implementation approach:**
Use `async function runChoreography()` called from a `useEffect` on mount:
```typescript
useEffect(() => {
  if (hasPlayedChoreography.current) return;
  const controller = new AbortController();
  void runChoreography(controller.signal);
  return () => controller.abort();
}, []);
```

The `runChoreography` function uses `await sleep(ms)` helpers and motion/react `useAnimationControls` for sequencing. Each stage sets state via callbacks (not directly in effect body -- React Compiler safe):

```typescript
async function runChoreography(signal: AbortSignal) {
  if (signal.aborted) return;
  // Stage 1: Card enter
  setStage('card-enter');
  await cardControls.start({ ... });
  if (signal.aborted) return;
  // Stage 2: Count-up
  setStage('count-up');
  await new Promise<void>(resolve => countUpResolveRef.current = resolve);
  // ... etc
}
```

NOTE: `setStage` calls inside the async function are fine because they're called from the async flow, not directly in an effect body. The effect only starts the async function.

**13. Keep all existing content below the header unchanged:**
- Stats grid, category breakdown, weak area nudge, question review -- all stay as-is
- Only the header section (trophy, score, pass/fail badge, action buttons) gets choreography
- Wrap each section in motion.div controlled by stage (show after 'buttons' stage completes)

**14. Reduced motion:**
- Skip all animation -- show final state immediately
- Sound still plays (milestone/level-up sounds at component mount)
- No choreography stages -- everything visible from mount
  </action>
  <verify>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. `npm run build` succeeds
4. TestResultsScreen renders without errors
5. All existing props still accepted (no breaking changes)
6. Choreography stages fire in correct sequence
7. No `setState` directly in effect bodies (React Compiler compliant)
  </verify>
  <done>
- Multi-stage choreography: card -> count-up -> pass/fail -> confetti -> buttons, visibly sequenced
- Teaser confetti at pass threshold crossing during count-up
- Pass: snappy ~2.5-3s total, fail: slower/gentler
- Action buttons cascade with 100ms gaps
- Warm golden background gradient during reveal
- 100% perfect score: ultimate choreography (golden + fireworks + shake + fanfare)
- Fail: subdued warm amber, no confetti, soft sound, gentle haptic
- Practice: light celebration, mini count-up
- Replay button on return visit
- Haptics at each stage: light->medium->heavy progression
- Reduced motion: instant final state, sound plays
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck && npm run lint && npm run build` all pass
- TestResultsScreen choreography stages fire in order
- celebrate() is called at correct moments
- No breaking changes to TestResultsScreen props
- Replay button appears on return visit
</verification>

<success_criteria>
- Multi-stage choreography is visibly sequenced (not simultaneous)
- Pass vs fail vs 100% have distinct choreography
- Practice mode has lighter celebration
- Haptics fire at each stage
- Background gradient shifts during reveal
- Replay functionality works on return visits
</success_criteria>

<output>
After completion, create `.planning/phases/32-celebration-system-elevation/32-06-SUMMARY.md`
</output>
