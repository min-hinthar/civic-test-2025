---
phase: 31-animation-interaction-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/Dialog.tsx
  - src/lib/audio/soundEffects.ts
autonomous: true
requirements: [ANIM-03]

must_haves:
  truths:
    - "Closing any dialog plays a fade + scale(0.95) exit animation instead of instant disappearance — all 7 consumer files get this automatically via React context (no consumer changes needed)"
    - "Dialog overlay (backdrop) fades out synchronized with the content panel"
    - "Exit animation is faster than enter (~150ms exit vs ~250ms enter spring)"
    - "Exit scales toward the origin element (trigger button) via dynamic transformOrigin, not screen center"
    - "Pressing Escape triggers the same animated exit, not instant close"
    - "prefers-reduced-motion makes dialogs hide instantly with no animation"
    - "A subtle audio cue (soft descending pop) plays on overlay dismiss"
  artifacts:
    - path: "src/components/ui/Dialog.tsx"
      provides: "Dialog with React context open state, forceMount + AnimatePresence exit animations, transformOrigin targeting"
      contains: "AnimatePresence"
    - path: "src/lib/audio/soundEffects.ts"
      provides: "playDismiss sound effect for overlay exit"
      exports: ["playDismiss"]
  key_links:
    - from: "src/components/ui/Dialog.tsx"
      to: "motion/react"
      via: "AnimatePresence wrapping forceMount content"
      pattern: "AnimatePresence"
    - from: "src/components/ui/Dialog.tsx"
      to: "src/lib/audio/soundEffects.ts"
      via: "playDismiss() call on close"
      pattern: "playDismiss"
    - from: "Dialog (root)"
      to: "DialogContent"
      via: "React context provides open state automatically"
      pattern: "DialogInternalContext"
---

<objective>
Add exit animations to Dialog and a dismiss audio cue so overlays exit gracefully with fade + scale(0.95) instead of instantly vanishing.

Purpose: Instant overlay dismissal feels jarring and unfinished. Animated exits reinforce the spatial model (overlays recede into the background), provide satisfying closure, and match the playful spring-in enter animations. A soft audio cue adds multi-sensory feedback.

Output: Refactored Dialog.tsx with AnimatePresence + forceMount for exit animations, and a new playDismiss() function in soundEffects.ts.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/ui/Dialog.tsx
@src/lib/audio/soundEffects.ts
@src/lib/motion-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor Dialog.tsx with forceMount + AnimatePresence for exit animations</name>
  <files>src/components/ui/Dialog.tsx</files>
  <action>
The current Dialog.tsx has enter animations (spring from scale 0.95 + y:50) but NO exit animation because Radix unmounts content instantly when `open` becomes false. Fix by restructuring to use `forceMount` + `AnimatePresence`, with React context to thread `open` state automatically so ALL 7 consumer files get exit animations without any consumer-side changes.

**Key restructuring:**

1. **Create DialogInternalContext to thread `open` state.** The `Dialog` root wrapper knows `open` but `DialogContent` (a child component) doesn't. Use React context to bridge them — this avoids requiring every consumer to pass `open` as a prop to `DialogContent`:

   ```typescript
   import { createContext, useContext } from 'react';

   interface DialogInternalState {
     open: boolean;
     triggerRef: React.RefObject<HTMLElement | null>;
   }

   const DialogInternalContext = createContext<DialogInternalState | null>(null);

   function useDialogInternal(): DialogInternalState {
     const ctx = useContext(DialogInternalContext);
     if (!ctx) throw new Error('DialogContent must be inside Dialog');
     return ctx;
   }
   ```

2. **Update Dialog root to provide context and capture trigger position:**

   ```typescript
   export function Dialog({ open, onOpenChange, children }: DialogProps) {
     const triggerRef = useRef<HTMLElement | null>(null);

     const handleOpenChange = (newOpen: boolean) => {
       if (!newOpen && open) {
         playDismiss(); // Play audio on close
       }
       onOpenChange(newOpen);
     };

     return (
       <DialogInternalContext.Provider value={{ open, triggerRef }}>
         <DialogPrimitive.Root open={open} onOpenChange={handleOpenChange}>
           {children}
         </DialogPrimitive.Root>
       </DialogInternalContext.Provider>
     );
   }
   ```

3. **Update DialogTrigger to capture trigger element ref.** Wrap Radix's `DialogTrigger` to capture the trigger element's bounding rect for transformOrigin targeting:

   ```typescript
   export const DialogTrigger = forwardRef<HTMLButtonElement, DialogPrimitive.DialogTriggerProps>(
     (props, ref) => {
       const { triggerRef } = useDialogInternal();
       const combinedRef = useCallback((node: HTMLButtonElement | null) => {
         triggerRef.current = node;
         if (typeof ref === 'function') ref(node);
         else if (ref) ref.current = node;
       }, [ref, triggerRef]);
       return <DialogPrimitive.Trigger ref={combinedRef} {...props} />;
     }
   );
   ```

   NOTE: Not all consumers use `DialogTrigger` — some programmatically control `open` state. For those, `triggerRef` stays null, and exit scales from center (graceful fallback).

4. **Refactor DialogContent to read `open` from context and use AnimatePresence + forceMount:**

   ```typescript
   export const DialogContent = forwardRef<
     HTMLDivElement,
     DialogPrimitive.DialogContentProps & { showCloseButton?: boolean }
   >(({ className, children, showCloseButton = true, ...props }, ref) => {
     const shouldReduceMotion = useReducedMotion();
     const { open, triggerRef } = useDialogInternal();

     // Compute transformOrigin from trigger element position (locked decision)
     const transformOrigin = useMemo(() => {
       if (!triggerRef.current) return 'center center'; // Fallback
       const rect = triggerRef.current.getBoundingClientRect();
       const x = rect.left + rect.width / 2;
       const y = rect.top + rect.height / 2;
       return `${x}px ${y}px`;
     }, [open, triggerRef]); // Recalc when open changes (trigger may move)

     return (
       <AnimatePresence>
         {open && (
           <DialogPortal forceMount>
             <DialogOverlay forceMount />
             <DialogPrimitive.Content forceMount asChild ref={ref} {...props}>
               <div className="fixed inset-0 z-50 flex items-center justify-center p-4 pointer-events-none">
                 <motion.div
                   initial={shouldReduceMotion ? false : { opacity: 0, y: 50, scale: 0.95 }}
                   animate={{ opacity: 1, y: 0, scale: 1 }}
                   exit={shouldReduceMotion ? undefined : {
                     opacity: 0,
                     scale: 0.95,
                     transition: { duration: 0.15, ease: 'easeIn' }
                   }}
                   transition={SPRING_BOUNCY}
                   style={{ transformOrigin }}
                   className={clsx(
                     'pointer-events-auto w-full max-w-lg max-h-[85vh] overflow-auto',
                     'rounded-2xl bg-card border border-border/60 p-6',
                     'glass-heavy prismatic-border',
                     'shadow-2xl shadow-black/20',
                     'focus:outline-none',
                     className
                   )}
                 >
                   {children}
                   {showCloseButton && (
                     <DialogPrimitive.Close className={/* same close button classes */}>
                       <X className="h-4 w-4" />
                       <span className="sr-only">Close</span>
                     </DialogPrimitive.Close>
                   )}
                 </motion.div>
               </div>
             </DialogPrimitive.Content>
           </DialogPortal>
         )}
       </AnimatePresence>
     );
   });
   ```

   **transformOrigin behavior (locked decision):** The exit animation scales toward the button that opened the dialog. `triggerRef` captures the trigger element position. When no trigger element exists (programmatic dialogs), falls back to `center center`.

5. **DialogOverlay exit animation.** Update the overlay to use `exit` prop for synchronized fade-out:
   - Keep `exit={{ opacity: 0, transition: { duration: 0.15 } }}` to sync with content exit
   - Overlay and content share the parent `AnimatePresence` wrapper so both animate in sync

6. **DialogPortal with forceMount.** Radix `DialogPrimitive.Portal` supports `forceMount` prop. When set, it keeps the portal in the DOM regardless of open state, which is needed for AnimatePresence to animate exit.

7. **All 7 consumer files get exit animations automatically.** Since `DialogContent` now reads `open` from React context (not from a prop), every existing consumer that wraps content in `<Dialog open={...}>...<DialogContent>...</DialogContent></Dialog>` automatically gets exit animations with zero code changes. Verify all 7 files:
   - `InterviewSession.tsx` — `<Dialog open={showQuitDialog} ...>`
   - `MasteryMilestone.tsx` — `<Dialog open={isOpen} ...>`
   - `ResumePromptModal.tsx` — `<Dialog open={open} ...>`
   - `BadgeCelebration.tsx` — `<Dialog open={isOpen} ...>`
   - `LeaderboardProfile.tsx` — `<Dialog open={open} ...>`
   - `ShareCardPreview.tsx` — `<Dialog open={open} ...>`
   - `SocialOptInFlow.tsx` — `<Dialog open={open} ...>`
   All already pass `open` to `<Dialog>`, so context has the value.

**CRITICAL PITFALLS (from research):**
- `asChild` on `DialogPrimitive.Content` merges props onto its single child. When `motion.div` is that child wrapped in a positioning div, ensure the `asChild` target receives all Radix accessibility props (aria-*, role, etc.).
- `AnimatePresence` needs `key` prop on its direct children to track exits. Since there's only one child (the portal), this is handled automatically.
- Do NOT use `AnimatePresence mode="wait"` — that would delay new dialog opening if one is closing.
- `useMemo` for `transformOrigin` must depend on `open` (trigger position may change between opens) but NOT on `triggerRef.current` (ref access during render violates React Compiler rules). Instead, read `triggerRef.current` inside the memo when `open` transitions. If this causes Compiler lint issues, compute transformOrigin in an effect and store in state.
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- Check that Dialog.tsx imports `AnimatePresence` from `motion/react`
- Check that `DialogInternalContext` is created and provided by `Dialog` root
- Check that `DialogContent` reads `open` from context (not from prop)
- Check that `forceMount` is used on Portal, Overlay, and Content
- Check that `exit` prop is present on motion.div elements with `transformOrigin` style
- Verify all 7 consumer files compile without changes (no API breakage)
  </verify>
  <done>
ALL dialog overlays play fade + scale(0.95) exit animation via React context — zero consumer changes needed. Exit scales toward the trigger button (origin element) via dynamic transformOrigin, falling back to center for programmatic dialogs. Exit takes ~150ms (faster than enter). Escape key triggers same animated exit. Backdrop fades in sync. prefers-reduced-motion users see instant hide. playDismiss() audio cue fires on close.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add playDismiss sound effect for overlay exit audio cue</name>
  <files>src/lib/audio/soundEffects.ts</files>
  <action>
Add a `playDismiss` function to `soundEffects.ts` following the established pattern (mute check, getContext, oscillator+gain envelope, silent catch).

**Implementation:**
```typescript
/**
 * Soft descending pop for overlay/dialog dismiss.
 * 600 Hz -> 300 Hz sine sweep over 100ms. Gentle, satisfying close.
 */
export function playDismiss(): void {
  if (isSoundMuted()) return;
  try {
    const ctx = getContext();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gainNode = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.1);
    gainNode.gain.setValueAtTime(0.08, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
    osc.connect(gainNode);
    gainNode.connect(ctx.destination);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.1);
  } catch {
    // Silently ignore -- sound failure must never break app flow
  }
}
```

Place it in a new "Overlay sounds" section after the existing "Quiz interaction sounds" section. Follow the same documentation pattern (JSDoc with frequency/duration/character description).
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- `playDismiss` is exported from soundEffects.ts
- Function follows established pattern: mute check, getContext, oscillator, silent catch
  </verify>
  <done>
`playDismiss()` exported from soundEffects.ts. Plays a soft 600->300 Hz descending sine sweep over 100ms at volume 0.08. Respects mute setting. Silent no-op on error.
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with no errors
- `npm run lint` passes
- `npm run build` completes without errors
- Dialog.tsx imports AnimatePresence and uses forceMount pattern
- soundEffects.ts exports playDismiss function
- Exit animation uses faster timing (~150ms) than enter (spring ~250ms)
</verification>

<success_criteria>
Closing any dialog plays a smooth fade + scale(0.95) exit animation that scales toward the origin trigger element, with synchronized backdrop fade-out and a subtle audio dismiss cue. Exit feels snappier than enter. Escape key triggers the same animated exit. All 7 existing dialog consumers get exit animations automatically via React context — zero consumer code changes. Reduced motion users see instant hide.
</success_criteria>

<output>
After completion, create `.planning/phases/31-animation-interaction-polish/31-02-SUMMARY.md`
</output>
