---
phase: 13-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
  - .planning/security/rls-audit.md
autonomous: true

must_haves:
  truths:
    - "push_subscriptions table is defined in schema.sql with RLS policies"
    - "Every table in schema.sql has enable row level security"
    - "All RLS policies are documented in .planning/security/rls-audit.md"
    - "security_definer functions (get_leaderboard, get_user_rank) are documented with justification"
    - "No table allows unrestricted public access without documented justification"
    - "display_name in social_profiles rejects HTML tags via CHECK constraint (SEC-03)"
    - "All user input surfaces are audited and documented in rls-audit.md with XSS assessment (SEC-03)"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "push_subscriptions table with RLS policies, display_name validation"
      contains: "push_subscriptions"
    - path: ".planning/security/rls-audit.md"
      provides: "Comprehensive RLS audit documentation including XSS input surface assessment"
      contains: "push_subscriptions"
  key_links:
    - from: "supabase/schema.sql"
      to: "pages/api/push/subscribe.ts"
      via: "push_subscriptions table used by subscribe API"
      pattern: "push_subscriptions"
    - from: ".planning/security/rls-audit.md"
      to: "supabase/schema.sql"
      via: "Documents every table and policy from schema"
      pattern: "RLS"
---

<objective>
Add the missing push_subscriptions table to schema.sql with RLS policies, and create a comprehensive audit document covering all Supabase tables, RLS policies, and security_definer functions.

Purpose: The push_subscriptions table was created manually in Supabase without documented RLS. All tables need a unified audit document for ongoing security review. Per user decision: "Review AND fix -- audit all tables, document policies, and tighten overly permissive ones."

Output: Updated schema.sql with push_subscriptions + RLS, new .planning/security/rls-audit.md audit document.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/schema.sql
@pages/api/push/subscribe.ts
@pages/api/push/send.ts
@pages/api/push/srs-reminder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add push_subscriptions table with RLS to schema.sql</name>
  <files>supabase/schema.sql</files>
  <action>
Add a `push_subscriptions` table section to `supabase/schema.sql`, placed after the earned_badges section and before the leaderboard functions. Include clear section header comments.

**Table definition (matching what the subscribe API currently expects):**
```sql
-- ============================================================
-- Push Notification Subscriptions (Phase 2 - PWA)
-- ============================================================
-- NOTE: This table was originally created manually in Supabase.
-- Added to schema.sql in Phase 13 (Security Hardening) with RLS policies.
-- The subscribe API (pages/api/push/subscribe.ts) uses SUPABASE_SERVICE_ROLE_KEY
-- to bypass RLS for upsert/delete operations AFTER verifying the user's JWT.
-- Cron endpoints (send.ts, srs-reminder.ts, weak-area-nudge.ts) also use
-- service role key to read all subscriptions for cross-user notification delivery.

create table if not exists public.push_subscriptions (
  user_id uuid primary key references public.profiles (id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  reminder_frequency text not null default 'daily'
    check (reminder_frequency in ('daily', 'every2days', 'weekly', 'off')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**RLS policies:**
```sql
alter table public.push_subscriptions enable row level security;

-- Users can read their own push subscription status
drop policy if exists "Users can view own push subscription" on public.push_subscriptions;
create policy "Users can view own push subscription" on public.push_subscriptions
  for select using (auth.uid() = user_id);

-- Users can manage their own push subscription (insert/update/delete)
drop policy if exists "Users can manage own push subscription" on public.push_subscriptions;
create policy "Users can manage own push subscription" on public.push_subscriptions
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);
```

**Add `display_name` length AND character pattern constraints to social_profiles** (flagged in research as needing server-side validation -- currently only client-side 2-30 chars). This directly addresses SEC-03 (XSS input sanitization) by rejecting HTML tags at the database level:
```sql
-- Add display_name length constraint if not exists
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'social_profiles_display_name_length'
  ) then
    alter table public.social_profiles
      add constraint social_profiles_display_name_length
      check (char_length(display_name) between 2 and 30);
  end if;
end $$;

-- Add display_name no-HTML constraint if not exists (SEC-03: XSS prevention)
-- Rejects any value containing < or > characters, preventing HTML/script injection.
-- React JSX auto-escapes on render, but defense-in-depth means we also sanitize at storage.
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'social_profiles_display_name_no_html'
  ) then
    alter table public.social_profiles
      add constraint social_profiles_display_name_no_html
      check (display_name !~ '[<>]');
  end if;
end $$;
```

Place these constraint additions right after the social_profiles table definition (after the `enable row level security` and policies block).

**Add SQL comments to security_definer functions:**
Add a block comment above each `security definer` function explaining WHY it uses definer:

Above `get_leaderboard`:
```sql
-- security definer: Required because leaderboard queries all opted-in social_profiles,
-- not just the calling user's row. RLS would restrict to auth.uid() = user_id only.
-- Safe because: only returns display_name, score, streak, badge of opted-in users.
-- Granted to: authenticated, anon (public leaderboard is intentional).
```

Above `get_user_rank`:
```sql
-- security definer: Required to compute rank across all opted-in users.
-- RLS would restrict to auth.uid() = user_id only, preventing ranking calculation.
-- Safe because: only returns a single bigint rank number, no PII.
-- Granted to: authenticated only (user must be logged in to see their rank).
```
  </action>
  <verify>
1. Read `supabase/schema.sql` and confirm: push_subscriptions table with RLS policies exists, display_name length constraint on social_profiles exists, display_name no-HTML constraint on social_profiles exists, security_definer comments exist.
2. Run `pnpm run typecheck` (should be unaffected by SQL changes, but verifies no accidental file corruption).
3. Verify push_subscriptions has `enable row level security` + at least a select and an all/insert/update/delete policy.
  </verify>
  <done>
- push_subscriptions table defined in schema.sql with proper types and constraints
- RLS enabled on push_subscriptions with user-scoped policies
- display_name length constraint (2-30 chars) added to social_profiles
- display_name no-HTML constraint (rejects < and > characters) added to social_profiles (SEC-03)
- security_definer functions have SQL comments explaining WHY they need definer
- All SQL is idempotent (uses IF NOT EXISTS, DROP IF EXISTS patterns)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive RLS audit document</name>
  <files>.planning/security/rls-audit.md</files>
  <action>
Create `.planning/security/rls-audit.md` (create the `security/` directory if it doesn't exist).

**Document structure:**

```markdown
# Supabase Row Level Security Audit

**Audit Date:** [current date]
**Auditor:** Claude (Phase 13 - Security Hardening)
**Schema File:** `supabase/schema.sql`

## Summary

[Brief summary: N tables audited, all have RLS enabled, N functions reviewed, no unrestricted public access found]

## Tables

### profiles
- **RLS:** Enabled
- **Policies:**
  - SELECT: Owner only (`auth.uid() = id`)
  - INSERT: Owner only (`auth.uid() = id`)
  - UPDATE: Owner only (`auth.uid() = id`)
  - DELETE: Not allowed (cascade from auth.users)
- **Risk Level:** Low
- **Notes:** Automatically populated by `handle_new_user()` trigger on auth.users insert.

### mock_tests
[Same format for each table]

### mock_test_responses
[Include note about the subquery join to mock_tests for user_id verification]

### srs_cards
[Full CRUD for owner]

### interview_sessions
[SELECT + INSERT for owner]

### social_profiles
[Note the public SELECT for opted-in users -- intentional for leaderboard]

### streak_data
[ALL + INSERT for owner]

### earned_badges
[Note the cross-table join for opted-in user badge visibility]

### push_subscriptions (NEW)
[Added in Phase 13, policies documented]

## Functions

### handle_new_user() - SECURITY DEFINER
- **Purpose:** Auto-populate profiles on auth.users insert
- **Justification:** Trigger runs on auth schema, needs access to public.profiles
- **Risk:** Low -- only reads new.id/email/metadata from auth.users insert event
- **Granted to:** Trigger (not callable directly)

### get_leaderboard() - SECURITY DEFINER
- **Purpose:** Query all opted-in social profiles for ranking
- **Justification:** RLS would restrict to calling user only; leaderboard needs cross-user data
- **Risk:** Low -- only returns display_name, score, streak, badge of opted-in users
- **Granted to:** authenticated, anon

### get_user_rank() - SECURITY DEFINER
- **Purpose:** Compute caller's rank among opted-in users
- **Justification:** RLS would restrict to calling user only; ranking needs cross-user data
- **Risk:** Low -- returns only a bigint rank number
- **Granted to:** authenticated

## Storage Buckets

No Supabase Storage buckets are in use. Nothing to audit.

## Edge Functions

No Supabase Edge Functions are deployed. Nothing to audit.

## Service Role Key Usage

### pages/api/push/subscribe.ts
- **Uses:** SUPABASE_SERVICE_ROLE_KEY for upsert/delete on push_subscriptions
- **Justification:** After Phase 13, JWT is verified first, then service role used for the database operation. Could be replaced with user-scoped client + RLS in a future iteration, but service role is acceptable since auth is verified upstream.
- **Risk:** Medium -- if JWT verification is bypassed, service role grants full access. Mitigated by: JWT verification is the first check, rate limiting is second.

### pages/api/push/send.ts, srs-reminder.ts, weak-area-nudge.ts
- **Uses:** SUPABASE_SERVICE_ROLE_KEY (or CRON_SECRET/API key auth)
- **Justification:** Cron-triggered endpoints that need to read ALL user subscriptions to send notifications. Cannot use per-user auth (no user context in cron).
- **Risk:** Low -- endpoints are server-to-server only, protected by cron secret/API key.

## Recommendations

1. [Any findings about overly permissive policies]
2. [Any recommendations for future hardening]
```

**Fill in each section** by reading the actual policies from `supabase/schema.sql`. Be precise about which operations each policy covers (SELECT, INSERT, UPDATE, DELETE, ALL) and the condition (auth.uid() = user_id, subquery, etc.).

Include a final "Recommendations" section with actionable findings. For example:
- The `streak_data` table has both an ALL policy and a separate INSERT policy -- the ALL policy already covers insert, so the INSERT policy is redundant (not harmful, just unnecessary).
- Consider adding a DELETE policy restriction on social_profiles (currently no explicit delete policy -- falls under the ALL-less approach where delete is implicitly denied by RLS if no policy exists for it).
  </action>
  <verify>
1. Read `.planning/security/rls-audit.md` and confirm: all 9 tables documented, all 3 functions documented, storage + edge function sections present, service role usage documented.
2. Verify every table in `supabase/schema.sql` appears in the audit document.
3. Verify the document includes Storage Buckets and Edge Functions sections (even if empty per user decision "Full Supabase audit").
  </verify>
  <done>
- .planning/security/rls-audit.md exists with all 9 tables documented
- Each table entry includes: RLS status, policy details (operation + condition), risk level, notes
- All 3 security_definer functions documented with justification
- Storage and Edge Functions sections present (noting nothing to audit)
- Service role key usage documented for all API routes
- Recommendations section with actionable findings
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit all user input surfaces for XSS and document in rls-audit.md (SEC-03)</name>
  <files>.planning/security/rls-audit.md</files>
  <action>
After completing Tasks 1 and 2, add an "Input Sanitization & XSS Assessment" section to `.planning/security/rls-audit.md`. This section directly satisfies SEC-03 ("User-facing input fields are sanitized against XSS").

**Audit procedure:** Search the codebase for all user input surfaces:
1. `grep -r "dangerouslySetInnerHTML" src/ pages/` -- identify any user-controlled HTML rendering
2. `grep -r "display_name\|displayName" src/` -- trace where display_name is rendered
3. `grep -r "<input\|<textarea\|contentEditable" src/` -- find all input fields
4. `grep -r "marked\|markdown\|sanitize\|DOMPurify" src/` -- find any HTML rendering libraries in use
5. Check if `marked` is imported anywhere (research says it's unused -- confirm)

**Document the following in a new section of rls-audit.md:**

```markdown
## Input Sanitization & XSS Assessment (SEC-03)

**Assessment Date:** [current date]
**Overall XSS Risk:** LOW

### Defense Layers

1. **React JSX auto-escaping:** All user-visible text rendered via JSX expressions (`{variable}`) which auto-escape HTML entities. No user-controlled content passes through `dangerouslySetInnerHTML`.
2. **CSP nonce-based script-src (Plan 13-02):** Even if an XSS payload were stored, CSP blocks execution of inline scripts without a valid nonce.
3. **Database CHECK constraints (Plan 13-03):** `display_name` rejects `<` and `>` characters at the PostgreSQL level, preventing HTML tag storage.

### User Input Surface Inventory

| Input Field | Location | Rendered To Others? | Sanitization | Risk |
|-------------|----------|---------------------|--------------|------|
| display_name | social_profiles | Yes (leaderboard) | DB CHECK: 2-30 chars, no `<>` chars; React JSX auto-escape on render | LOW |
| email | auth (Supabase) | No (only shown to self) | Managed by Supabase Auth | NONE |
| password | auth (Supabase) | No (never rendered) | Managed by Supabase Auth, min 12 chars | NONE |
| test answers | mock_test_responses | No (only shown to self) | Stored as option index (integer), not free text | NONE |
| study guide search | StudyGuide filter | No (client-side filter only) | Not stored; React JSX auto-escape | NONE |
| interview responses | interview_sessions | No (only shown to self) | React JSX auto-escape on render | LOW |

### Removed XSS Vectors

- **`marked` library:** Present in package.json but NOT imported anywhere in src/. Scheduled for removal in Plan 13-04 (dependency pruning). This eliminates a potential markdown-to-HTML XSS vector.

### Conclusion

No additional runtime sanitization library (e.g., DOMPurify) is needed because:
1. No user input is rendered as raw HTML (no `dangerouslySetInnerHTML` with user content)
2. The only user text visible to others (`display_name`) has database-level character restrictions
3. CSP provides defense-in-depth against any stored XSS payloads
4. The `marked` library (potential XSS vector) is unused and being removed
```

Adapt the table based on actual findings from the grep audit. If any unexpected input surfaces are found, document them and add appropriate mitigation.
  </action>
  <verify>
1. Read `.planning/security/rls-audit.md` and confirm: "Input Sanitization & XSS Assessment (SEC-03)" section exists with input surface inventory table.
2. Verify the section documents: defense layers (React auto-escape, CSP, DB constraints), input surface table, removed XSS vectors (`marked` removal), and conclusion.
3. Confirm no user input field is missing from the inventory.
  </verify>
  <done>
- rls-audit.md contains "Input Sanitization & XSS Assessment (SEC-03)" section
- All user input surfaces inventoried with location, rendering scope, sanitization method, and risk level
- Defense-in-depth layers documented (React JSX, CSP, DB constraints)
- `marked` library removal noted as eliminated XSS vector
- Conclusion explains why no additional runtime sanitization (DOMPurify) is needed
- SEC-03 requirement fully covered
  </done>
</task>

</tasks>

<verification>
1. `supabase/schema.sql` contains push_subscriptions table with RLS enabled and policies
2. `supabase/schema.sql` contains display_name length constraint on social_profiles
3. `supabase/schema.sql` contains display_name no-HTML constraint on social_profiles (SEC-03)
4. `.planning/security/rls-audit.md` documents all tables, functions, storage, and edge functions
5. `.planning/security/rls-audit.md` contains "Input Sanitization & XSS Assessment" section (SEC-03)
6. No table in schema.sql is missing from the audit document
7. `pnpm run typecheck` passes (SQL changes don't affect TS)
</verification>

<success_criteria>
- push_subscriptions table defined in schema.sql with RLS
- All 9 Supabase tables have documented RLS policies
- All security_definer functions have documented justification
- Full Supabase audit (tables, storage, edge functions) documented
- Service role key usage documented with risk assessment
- SEC-03 satisfied: display_name rejects HTML tags via DB constraint, all input surfaces audited and documented
</success_criteria>

<output>
After completion, create `.planning/phases/13-security-hardening/13-03-SUMMARY.md`
</output>
