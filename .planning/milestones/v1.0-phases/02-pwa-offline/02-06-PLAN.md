---
phase: 02-pwa-offline
plan: 06
type: execute
wave: 5
depends_on: ["02-01", "02-04"]
files_modified:
  - src/lib/pwa/sw.ts
  - src/lib/pwa/pushNotifications.ts
  - src/hooks/usePushNotifications.ts
  - src/app/api/push/subscribe/route.ts
  - src/app/api/push/send/route.ts
  - src/components/pwa/NotificationSettings.tsx
  - src/pages/SettingsPage.tsx
  - package.json
  - .env.example
autonomous: true
user_setup:
  - service: web-push
    why: "VAPID keys for push notifications"
    env_vars:
      - name: NEXT_PUBLIC_VAPID_PUBLIC_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
      - name: VAPID_PRIVATE_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
      - name: VAPID_EMAIL
        source: "Your email for VAPID identification (e.g., mailto:you@example.com)"

must_haves:
  truths:
    - "User can enable/disable push notifications"
    - "User can configure reminder frequency (daily, every 2 days, weekly, off)"
    - "User receives bilingual push notification when scheduled"
    - "Push subscription is stored in Supabase"
  artifacts:
    - path: "src/lib/pwa/pushNotifications.ts"
      provides: "Push subscription client-side logic"
      exports: ["subscribeToPush", "unsubscribeFromPush"]
    - path: "src/hooks/usePushNotifications.ts"
      provides: "Hook for push notification state and actions"
      exports: ["usePushNotifications"]
    - path: "src/app/api/push/subscribe/route.ts"
      provides: "API route to store push subscription"
      exports: ["POST"]
    - path: "src/app/api/push/send/route.ts"
      provides: "API route to send push notification"
      exports: ["POST"]
    - path: "src/components/pwa/NotificationSettings.tsx"
      provides: "UI for notification preferences"
      exports: ["NotificationSettings"]
  key_links:
    - from: "src/lib/pwa/sw.ts"
      to: "push event handler"
      via: "addEventListener push"
      pattern: "addEventListener.*push"
    - from: "src/lib/pwa/pushNotifications.ts"
      to: "src/app/api/push/subscribe/route.ts"
      via: "fetch to API"
      pattern: "api/push/subscribe"
---

<objective>
Implement push notification infrastructure for study reminders.

Purpose: Per user decisions - push notifications for study reminders and milestone celebrations, bilingual text, user-configurable frequency (daily, every 2 days, weekly, off). Permission requested during onboarding (already handled in 02-04).
Output: Working push notification system with subscription storage and configurable reminders.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pwa-offline/02-RESEARCH.md
@.planning/phases/02-pwa-offline/02-01-SUMMARY.md
@.planning/phases/02-pwa-offline/02-04-SUMMARY.md

@src/lib/pwa/sw.ts
@src/lib/supabaseClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up web-push and update service worker</name>
  <files>
    package.json
    src/lib/pwa/sw.ts
    .env.example
  </files>
  <action>
1. Install web-push:
   ```bash
   pnpm add web-push
   ```

2. Update .env.example with required env vars:
   ```
   # Push Notifications (generate with: npx web-push generate-vapid-keys)
   NEXT_PUBLIC_VAPID_PUBLIC_KEY=
   VAPID_PRIVATE_KEY=
   VAPID_EMAIL=mailto:your-email@example.com
   ```

3. Update src/lib/pwa/sw.ts to handle push events:
   Add after existing serwist.addEventListeners():

   ```typescript
   // Handle push notifications
   self.addEventListener("push", (event) => {
     if (!event.data) return;

     try {
       const data = event.data.json();

       // Bilingual notification per user decision
       const title = data.title || "US Civics / US Civics";
       const options: NotificationOptions = {
         body: data.body || "",
         icon: "/icons/icon-192.png",
         badge: "/icons/badge-72.png",
         tag: data.tag || "study-reminder",
         data: {
           url: data.url || "/",
         },
         // Vibrate pattern for mobile
         vibrate: [100, 50, 100],
       };

       event.waitUntil(self.registration.showNotification(title, options));
     } catch (error) {
       console.error("Push notification error:", error);
     }
   });

   // Handle notification click
   self.addEventListener("notificationclick", (event) => {
     event.notification.close();

     const url = event.notification.data?.url || "/";

     event.waitUntil(
       clients.matchAll({ type: "window", includeUncontrolled: true }).then((clientList) => {
         // If app window exists, focus it
         for (const client of clientList) {
           if (client.url.includes(self.location.origin) && "focus" in client) {
             return client.focus();
           }
         }
         // Otherwise open new window
         return clients.openWindow(url);
       })
     );
   });
   ```

4. Create public/icons/badge-72.png placeholder (small monochrome badge icon for notification tray).
  </action>
  <verify>
    pnpm install succeeds
    pnpm run build succeeds
    .env.example includes VAPID vars
  </verify>
  <done>
    web-push installed, service worker handles push/notificationclick events, badge icon exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Create push subscription client logic and API routes</name>
  <files>
    src/lib/pwa/pushNotifications.ts
    src/hooks/usePushNotifications.ts
    src/app/api/push/subscribe/route.ts
    src/app/api/push/send/route.ts
  </files>
  <action>
1. Create src/lib/pwa/pushNotifications.ts:
   ```typescript
   const VAPID_PUBLIC_KEY = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY;

   function urlBase64ToUint8Array(base64String: string): Uint8Array {
     const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
     const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
     const rawData = window.atob(base64);
     const outputArray = new Uint8Array(rawData.length);
     for (let i = 0; i < rawData.length; ++i) {
       outputArray[i] = rawData.charCodeAt(i);
     }
     return outputArray;
   }

   export async function subscribeToPush(
     userId: string,
     reminderFrequency: "daily" | "every2days" | "weekly" | "off"
   ): Promise<boolean> {
     if (!VAPID_PUBLIC_KEY) {
       console.error("VAPID public key not configured");
       return false;
     }

     try {
       const registration = await navigator.serviceWorker.ready;

       const subscription = await registration.pushManager.subscribe({
         userVisibleOnly: true,
         applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
       });

       // Send subscription to server
       const response = await fetch("/api/push/subscribe", {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({
           subscription: subscription.toJSON(),
           userId,
           reminderFrequency,
         }),
       });

       return response.ok;
     } catch (error) {
       console.error("Push subscription error:", error);
       return false;
     }
   }

   export async function unsubscribeFromPush(userId: string): Promise<boolean> {
     try {
       const registration = await navigator.serviceWorker.ready;
       const subscription = await registration.pushManager.getSubscription();

       if (subscription) {
         await subscription.unsubscribe();
       }

       // Notify server
       const response = await fetch("/api/push/subscribe", {
         method: "DELETE",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ userId }),
       });

       return response.ok;
     } catch (error) {
       console.error("Push unsubscribe error:", error);
       return false;
     }
   }

   export async function getSubscriptionStatus(): Promise<{
     subscribed: boolean;
     permission: NotificationPermission;
   }> {
     if (typeof Notification === "undefined") {
       return { subscribed: false, permission: "denied" };
     }

     const permission = Notification.permission;

     if (permission !== "granted") {
       return { subscribed: false, permission };
     }

     try {
       const registration = await navigator.serviceWorker.ready;
       const subscription = await registration.pushManager.getSubscription();
       return { subscribed: !!subscription, permission };
     } catch {
       return { subscribed: false, permission };
     }
   }
   ```

2. Create src/hooks/usePushNotifications.ts:
   ```typescript
   import { useState, useEffect, useCallback } from "react";
   import {
     subscribeToPush,
     unsubscribeFromPush,
     getSubscriptionStatus,
   } from "@/lib/pwa/pushNotifications";

   type ReminderFrequency = "daily" | "every2days" | "weekly" | "off";

   interface UsePushNotificationsResult {
     isSubscribed: boolean;
     permission: NotificationPermission;
     reminderFrequency: ReminderFrequency;
     isLoading: boolean;
     subscribe: (frequency: ReminderFrequency) => Promise<boolean>;
     unsubscribe: () => Promise<boolean>;
     updateFrequency: (frequency: ReminderFrequency) => Promise<boolean>;
   }

   const FREQUENCY_KEY = "push-reminder-frequency";

   export function usePushNotifications(userId: string | null): UsePushNotificationsResult {
     const [isSubscribed, setIsSubscribed] = useState(false);
     const [permission, setPermission] = useState<NotificationPermission>("default");
     const [reminderFrequency, setReminderFrequency] = useState<ReminderFrequency>("off");
     const [isLoading, setIsLoading] = useState(true);

     useEffect(() => {
       async function checkStatus() {
         const status = await getSubscriptionStatus();
         setIsSubscribed(status.subscribed);
         setPermission(status.permission);

         const savedFrequency = localStorage.getItem(FREQUENCY_KEY) as ReminderFrequency | null;
         if (savedFrequency) {
           setReminderFrequency(savedFrequency);
         }

         setIsLoading(false);
       }
       checkStatus();
     }, []);

     const subscribe = useCallback(
       async (frequency: ReminderFrequency): Promise<boolean> => {
         if (!userId) return false;

         setIsLoading(true);
         const success = await subscribeToPush(userId, frequency);
         if (success) {
           setIsSubscribed(true);
           setReminderFrequency(frequency);
           localStorage.setItem(FREQUENCY_KEY, frequency);
         }
         setIsLoading(false);
         return success;
       },
       [userId]
     );

     const unsubscribe = useCallback(async (): Promise<boolean> => {
       if (!userId) return false;

       setIsLoading(true);
       const success = await unsubscribeFromPush(userId);
       if (success) {
         setIsSubscribed(false);
         setReminderFrequency("off");
         localStorage.setItem(FREQUENCY_KEY, "off");
       }
       setIsLoading(false);
       return success;
     }, [userId]);

     const updateFrequency = useCallback(
       async (frequency: ReminderFrequency): Promise<boolean> => {
         if (!userId) return false;

         if (frequency === "off") {
           return unsubscribe();
         }

         setIsLoading(true);
         const success = await subscribeToPush(userId, frequency);
         if (success) {
           setReminderFrequency(frequency);
           localStorage.setItem(FREQUENCY_KEY, frequency);
         }
         setIsLoading(false);
         return success;
       },
       [userId, unsubscribe]
     );

     return {
       isSubscribed,
       permission,
       reminderFrequency,
       isLoading,
       subscribe,
       unsubscribe,
       updateFrequency,
     };
   }
   ```

3. Create src/app/api/push/subscribe/route.ts:
   ```typescript
   import { NextRequest, NextResponse } from "next/server";
   import { createClient } from "@supabase/supabase-js";

   const supabaseAdmin = createClient(
     process.env.NEXT_PUBLIC_SUPABASE_URL!,
     process.env.SUPABASE_SERVICE_ROLE_KEY!
   );

   export async function POST(request: NextRequest) {
     try {
       const { subscription, userId, reminderFrequency } = await request.json();

       if (!userId || !subscription) {
         return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
       }

       const { error } = await supabaseAdmin.from("push_subscriptions").upsert(
         {
           user_id: userId,
           endpoint: subscription.endpoint,
           keys: subscription.keys,
           reminder_frequency: reminderFrequency,
           updated_at: new Date().toISOString(),
         },
         { onConflict: "user_id" }
       );

       if (error) throw error;

       return NextResponse.json({ success: true });
     } catch (error) {
       console.error("Push subscription error:", error);
       return NextResponse.json({ error: "Failed to save subscription" }, { status: 500 });
     }
   }

   export async function DELETE(request: NextRequest) {
     try {
       const { userId } = await request.json();

       if (!userId) {
         return NextResponse.json({ error: "Missing userId" }, { status: 400 });
       }

       const { error } = await supabaseAdmin
         .from("push_subscriptions")
         .delete()
         .eq("user_id", userId);

       if (error) throw error;

       return NextResponse.json({ success: true });
     } catch (error) {
       console.error("Push unsubscribe error:", error);
       return NextResponse.json({ error: "Failed to remove subscription" }, { status: 500 });
     }
   }
   ```

4. Create src/app/api/push/send/route.ts (for sending notifications - admin/cron use):
   ```typescript
   import { NextRequest, NextResponse } from "next/server";
   import webPush from "web-push";
   import { createClient } from "@supabase/supabase-js";

   const supabaseAdmin = createClient(
     process.env.NEXT_PUBLIC_SUPABASE_URL!,
     process.env.SUPABASE_SERVICE_ROLE_KEY!
   );

   // Configure web-push
   webPush.setVapidDetails(
     process.env.VAPID_EMAIL!,
     process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,
     process.env.VAPID_PRIVATE_KEY!
   );

   // Bilingual reminder messages
   const REMINDER_MESSAGES = [
     {
       title: "Time to study! / လေ့လာရန် အချိန်ရောက်ပြီ!",
       body: "A few minutes of practice today keeps your knowledge fresh.\nယနေ့ မိနစ်အနည်းငယ် လေ့ကျင့်ပါ။",
     },
     {
       title: "Ready for your civics test? / နိုင်ငံရေးစာမေးပွဲ အဆင်သင့်ဖြစ်ပြီလား။",
       body: "Keep practicing - you're making progress!\nဆက်လေ့ကျင့်ပါ - တိုးတက်နေပါပြီ!",
     },
     {
       title: "Study reminder / လေ့လာရန် သတိပေးချက်",
       body: "A little study every day makes a big difference.\nနေ့တိုင်း အနည်းငယ် လေ့လာခြင်းက ကြီးမားသော ခြားနားချက် ဖြစ်စေပါသည်။",
     },
   ];

   export async function POST(request: NextRequest) {
     try {
       // Verify admin authorization (simple API key check)
       const authHeader = request.headers.get("authorization");
       if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
         return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
       }

       const { frequency } = await request.json();

       // Get subscriptions matching frequency
       const { data: subscriptions, error } = await supabaseAdmin
         .from("push_subscriptions")
         .select("*")
         .eq("reminder_frequency", frequency);

       if (error) throw error;

       const message = REMINDER_MESSAGES[Math.floor(Math.random() * REMINDER_MESSAGES.length)];
       let sent = 0;
       let failed = 0;

       for (const sub of subscriptions || []) {
         try {
           await webPush.sendNotification(
             {
               endpoint: sub.endpoint,
               keys: sub.keys,
             },
             JSON.stringify({
               title: message.title,
               body: message.body,
               url: "/",
               tag: "study-reminder",
             })
           );
           sent++;
         } catch (err) {
           failed++;
           // If subscription is invalid, remove it
           if ((err as { statusCode?: number }).statusCode === 410) {
             await supabaseAdmin
               .from("push_subscriptions")
               .delete()
               .eq("user_id", sub.user_id);
           }
         }
       }

       return NextResponse.json({ sent, failed });
     } catch (error) {
       console.error("Send push error:", error);
       return NextResponse.json({ error: "Failed to send notifications" }, { status: 500 });
     }
   }
   ```
  </action>
  <verify>
    pnpm run typecheck passes
    pnpm run lint passes
    API routes have correct exports
  </verify>
  <done>
    Push subscription logic complete, API routes for subscribe/unsubscribe/send, bilingual messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Create notification settings UI</name>
  <files>
    src/components/pwa/NotificationSettings.tsx
    src/pages/SettingsPage.tsx
  </files>
  <action>
1. Create src/components/pwa/NotificationSettings.tsx:
   ```typescript
   import React from "react";
   import { Bell, BellOff } from "lucide-react";
   import { usePushNotifications } from "@/hooks/usePushNotifications";
   import { useAuth } from "@/contexts/SupabaseAuthContext";

   type ReminderFrequency = "daily" | "every2days" | "weekly" | "off";

   const FREQUENCY_OPTIONS: { value: ReminderFrequency; labelEn: string; labelMy: string }[] = [
     { value: "daily", labelEn: "Daily", labelMy: "နေ့တိုင်း" },
     { value: "every2days", labelEn: "Every 2 days", labelMy: "၂ ရက်တစ်ကြိမ်" },
     { value: "weekly", labelEn: "Weekly", labelMy: "အပတ်စဉ်" },
     { value: "off", labelEn: "Off", labelMy: "ပိတ်ထားပါ" },
   ];

   export function NotificationSettings() {
     const { user } = useAuth();
     const {
       isSubscribed,
       permission,
       reminderFrequency,
       isLoading,
       updateFrequency,
     } = usePushNotifications(user?.id || null);

     const handleFrequencyChange = async (e: React.ChangeEvent<HTMLSelectElement>) => {
       const frequency = e.target.value as ReminderFrequency;
       await updateFrequency(frequency);
     };

     // If notifications not supported or denied
     if (typeof Notification === "undefined") {
       return (
         <div className="rounded-lg border border-gray-200 p-4 dark:border-gray-700">
           <p className="text-sm text-gray-500 dark:text-gray-400">
             Notifications are not supported in this browser.
           </p>
           <p className="font-myanmar text-sm text-gray-500 dark:text-gray-400">
             ဤဘရောင်ဇာတွင် အကြောင်းကြားချက်များကို မပံ့ပိုးပါ။
           </p>
         </div>
       );
     }

     if (permission === "denied") {
       return (
         <div className="rounded-lg border border-red-200 bg-red-50 p-4 dark:border-red-800 dark:bg-red-900/20">
           <div className="flex items-center gap-2">
             <BellOff className="h-5 w-5 text-red-500" />
             <p className="font-medium text-red-800 dark:text-red-200">
               Notifications blocked
             </p>
           </div>
           <p className="mt-1 text-sm text-red-700 dark:text-red-300">
             To enable notifications, update your browser settings.
           </p>
           <p className="font-myanmar text-sm text-red-600 dark:text-red-400">
             အကြောင်းကြားချက်များ ပိတ်ထားပါသည်။ ဘရောင်ဇာ ဆက်တင်မှ ပြင်ဆင်ပါ။
           </p>
         </div>
       );
     }

     return (
       <div className="rounded-lg border border-gray-200 p-4 dark:border-gray-700">
         <div className="flex items-center gap-2 mb-3">
           <Bell className="h-5 w-5 text-blue-600 dark:text-blue-400" />
           <h3 className="font-medium text-gray-900 dark:text-white">
             Study Reminders
           </h3>
         </div>
         <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
           Get friendly reminders to keep studying
         </p>
         <p className="font-myanmar text-sm text-gray-500 dark:text-gray-500 mb-4">
           လေ့လာရန် သတိပေးချက်များ ရယူပါ
         </p>

         <div className="flex items-center gap-3">
           <label htmlFor="reminder-frequency" className="text-sm text-gray-700 dark:text-gray-300">
             Frequency / ကြိမ်နှုန်း:
           </label>
           <select
             id="reminder-frequency"
             value={reminderFrequency}
             onChange={handleFrequencyChange}
             disabled={isLoading}
             className="rounded-md border border-gray-300 bg-white px-3 py-1.5 text-sm dark:border-gray-600 dark:bg-gray-800 dark:text-white disabled:opacity-50"
           >
             {FREQUENCY_OPTIONS.map((option) => (
               <option key={option.value} value={option.value}>
                 {option.labelEn} / {option.labelMy}
               </option>
             ))}
           </select>
         </div>

         {isSubscribed && reminderFrequency !== "off" && (
           <p className="mt-3 text-sm text-green-600 dark:text-green-400">
             Notifications enabled / အကြောင်းကြားချက်များ ဖွင့်ထားပါပြီ
           </p>
         )}
       </div>
     );
   }
   ```

2. Create or update src/pages/SettingsPage.tsx (if it doesn't exist):
   - Add NotificationSettings component to settings page
   - If SettingsPage doesn't exist, create a minimal settings page with notification settings
   - Add route for /settings in AppShell.tsx if needed

   If creating new:
   ```typescript
   import React from "react";
   import { NotificationSettings } from "@/components/pwa/NotificationSettings";

   export default function SettingsPage() {
     return (
       <div className="container mx-auto max-w-2xl px-4 py-8">
         <h1 className="mb-6 text-2xl font-bold text-gray-900 dark:text-white">
           Settings / ဆက်တင်များ
         </h1>

         <section className="mb-6">
           <h2 className="mb-3 text-lg font-semibold text-gray-800 dark:text-gray-200">
             Notifications / အကြောင်းကြားချက်များ
           </h2>
           <NotificationSettings />
         </section>
       </div>
     );
   }
   ```

3. Add route to AppShell.tsx if SettingsPage is new.
  </action>
  <verify>
    pnpm run build succeeds
    Settings page shows notification options
    Frequency dropdown works
  </verify>
  <done>
    NotificationSettings component complete, integrated into settings page, frequency selection works
  </done>
</task>

</tasks>

<verification>
1. Generate VAPID keys: `npx web-push generate-vapid-keys`
2. Add keys to .env.local
3. Run `pnpm run build` and `pnpm start`
4. Navigate to Settings page
5. Change notification frequency from "Off" to "Daily"
6. Check browser notification permission prompt appears (if not already granted)
7. Check Supabase push_subscriptions table for new entry
8. Test send API (requires CRON_SECRET env var):
   ```bash
   curl -X POST http://localhost:3000/api/push/send \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer YOUR_CRON_SECRET" \
     -d '{"frequency": "daily"}'
   ```
9. Notification should appear with bilingual content
</verification>

<success_criteria>
- Service worker handles push and notificationclick events
- Push subscription stored in Supabase with user_id, endpoint, keys, frequency
- NotificationSettings shows frequency dropdown (daily, every 2 days, weekly, off)
- Changing frequency updates subscription
- Send API sends bilingual notifications
- Notification click opens app
- Invalid subscriptions cleaned up on 410 status
- All UI text is bilingual
</success_criteria>

<output>
After completion, create `.planning/phases/02-pwa-offline/02-06-SUMMARY.md`
</output>
