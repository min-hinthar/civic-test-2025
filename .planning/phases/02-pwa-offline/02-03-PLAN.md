---
phase: 02-pwa-offline
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/pwa/offlineDb.ts
  - src/lib/pwa/syncQueue.ts
  - src/hooks/useSyncQueue.ts
  - src/contexts/OfflineContext.tsx
  - src/components/pwa/SyncStatusIndicator.tsx
  - src/components/AppNavigation.tsx
autonomous: true

must_haves:
  truths:
    - "User can complete test offline and results are saved locally"
    - "User sees badge count of pending sync items"
    - "Results auto-sync when connectivity returns"
    - "User sees sync confirmation toast when complete"
  artifacts:
    - path: "src/lib/pwa/syncQueue.ts"
      provides: "Sync queue with exponential backoff retry"
      exports: ["queueTestResult", "syncAllPendingResults", "getPendingSyncCount"]
    - path: "src/hooks/useSyncQueue.ts"
      provides: "Hook for triggering sync and getting pending count"
      exports: ["useSyncQueue"]
    - path: "src/components/pwa/SyncStatusIndicator.tsx"
      provides: "Sync icon with pending badge"
      exports: ["SyncStatusIndicator"]
  key_links:
    - from: "src/lib/pwa/syncQueue.ts"
      to: "src/lib/supabaseClient.ts"
      via: "supabase insert"
      pattern: "supabase.*from.*mock_tests"
    - from: "src/contexts/OfflineContext.tsx"
      to: "src/lib/pwa/syncQueue.ts"
      via: "sync trigger on online"
      pattern: "syncAllPendingResults"
---

<objective>
Implement offline sync queue for test results with auto-sync on reconnection.

Purpose: Users can complete tests offline and have results automatically synced when back online. Per user decision: auto-retry with exponential backoff, manual retry button, sync feedback in header with badge count.
Output: Test results saved to IndexedDB when offline, synced to Supabase when online with visual feedback.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pwa-offline/02-RESEARCH.md
@.planning/phases/02-pwa-offline/02-01-SUMMARY.md

@src/lib/pwa/offlineDb.ts
@src/lib/supabaseClient.ts
@src/contexts/SupabaseAuthContext.tsx
@src/contexts/OfflineContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend offlineDb and create syncQueue module</name>
  <files>
    src/lib/pwa/offlineDb.ts
    src/lib/pwa/syncQueue.ts
  </files>
  <action>
1. Extend src/lib/pwa/offlineDb.ts to add sync queue operations:
   ```typescript
   // Add to existing file after syncQueueStore declaration:

   interface PendingTestResult {
     id: string;
     userId: string;
     score: number;
     totalQuestions: number;
     durationSeconds: number;
     passed: boolean;
     endReason: string;
     createdAt: string;
     responses: Array<{
       questionId: string;
       selectedAnswer: string;
       correct: boolean;
       timeSpentSeconds: number;
     }>;
   }

   // Queue test result for sync
   export async function queueTestResult(result: PendingTestResult): Promise<string> {
     const id = `pending-${Date.now()}-${Math.random().toString(36).slice(2)}`;
     await set(id, result, syncQueueStore);
     return id;
   }

   // Get all pending results
   export async function getPendingResults(): Promise<Array<{ key: string; data: PendingTestResult }>> {
     const allKeys = await keys(syncQueueStore);
     const results: Array<{ key: string; data: PendingTestResult }> = [];
     for (const key of allKeys) {
       const result = await get<PendingTestResult>(key, syncQueueStore);
       if (result) results.push({ key: String(key), data: result });
     }
     return results;
   }

   // Remove synced result
   export async function removeSyncedResult(id: string): Promise<void> {
     await del(id, syncQueueStore);
   }

   // Count pending items for badge
   export async function getPendingSyncCount(): Promise<number> {
     const allKeys = await keys(syncQueueStore);
     return allKeys.length;
   }

   export type { PendingTestResult };
   ```

2. Create src/lib/pwa/syncQueue.ts:
   ```typescript
   import { getPendingResults, removeSyncedResult, getPendingSyncCount, type PendingTestResult } from "./offlineDb";
   import { supabase } from "@/lib/supabaseClient";

   const MAX_RETRIES = 5;
   const BASE_DELAY_MS = 1000;

   export interface SyncProgress {
     current: number;
     total: number;
     status: "syncing" | "success" | "error";
   }

   async function syncSingleResult(
     key: string,
     data: PendingTestResult
   ): Promise<boolean> {
     let retries = 0;

     while (retries < MAX_RETRIES) {
       try {
         // Insert mock test
         const { data: testData, error: testError } = await supabase
           .from("mock_tests")
           .insert({
             user_id: data.userId,
             score: data.score,
             total_questions: data.totalQuestions,
             duration_seconds: data.durationSeconds,
             passed: data.passed,
             end_reason: data.endReason,
             created_at: data.createdAt,
           })
           .select("id")
           .single();

         if (testError) throw testError;

         // Insert responses
         if (data.responses.length > 0 && testData) {
           const responsesToInsert = data.responses.map((r) => ({
             mock_test_id: testData.id,
             question_id: r.questionId,
             selected_answer: r.selectedAnswer,
             is_correct: r.correct,
             time_spent_seconds: r.timeSpentSeconds,
           }));

           const { error: responseError } = await supabase
             .from("mock_test_responses")
             .insert(responsesToInsert);

           if (responseError) throw responseError;
         }

         await removeSyncedResult(key);
         return true;
       } catch (error) {
         retries++;
         if (retries < MAX_RETRIES) {
           const delay = BASE_DELAY_MS * Math.pow(2, retries);
           await new Promise((resolve) => setTimeout(resolve, delay));
         } else {
           console.error("Failed to sync result after max retries:", error);
         }
       }
     }

     return false;
   }

   export async function syncAllPendingResults(
     onProgress?: (progress: SyncProgress) => void
   ): Promise<{ synced: number; failed: number }> {
     const pending = await getPendingResults();
     if (pending.length === 0) {
       return { synced: 0, failed: 0 };
     }

     let synced = 0;
     let failed = 0;

     onProgress?.({ current: 0, total: pending.length, status: "syncing" });

     for (let i = 0; i < pending.length; i++) {
       const { key, data } = pending[i];
       const success = await syncSingleResult(key, data);

       if (success) synced++;
       else failed++;

       onProgress?.({
         current: i + 1,
         total: pending.length,
         status: "syncing",
       });
     }

     onProgress?.({
       current: pending.length,
       total: pending.length,
       status: failed > 0 ? "error" : "success",
     });

     return { synced, failed };
   }

   export { getPendingSyncCount };
   ```
  </action>
  <verify>
    pnpm run typecheck passes
    pnpm run lint passes
  </verify>
  <done>
    offlineDb exports queue functions, syncQueue implements exponential backoff sync to Supabase
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync hook and indicator component</name>
  <files>
    src/hooks/useSyncQueue.ts
    src/components/pwa/SyncStatusIndicator.tsx
  </files>
  <action>
1. Create src/hooks/useSyncQueue.ts:
   ```typescript
   import { useState, useEffect, useCallback } from "react";
   import { useOnlineStatus } from "./useOnlineStatus";
   import { syncAllPendingResults, getPendingSyncCount, type SyncProgress } from "@/lib/pwa/syncQueue";

   interface UseSyncQueueResult {
     pendingCount: number;
     isSyncing: boolean;
     lastSyncResult: { synced: number; failed: number } | null;
     triggerSync: () => Promise<void>;
     refreshCount: () => Promise<void>;
   }

   export function useSyncQueue(): UseSyncQueueResult {
     const isOnline = useOnlineStatus();
     const [pendingCount, setPendingCount] = useState(0);
     const [isSyncing, setIsSyncing] = useState(false);
     const [lastSyncResult, setLastSyncResult] = useState<{ synced: number; failed: number } | null>(null);

     const refreshCount = useCallback(async () => {
       const count = await getPendingSyncCount();
       setPendingCount(count);
     }, []);

     const triggerSync = useCallback(async () => {
       if (isSyncing || !isOnline) return;

       setIsSyncing(true);
       try {
         const result = await syncAllPendingResults();
         setLastSyncResult(result);
         await refreshCount();
       } finally {
         setIsSyncing(false);
       }
     }, [isSyncing, isOnline, refreshCount]);

     // Refresh count on mount and when sync completes
     useEffect(() => {
       refreshCount();
     }, [refreshCount]);

     // Auto-sync when coming back online
     useEffect(() => {
       if (isOnline && pendingCount > 0 && !isSyncing) {
         triggerSync();
       }
     }, [isOnline, pendingCount, isSyncing, triggerSync]);

     return {
       pendingCount,
       isSyncing,
       lastSyncResult,
       triggerSync,
       refreshCount,
     };
   }
   ```

2. Create src/components/pwa/SyncStatusIndicator.tsx:
   ```typescript
   import React from "react";
   import { RefreshCw } from "lucide-react";
   import { useSyncQueue } from "@/hooks/useSyncQueue";

   export function SyncStatusIndicator() {
     const { pendingCount, isSyncing, triggerSync } = useSyncQueue();

     // Don't show if nothing pending and not syncing
     if (pendingCount === 0 && !isSyncing) {
       return null;
     }

     return (
       <button
         onClick={() => triggerSync()}
         disabled={isSyncing}
         className="relative flex items-center justify-center p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 disabled:opacity-50"
         title={isSyncing ? "Syncing..." : `${pendingCount} pending`}
         aria-label={isSyncing ? "Syncing offline results" : `${pendingCount} results waiting to sync`}
       >
         <RefreshCw
           className={`h-4 w-4 ${isSyncing ? "animate-spin" : ""}`}
           aria-hidden="true"
         />
         {/* Badge count per user decision */}
         {pendingCount > 0 && !isSyncing && (
           <span
             className="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-orange-500 text-[10px] font-medium text-white"
             aria-hidden="true"
           >
             {pendingCount > 9 ? "9+" : pendingCount}
           </span>
         )}
       </button>
     );
   }
   ```
  </action>
  <verify>
    pnpm run typecheck passes
    pnpm run lint passes
  </verify>
  <done>
    useSyncQueue auto-syncs when online, SyncStatusIndicator shows badge and spinning icon
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate sync into OfflineContext and AppNavigation</name>
  <files>
    src/contexts/OfflineContext.tsx
    src/components/AppNavigation.tsx
  </files>
  <action>
1. Update src/contexts/OfflineContext.tsx to expose sync state:
   - Add pendingSyncCount to context value (from useSyncQueue or direct call)
   - Add refreshPendingCount method
   - Add triggerSync method
   - Note: The useSyncQueue hook handles auto-sync internally, but context should expose pending count for other components

2. Update src/components/AppNavigation.tsx:
   - Import SyncStatusIndicator from "@/components/pwa/SyncStatusIndicator"
   - Add SyncStatusIndicator next to OnlineStatusIndicator in header
   - Position: sync indicator should be near the status dot, slightly separated
   - The sync indicator only appears when there are pending items

3. Add sync completion toast notification:
   - In useSyncQueue, when sync completes successfully and synced > 0, show bilingual toast
   - Use existing toast mechanism (check if BilingualToast is available)
   - English: "Synced {n} offline result(s)"
   - Burmese: "အော့ဖ်လိုင်း ရလဒ် {n} ခု စင့်ခ်လုပ်ပြီးပါပြီ"
   - If failed > 0: "Failed to sync {n} result(s). Will retry."
  </action>
  <verify>
    pnpm run build succeeds
    pnpm run typecheck passes
    Sync indicator appears in header when pending items exist
  </verify>
  <done>
    SyncStatusIndicator visible in header with badge, toast shows on sync completion
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm run build` and `pnpm start`
2. Verify logged in state (sync requires user ID per user decision)
3. Go offline (DevTools Network: Offline)
4. Complete a test - should see "Results saved offline" notice
5. Check IndexedDB for pending result entry
6. Go back online - should see sync indicator spin, then toast
7. Check IndexedDB - pending result should be removed
8. Check Supabase - result should appear in mock_tests table
</verification>

<success_criteria>
- Test results queued in IndexedDB when offline
- Sync indicator shows badge with pending count (e.g., "3")
- Sync icon spins during sync
- Auto-sync triggers when coming back online
- Exponential backoff on failed sync (observe in network tab)
- Bilingual toast confirms sync completion
- Manual retry button works (click sync icon)
- Synced results appear in Supabase
</success_criteria>

<output>
After completion, create `.planning/phases/02-pwa-offline/02-03-SUMMARY.md`
</output>
