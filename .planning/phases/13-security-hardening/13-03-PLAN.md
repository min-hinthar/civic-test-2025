---
phase: 13-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
  - .planning/security/rls-audit.md
autonomous: true

must_haves:
  truths:
    - "push_subscriptions table is defined in schema.sql with RLS policies"
    - "Every table in schema.sql has enable row level security"
    - "All RLS policies are documented in .planning/security/rls-audit.md"
    - "security_definer functions (get_leaderboard, get_user_rank) are documented with justification"
    - "No table allows unrestricted public access without documented justification"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "push_subscriptions table with RLS policies"
      contains: "push_subscriptions"
    - path: ".planning/security/rls-audit.md"
      provides: "Comprehensive RLS audit documentation"
      contains: "push_subscriptions"
  key_links:
    - from: "supabase/schema.sql"
      to: "pages/api/push/subscribe.ts"
      via: "push_subscriptions table used by subscribe API"
      pattern: "push_subscriptions"
    - from: ".planning/security/rls-audit.md"
      to: "supabase/schema.sql"
      via: "Documents every table and policy from schema"
      pattern: "RLS"
---

<objective>
Add the missing push_subscriptions table to schema.sql with RLS policies, and create a comprehensive audit document covering all Supabase tables, RLS policies, and security_definer functions.

Purpose: The push_subscriptions table was created manually in Supabase without documented RLS. All tables need a unified audit document for ongoing security review. Per user decision: "Review AND fix -- audit all tables, document policies, and tighten overly permissive ones."

Output: Updated schema.sql with push_subscriptions + RLS, new .planning/security/rls-audit.md audit document.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/schema.sql
@pages/api/push/subscribe.ts
@pages/api/push/send.ts
@pages/api/push/srs-reminder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add push_subscriptions table with RLS to schema.sql</name>
  <files>supabase/schema.sql</files>
  <action>
Add a `push_subscriptions` table section to `supabase/schema.sql`, placed after the earned_badges section and before the leaderboard functions. Include clear section header comments.

**Table definition (matching what the subscribe API currently expects):**
```sql
-- ============================================================
-- Push Notification Subscriptions (Phase 2 - PWA)
-- ============================================================
-- NOTE: This table was originally created manually in Supabase.
-- Added to schema.sql in Phase 13 (Security Hardening) with RLS policies.
-- The subscribe API (pages/api/push/subscribe.ts) uses SUPABASE_SERVICE_ROLE_KEY
-- to bypass RLS for upsert/delete operations AFTER verifying the user's JWT.
-- Cron endpoints (send.ts, srs-reminder.ts, weak-area-nudge.ts) also use
-- service role key to read all subscriptions for cross-user notification delivery.

create table if not exists public.push_subscriptions (
  user_id uuid primary key references public.profiles (id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  reminder_frequency text not null default 'daily'
    check (reminder_frequency in ('daily', 'every2days', 'weekly', 'off')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**RLS policies:**
```sql
alter table public.push_subscriptions enable row level security;

-- Users can read their own push subscription status
drop policy if exists "Users can view own push subscription" on public.push_subscriptions;
create policy "Users can view own push subscription" on public.push_subscriptions
  for select using (auth.uid() = user_id);

-- Users can manage their own push subscription (insert/update/delete)
drop policy if exists "Users can manage own push subscription" on public.push_subscriptions;
create policy "Users can manage own push subscription" on public.push_subscriptions
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);
```

**Add a `display_name` length constraint to social_profiles** (flagged in research as needing server-side validation -- currently only client-side 2-30 chars):
```sql
-- Add display_name length constraint if not exists
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'social_profiles_display_name_length'
  ) then
    alter table public.social_profiles
      add constraint social_profiles_display_name_length
      check (char_length(display_name) between 2 and 30);
  end if;
end $$;
```

Place this constraint addition right after the social_profiles table definition (after the `enable row level security` and policies block).

**Add SQL comments to security_definer functions:**
Add a block comment above each `security definer` function explaining WHY it uses definer:

Above `get_leaderboard`:
```sql
-- security definer: Required because leaderboard queries all opted-in social_profiles,
-- not just the calling user's row. RLS would restrict to auth.uid() = user_id only.
-- Safe because: only returns display_name, score, streak, badge of opted-in users.
-- Granted to: authenticated, anon (public leaderboard is intentional).
```

Above `get_user_rank`:
```sql
-- security definer: Required to compute rank across all opted-in users.
-- RLS would restrict to auth.uid() = user_id only, preventing ranking calculation.
-- Safe because: only returns a single bigint rank number, no PII.
-- Granted to: authenticated only (user must be logged in to see their rank).
```
  </action>
  <verify>
1. Read `supabase/schema.sql` and confirm: push_subscriptions table with RLS policies exists, display_name constraint on social_profiles exists, security_definer comments exist.
2. Run `pnpm run typecheck` (should be unaffected by SQL changes, but verifies no accidental file corruption).
3. Verify push_subscriptions has `enable row level security` + at least a select and an all/insert/update/delete policy.
  </verify>
  <done>
- push_subscriptions table defined in schema.sql with proper types and constraints
- RLS enabled on push_subscriptions with user-scoped policies
- display_name length constraint added to social_profiles
- security_definer functions have SQL comments explaining WHY they need definer
- All SQL is idempotent (uses IF NOT EXISTS, DROP IF EXISTS patterns)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive RLS audit document</name>
  <files>.planning/security/rls-audit.md</files>
  <action>
Create `.planning/security/rls-audit.md` (create the `security/` directory if it doesn't exist).

**Document structure:**

```markdown
# Supabase Row Level Security Audit

**Audit Date:** [current date]
**Auditor:** Claude (Phase 13 - Security Hardening)
**Schema File:** `supabase/schema.sql`

## Summary

[Brief summary: N tables audited, all have RLS enabled, N functions reviewed, no unrestricted public access found]

## Tables

### profiles
- **RLS:** Enabled
- **Policies:**
  - SELECT: Owner only (`auth.uid() = id`)
  - INSERT: Owner only (`auth.uid() = id`)
  - UPDATE: Owner only (`auth.uid() = id`)
  - DELETE: Not allowed (cascade from auth.users)
- **Risk Level:** Low
- **Notes:** Automatically populated by `handle_new_user()` trigger on auth.users insert.

### mock_tests
[Same format for each table]

### mock_test_responses
[Include note about the subquery join to mock_tests for user_id verification]

### srs_cards
[Full CRUD for owner]

### interview_sessions
[SELECT + INSERT for owner]

### social_profiles
[Note the public SELECT for opted-in users -- intentional for leaderboard]

### streak_data
[ALL + INSERT for owner]

### earned_badges
[Note the cross-table join for opted-in user badge visibility]

### push_subscriptions (NEW)
[Added in Phase 13, policies documented]

## Functions

### handle_new_user() - SECURITY DEFINER
- **Purpose:** Auto-populate profiles on auth.users insert
- **Justification:** Trigger runs on auth schema, needs access to public.profiles
- **Risk:** Low -- only reads new.id/email/metadata from auth.users insert event
- **Granted to:** Trigger (not callable directly)

### get_leaderboard() - SECURITY DEFINER
- **Purpose:** Query all opted-in social profiles for ranking
- **Justification:** RLS would restrict to calling user only; leaderboard needs cross-user data
- **Risk:** Low -- only returns display_name, score, streak, badge of opted-in users
- **Granted to:** authenticated, anon

### get_user_rank() - SECURITY DEFINER
- **Purpose:** Compute caller's rank among opted-in users
- **Justification:** RLS would restrict to calling user only; ranking needs cross-user data
- **Risk:** Low -- returns only a bigint rank number
- **Granted to:** authenticated

## Storage Buckets

No Supabase Storage buckets are in use. Nothing to audit.

## Edge Functions

No Supabase Edge Functions are deployed. Nothing to audit.

## Service Role Key Usage

### pages/api/push/subscribe.ts
- **Uses:** SUPABASE_SERVICE_ROLE_KEY for upsert/delete on push_subscriptions
- **Justification:** After Phase 13, JWT is verified first, then service role used for the database operation. Could be replaced with user-scoped client + RLS in a future iteration, but service role is acceptable since auth is verified upstream.
- **Risk:** Medium -- if JWT verification is bypassed, service role grants full access. Mitigated by: JWT verification is the first check, rate limiting is second.

### pages/api/push/send.ts, srs-reminder.ts, weak-area-nudge.ts
- **Uses:** SUPABASE_SERVICE_ROLE_KEY (or CRON_SECRET/API key auth)
- **Justification:** Cron-triggered endpoints that need to read ALL user subscriptions to send notifications. Cannot use per-user auth (no user context in cron).
- **Risk:** Low -- endpoints are server-to-server only, protected by cron secret/API key.

## Recommendations

1. [Any findings about overly permissive policies]
2. [Any recommendations for future hardening]
```

**Fill in each section** by reading the actual policies from `supabase/schema.sql`. Be precise about which operations each policy covers (SELECT, INSERT, UPDATE, DELETE, ALL) and the condition (auth.uid() = user_id, subquery, etc.).

Include a final "Recommendations" section with actionable findings. For example:
- The `streak_data` table has both an ALL policy and a separate INSERT policy -- the ALL policy already covers insert, so the INSERT policy is redundant (not harmful, just unnecessary).
- Consider adding a DELETE policy restriction on social_profiles (currently no explicit delete policy -- falls under the ALL-less approach where delete is implicitly denied by RLS if no policy exists for it).
  </action>
  <verify>
1. Read `.planning/security/rls-audit.md` and confirm: all 9 tables documented, all 3 functions documented, storage + edge function sections present, service role usage documented.
2. Verify every table in `supabase/schema.sql` appears in the audit document.
3. Verify the document includes Storage Buckets and Edge Functions sections (even if empty per user decision "Full Supabase audit").
  </verify>
  <done>
- .planning/security/rls-audit.md exists with all 9 tables documented
- Each table entry includes: RLS status, policy details (operation + condition), risk level, notes
- All 3 security_definer functions documented with justification
- Storage and Edge Functions sections present (noting nothing to audit)
- Service role key usage documented for all API routes
- Recommendations section with actionable findings
  </done>
</task>

</tasks>

<verification>
1. `supabase/schema.sql` contains push_subscriptions table with RLS enabled and policies
2. `supabase/schema.sql` contains display_name length constraint on social_profiles
3. `.planning/security/rls-audit.md` documents all tables, functions, storage, and edge functions
4. No table in schema.sql is missing from the audit document
5. `pnpm run typecheck` passes (SQL changes don't affect TS)
</verification>

<success_criteria>
- push_subscriptions table defined in schema.sql with RLS
- All 9 Supabase tables have documented RLS policies
- All security_definer functions have documented justification
- Full Supabase audit (tables, storage, edge functions) documented
- Service role key usage documented with risk assessment
</success_criteria>

<output>
After completion, create `.planning/phases/13-security-hardening/13-03-SUMMARY.md`
</output>
