---
phase: 05-spaced-repetition
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/contexts/SRSContext.tsx
  - src/hooks/useSRSDeck.ts
  - src/hooks/useSRSReview.ts
  - src/hooks/useSRSWidget.ts
  - src/AppShell.tsx
autonomous: true

must_haves:
  truths:
    - "SRSProvider loads deck from IndexedDB on mount and provides deck state to all children"
    - "Components can add/remove cards and grade them via context"
    - "Due count updates reactively when cards are graded or time passes"
    - "SRS works without login using local IndexedDB only"
  artifacts:
    - path: "src/contexts/SRSContext.tsx"
      provides: "SRSProvider and useSRS hook for deck state"
      exports: ["SRSProvider", "useSRS"]
    - path: "src/hooks/useSRSDeck.ts"
      provides: "Hook for deck management (add, remove, bulk-add)"
      exports: ["useSRSDeck"]
    - path: "src/hooks/useSRSReview.ts"
      provides: "Hook for review session state machine"
      exports: ["useSRSReview"]
    - path: "src/hooks/useSRSWidget.ts"
      provides: "Hook for dashboard widget data (due count, streak, category breakdown)"
      exports: ["useSRSWidget"]
  key_links:
    - from: "src/contexts/SRSContext.tsx"
      to: "src/lib/srs/srsStore.ts"
      via: "getAllSRSCards on mount"
      pattern: "getAllSRSCards"
    - from: "src/contexts/SRSContext.tsx"
      to: "src/lib/srs/srsSync.ts"
      via: "sync on auth state change"
      pattern: "pullSRSCards|pushSRSCards"
    - from: "src/AppShell.tsx"
      to: "src/contexts/SRSContext.tsx"
      via: "SRSProvider in provider hierarchy"
      pattern: "SRSProvider"
---

<objective>
Create the SRSContext provider and specialized hooks that expose SRS deck state, review session logic, and widget data to the entire application.

Purpose: Central state management layer that all SRS UI components will consume. Handles in-memory deck, optimistic updates, sync triggers, and due-count reactivity.
Output: SRSContext provider wired into AppShell, plus useSRSDeck, useSRSReview, and useSRSWidget hooks.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-spaced-repetition/05-RESEARCH.md
@src/contexts/OfflineContext.tsx
@src/contexts/SupabaseAuthContext.tsx
@src/AppShell.tsx
@src/lib/srs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SRSContext provider with deck state management</name>
  <files>
    src/contexts/SRSContext.tsx
    src/AppShell.tsx
  </files>
  <action>
    1. Create `src/contexts/SRSContext.tsx` following the pattern from OfflineContext.tsx:

    **SRSContextValue interface:**
    ```
    {
      deck: SRSCardRecord[];         // All cards in user's deck
      dueCount: number;              // Cards currently due
      isLoading: boolean;            // Initial load in progress
      addCard: (questionId: string) => Promise<void>;
      removeCard: (questionId: string) => Promise<void>;
      gradeCard: (questionId: string, isEasy: boolean) => Promise<{ card: Card; intervalText: { en: string; my: string } }>;
      isInDeck: (questionId: string) => boolean;
      refreshDeck: () => Promise<void>;
      getDueCards: () => SRSCardRecord[];
    }
    ```

    **SRSProvider implementation:**
    - State: `deck` (SRSCardRecord[]), `isLoading` (boolean)
    - On mount: load all cards from IndexedDB via `getAllSRSCards()`. Use effect with cancelled flag pattern (same as Dashboard.tsx answer history load).
    - Compute `dueCount` as derived value: `const dueCount: number = useMemo(() => deck.filter(r => isDue(r.card)).length, [deck])`
    - `getDueCards()`: return deck filtered by isDue, sorted by due date ascending (most overdue first)
    - `addCard(questionId)`: create new FSRS card via `createNewSRSCard()`, create SRSCardRecord, call `setSRSCard()` to persist, optimistically update in-memory deck state. If user is logged in, queue sync.
    - `removeCard(questionId)`: call `removeSRSCard()`, remove from in-memory deck. Queue delete sync if logged in.
    - `gradeCard(questionId, isEasy)`: find card in deck, call `gradeCard()` from engine, update SRSCardRecord with new card state and lastReviewedAt, persist to IndexedDB, optimistically update in-memory deck, queue sync. Return the updated card and bilingual interval text.
    - `isInDeck(questionId)`: check in-memory deck for questionId
    - `refreshDeck()`: reload from IndexedDB

    **Sync integration:**
    - Import `useAuth` from SupabaseAuthContext
    - When user.id is available and deck is loaded, trigger sync:
      - First `syncPendingSRSReviews(user.id)` to push queued offline changes
      - Then `pullSRSCards(user.id)` to get remote state
      - Merge with `mergeSRSDecks(local, remote)`
      - Write merged deck back to IndexedDB and update in-memory state
      - Push merged state back to Supabase with `pushSRSCards(user.id, merged)`
    - This sync happens once on mount when user is logged in. No manual sync button (per user decision: auto-sync only).

    **Due count reactivity (Pitfall 6 from research):**
    - Add `visibilitychange` event listener that triggers `refreshDeck()` when document becomes visible
    - This ensures due count updates after midnight or after the app was backgrounded

    **SRS works without login (per discretion recommendation):**
    - All local operations (add, remove, grade) work without auth
    - Sync only triggers when `user?.id` is available
    - When user logs in for first time, local deck syncs up

    2. Wire SRSProvider into AppShell.tsx:
    - Add `<SRSProvider>` in the provider hierarchy. Place it inside OfflineProvider and LanguageProvider but wrapping the Routes. It needs auth context, so it should be inside any auth provider. Look at the existing nesting in AppShell.tsx and place SRSProvider at the appropriate level (after SupabaseAuthProvider, before Routes).

    IMPORTANT React Compiler rules:
    - Do NOT use `useMemo<SRSCardRecord[]>(...)` -- use `const x: SRSCardRecord[] = useMemo(...)`
    - For setState in effects (loading deck), use the cancelled flag pattern with comment: `// eslint-disable-next-line react-hooks/set-state-in-effect -- intentional: async data load`
    - Do NOT read ref.current during render
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - SRSProvider renders without error (no runtime crashes)
    - AppShell.tsx includes SRSProvider in provider hierarchy
  </verify>
  <done>
    - SRSProvider loads deck from IndexedDB on mount
    - Add/remove/grade operations persist to IDB and update in-memory state optimistically
    - Sync triggers automatically when user is logged in
    - Due count recomputes on visibility change
    - Works without login (local IndexedDB only)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useSRSDeck, useSRSReview, and useSRSWidget hooks</name>
  <files>
    src/hooks/useSRSDeck.ts
    src/hooks/useSRSReview.ts
    src/hooks/useSRSWidget.ts
  </files>
  <action>
    1. Create `src/hooks/useSRSDeck.ts`:
       - Thin wrapper around SRSContext for deck management convenience
       - `useSRSDeck()` returns: `{ deck, dueCount, isLoading, addCard, removeCard, isInDeck, bulkAddCards }`
       - `bulkAddCards(questionIds: string[]): Promise<number>` -- adds multiple cards at once. Loops through questionIds, skips any already in deck, calls addCard for each. Returns count of newly added cards. This supports the "Add all weak questions" bulk-add feature (per discretion: support both individual and bulk).
       - Import `detectWeakAreas` from `@/lib/mastery` for a convenience: `getWeakQuestionIds(categoryMasteries): string[]` that returns question IDs from weak categories (< 60% mastery). Uses `getCategoryQuestionIds` from mastery/categoryMapping.

    2. Create `src/hooks/useSRSReview.ts`:
       - State machine hook for review session: setup -> reviewing -> summary
       - `useSRSReview()` returns:
         ```
         {
           phase: SessionPhase;
           cards: SRSCardRecord[];      // Cards for this session
           currentIndex: number;
           sessionSize: number;
           results: ReviewResult[];
           timerEnabled: boolean;
           startSession: (size: number, timerEnabled: boolean) => void;
           rateCard: (isEasy: boolean) => Promise<void>;
           exitSession: () => void;       // Mid-session exit
           totalDue: number;              // Total due cards available
         }
         ```
       - `startSession(size, timerEnabled)`:
         - Get due cards from context `getDueCards()`
         - Slice to requested session size
         - Set phase to 'reviewing', currentIndex to 0, clear results
       - `rateCard(isEasy)`:
         - Call context `gradeCard(currentCard.questionId, isEasy)`
         - Push result to results array (questionId, rating, intervalText)
         - If currentIndex < cards.length - 1: advance to next card
         - Else: set phase to 'summary'
       - `exitSession()`:
         - Per user decision: "Exit mid-session saves progress -- reviewed cards update, remaining stay in queue"
         - Set phase to 'summary' (results array has only reviewed cards)
       - Per discretion decision: Do NOT re-queue Hard cards within session. FSRS Rating.Again with enable_short_term will schedule them for minutes later naturally.

    3. Create `src/hooks/useSRSWidget.ts`:
       - Hook providing data for the dashboard SRS widget
       - `useSRSWidget()` returns:
         ```
         {
           dueCount: number;
           reviewStreak: number;          // Consecutive days with at least 1 review
           categoryBreakdown: { categoryId: string; dueCount: number; totalCount: number }[];
           isEmpty: boolean;              // No cards in deck at all
           isAllCaughtUp: boolean;        // Cards exist but none due
           nextDueText: { en: string; my: string } | null;  // When next card is due
         }
         ```
       - `reviewStreak`: Compute from deck's lastReviewedAt dates. Group by calendar date, count consecutive days backwards from today. Separate from existing study streak (per user decision).
       - `categoryBreakdown`: Group deck cards by their question's category (lookup via civicsQuestions). Count due vs total per category.
       - `nextDueText`: If isAllCaughtUp, find the card with earliest future due date and return getNextReviewText for it.

    IMPORTANT: All hooks use `useSRS()` context internally. No direct IndexedDB access from hooks.
    React Compiler rules apply: no useMemo<T>(), no setState in effects without comment, no ref.current in render.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - All three hooks export correctly
    - No ESLint errors in hook files
  </verify>
  <done>
    - useSRSDeck provides deck CRUD + bulk-add for weak questions
    - useSRSReview implements setup/reviewing/summary state machine with mid-session exit
    - useSRSWidget provides dashboard data: due count, review streak, category breakdown, empty/caught-up states
    - All hooks consume SRSContext, no direct IDB access
  </done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- SRSProvider in AppShell provider hierarchy
- All hooks type-check and export correctly
- No React Compiler ESLint violations
</verification>

<success_criteria>
- SRSContext provides centralized deck state with optimistic updates
- Review session state machine handles setup -> reviewing -> summary lifecycle
- Widget hook provides all data needed for dashboard display
- Sync integrates with auth state automatically
- Works offline-first, syncs when user logs in
</success_criteria>

<output>
After completion, create `.planning/phases/05-spaced-repetition/05-03-SUMMARY.md`
</output>
