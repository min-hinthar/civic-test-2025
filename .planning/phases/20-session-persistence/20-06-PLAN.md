---
phase: 20-session-persistence
plan: 06
type: execute
wave: 3
depends_on: ["20-01", "20-02", "20-03"]
files_modified:
  - src/pages/PracticePage.tsx
  - src/components/practice/PracticeSession.tsx
  - src/pages/InterviewPage.tsx
  - src/components/interview/InterviewSession.tsx
autonomous: true

must_haves:
  truths:
    - "User who closes browser mid-practice sees resume prompt with session info when returning"
    - "Resumed practice session restores exact question set, progress, category config, and results"
    - "User who closes browser mid-interview sees resume prompt with session info when returning"
    - "Resumed interview session restores questions, results, counts, and mode"
    - "Practice and interview sessions are saved after every answer/grade"
    - "Sessions are deleted from IndexedDB when sessions complete"
    - "Practice countdown shows only when timer is enabled (both new and resumed)"
  artifacts:
    - path: "src/pages/PracticePage.tsx"
      provides: "Practice page with session persistence, resume prompt"
      contains: "ResumePromptModal"
    - path: "src/components/practice/PracticeSession.tsx"
      provides: "Practice session component that saves progress after each answer"
      contains: "saveSession"
    - path: "src/pages/InterviewPage.tsx"
      provides: "Interview page with session persistence, resume prompt"
      contains: "ResumePromptModal"
    - path: "src/components/interview/InterviewSession.tsx"
      provides: "Interview session component that saves progress after each grade"
      contains: "saveSession"
  key_links:
    - from: "src/pages/PracticePage.tsx"
      to: "src/components/sessions/ResumePromptModal.tsx"
      via: "Shows resume modal on mount when saved sessions exist"
      pattern: "ResumePromptModal"
    - from: "src/components/practice/PracticeSession.tsx"
      to: "src/lib/sessions/sessionStore.ts"
      via: "saveSession after each answer"
      pattern: "import.*saveSession"
    - from: "src/pages/InterviewPage.tsx"
      to: "src/components/sessions/ResumePromptModal.tsx"
      via: "Shows resume modal on mount when saved sessions exist"
      pattern: "ResumePromptModal"
    - from: "src/components/interview/InterviewSession.tsx"
      to: "src/lib/sessions/sessionStore.ts"
      via: "saveSession after each grade"
      pattern: "import.*saveSession"
---

<objective>
Integrate session persistence into PracticePage and InterviewPage: save progress, show resume prompts, restore sessions on resume, clean up on completion.

Purpose: This implements SESS-02 (practice) and SESS-03 (interview) -- users never lose progress in practice or interview sessions.

Output: Modified PracticePage, PracticeSession, InterviewPage, and InterviewSession with full session persistence.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-session-persistence/20-RESEARCH.md
@.planning/phases/20-session-persistence/20-CONTEXT.md
@.planning/phases/20-session-persistence/20-01-SUMMARY.md
@.planning/phases/20-session-persistence/20-02-SUMMARY.md
@.planning/phases/20-session-persistence/20-03-SUMMARY.md
@src/pages/PracticePage.tsx
@src/components/practice/PracticeSession.tsx
@src/pages/InterviewPage.tsx
@src/components/interview/InterviewSession.tsx
@src/lib/sessions/sessionTypes.ts
@src/lib/sessions/sessionStore.ts
@src/components/sessions/ResumePromptModal.tsx
@src/components/sessions/SessionCountdown.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: PracticePage session persistence</name>
  <files>src/pages/PracticePage.tsx, src/components/practice/PracticeSession.tsx</files>
  <action>
**Modify `src/pages/PracticePage.tsx`:**

1. **New imports:**
   ```typescript
   import { saveSession, getSessionsByType, deleteSession } from '@/lib/sessions/sessionStore';
   import type { PracticeSnapshot, SessionSnapshot } from '@/lib/sessions/sessionTypes';
   import { SESSION_VERSION } from '@/lib/sessions/sessionTypes';
   import { ResumePromptModal } from '@/components/sessions/ResumePromptModal';
   import { SessionCountdown } from '@/components/sessions/SessionCountdown';
   ```

2. **New state:**
   ```typescript
   const [savedSessions, setSavedSessions] = useState<PracticeSnapshot[]>([]);
   const [showResumeModal, setShowResumeModal] = useState(false);
   const [showCountdown, setShowCountdown] = useState(false);
   const [sessionId] = useState(() => `session-practice-${Date.now()}`);
   const [isResuming, setIsResuming] = useState(false);
   const [practiceConfig, setPracticeConfig] = useState<PracticeSnapshot['config'] | null>(null);
   ```

3. **Check for saved sessions on mount:**
   ```typescript
   useEffect(() => {
     let cancelled = false;
     getSessionsByType('practice').then(sessions => {
       if (!cancelled && sessions.length > 0) {
         setSavedSessions(sessions as PracticeSnapshot[]);
         setShowResumeModal(true);
       }
     }).catch(() => {});
     return () => { cancelled = true; };
   }, []);
   ```

4. **Resume handler:**
   When user clicks Resume on the modal:
   - Restore questions, results, currentIndex, timerEnabled, config from the PracticeSnapshot
   - Set `practiceQuestions` to the saved questions
   - Set `practiceResults` to an empty array (the session will continue from currentIndex)
   - BUT the session saves results incrementally, so we need to pass the saved currentIndex and results to PracticeSession
   - Set phase to 'session' (skip config)
   - Also set `categoryName` and `timerEnabled` from saved config
   - If timerEnabled, show countdown before session
   - Use fresh timer (full duration) per user decision

   Actually, the PracticePage manages `phase` as a state machine (config -> session -> results). On resume:
   - Skip config phase, go straight to session
   - Pass restored questions to PracticeSession
   - PracticeSession needs to accept initial results and currentIndex for resume

5. **Start Fresh handler:**
   Delete session, clear saved sessions state, close modal.

6. **Not Now handler:**
   Close modal, keep session.

7. **Modify handleStart to save config:**
   Store the practice config so it can be saved in snapshots:
   ```typescript
   setPracticeConfig({ category: config.category, categoryName: config.categoryName, count: config.count });
   ```

8. **Add sessionId prop to PracticeSession:**
   Pass `sessionId`, `practiceConfig`, and resume state (initial results, initial index) to PracticeSession.

9. **Delete session on completion:**
   In `handleComplete` callback, delete the session:
   ```typescript
   deleteSession(sessionId).catch(() => {});
   ```

10. **Render ResumePromptModal in config phase:**
    Show the modal overlay when in config phase and saved sessions exist.

11. **Render SessionCountdown:**
    Show countdown when `showCountdown` is true and timer is enabled.
    Subtitle: "Practice: {categoryName.en} — Q{index}/{count}" for resume, "Practice: {categoryName.en} — {count} Questions" for new.

**Modify `src/components/practice/PracticeSession.tsx`:**

1. **Add new props:**
   ```typescript
   interface PracticeSessionProps {
     questions: Question[];
     timerEnabled: boolean;
     onComplete: (results: QuestionResult[]) => void;
     sessionId?: string;
     practiceConfig?: { category: string; categoryName: { en: string; my: string }; count: number };
     initialResults?: QuestionResult[];
     initialIndex?: number;
   }
   ```

2. **Initialize state from resume props:**
   - `currentIndex`: use `initialIndex ?? 0`
   - `results`: use `initialResults ?? []`
   - Timer: always start at full duration (fresh timer per user decision)

3. **Save session after each answer:**
   In the `handleAnswerSelect` callback, after creating the result, fire-and-forget save:
   ```typescript
   if (sessionId && practiceConfig) {
     const snapshot: PracticeSnapshot = {
       id: sessionId,
       type: 'practice',
       savedAt: new Date().toISOString(),
       version: SESSION_VERSION,
       questions,
       results: [...results, result],
       currentIndex: currentIndex + 1,
       timerEnabled,
       timeLeft,
       config: practiceConfig,
     };
     saveSession(snapshot).catch(() => {});
   }
   ```

IMPORTANT: Be careful with the existing code structure. PracticeSession manages its own state internally. The resume data needs to seed the initial state values. Use `useState(initialValue ?? defaultValue)` pattern.
  </action>
  <verify>
`npm run typecheck` passes. `npm run lint` passes. Practice session saves after each answer. Resume modal appears on /practice when saved sessions exist. Resumed session starts at correct question with correct results.
  </verify>
  <done>
PracticePage checks for saved sessions on mount, shows resume modal, restores practice state on resume. PracticeSession saves progress after each answer. Session is deleted on completion. Countdown shows when timer is enabled. SESS-02 complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: InterviewPage session persistence</name>
  <files>src/pages/InterviewPage.tsx, src/components/interview/InterviewSession.tsx</files>
  <action>
**Modify `src/pages/InterviewPage.tsx`:**

1. **New imports:**
   ```typescript
   import { saveSession, getSessionsByType, deleteSession } from '@/lib/sessions/sessionStore';
   import type { InterviewSnapshot, SessionSnapshot } from '@/lib/sessions/sessionTypes';
   import { SESSION_VERSION } from '@/lib/sessions/sessionTypes';
   import { ResumePromptModal } from '@/components/sessions/ResumePromptModal';
   ```

2. **New state:**
   ```typescript
   const [savedSessions, setSavedSessions] = useState<InterviewSnapshot[]>([]);
   const [showResumeModal, setShowResumeModal] = useState(false);
   const [sessionId] = useState(() => `session-interview-${Date.now()}`);
   ```

3. **Check for saved sessions on mount:**
   Same pattern as TestPage -- `getSessionsByType('interview')`, show modal if found.

4. **Resume handler:**
   - Restore mode from saved session
   - Set phase to 'session' (skip setup and countdown)
   - Pass restored data to InterviewSession via new props
   - The InterviewSession component needs to accept initial state for resume

5. **Start Fresh handler:**
   Delete session, clear saved sessions, close modal.

6. **Not Now handler:**
   Close modal, keep session.

7. **Delete session on completion:**
   In `handleSessionComplete`, delete the session:
   ```typescript
   deleteSession(sessionId).catch(() => {});
   ```

8. **Render ResumePromptModal in setup phase:**
   Show modal overlay when in setup phase and saved sessions exist.

**Modify `src/components/interview/InterviewSession.tsx`:**

1. **Add new optional props:**
   ```typescript
   interface InterviewSessionProps {
     mode: InterviewMode;
     onComplete: (results: InterviewResult[], durationSeconds: number, endReason: InterviewEndReason) => void;
     micPermission: boolean;
     sessionId?: string;
     initialQuestions?: Question[];
     initialResults?: InterviewResult[];
     initialIndex?: number;
     initialCorrectCount?: number;
     initialIncorrectCount?: number;
     initialStartTime?: number;
   }
   ```

2. **Initialize state from resume props:**
   - `questions`: If `initialQuestions` provided, use them. Otherwise, use the existing `useMemo` shuffle. This requires changing the questions from `useMemo` to `useState` with lazy init (same pattern as TestPage):
     ```typescript
     const [questions] = useState<Question[]>(() =>
       initialQuestions ?? fisherYatesShuffle(allQuestions).slice(0, QUESTIONS_PER_SESSION)
     );
     ```
   - `currentIndex`: `useState(initialIndex ?? 0)`
   - `results`: `useState<InterviewResult[]>(initialResults ?? [])`
   - `correctCount`: `useState(initialCorrectCount ?? 0)`
   - `incorrectCount`: `useState(initialIncorrectCount ?? 0)`
   - `startTime`: `useState(() => initialStartTime ?? Date.now())`
   - `questionPhase`: When resuming (initialIndex > 0), start at 'chime' phase for the current question (don't replay greeting)

3. **Save session after each grade:**
   In the grade handler (where results are updated and counts incremented), add a fire-and-forget save:
   ```typescript
   if (sessionId) {
     const snapshot: InterviewSnapshot = {
       id: sessionId,
       type: 'interview',
       savedAt: new Date().toISOString(),
       version: SESSION_VERSION,
       questions,
       results: updatedResults,
       currentIndex: nextIndex,
       correctCount: newCorrectCount,
       incorrectCount: newIncorrectCount,
       mode,
       startTime,
     };
     saveSession(snapshot).catch(() => {});
   }
   ```

   Find the appropriate place in the grading logic. The interview session uses a complex state machine with `questionPhase`. The save should happen in the 'transition' phase handler where results are finalized for the current question, before moving to the next question.

   Look for where `setResults` and `setCorrectCount`/`setIncorrectCount` are called after grading. That's the save point.

4. **Skip greeting on resume:**
   When `initialIndex > 0` (resuming), set initial `questionPhase` to `'chime'` instead of `'greeting'`. This skips the greeting and goes directly to the chime+reading for the next ungraded question.

IMPORTANT: The InterviewSession has a complex TTS-driven state machine (greeting -> chime -> reading -> responding -> grading -> transition). When resuming, we skip greeting and start at 'chime' for the current question. Don't try to restore mid-question states like 'reading' or 'responding' -- that would require restoring TTS state which is not serializable. Always resume at the beginning of the next ungraded question.

IMPORTANT: InterviewSession stores `questions` in a useMemo currently. When adding resume support, change to `useState` with lazy init (same pattern as TestPage changes in plan 05). The useMemo needs to become `useState` to allow seeding with saved questions.
  </action>
  <verify>
`npm run typecheck` passes. `npm run lint` passes. `npm run build` passes. Interview session saves after each grade. Resume modal appears on /interview when saved sessions exist. Resumed session starts at correct question.
  </verify>
  <done>
InterviewPage checks for saved sessions on mount, shows resume modal, restores interview state on resume. InterviewSession saves progress after each grade. Session is deleted on completion. Resume skips greeting and starts at next ungraded question. SESS-03 complete.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes for all modified files
2. `npm run lint` passes
3. `npm run build` passes
4. Practice: session saved after each answer, resume modal on return, restore works
5. Interview: session saved after each grade, resume modal on return, restore works
6. Both: sessions deleted on completion
7. Practice: countdown shows only when timer enabled
8. Interview: resume skips greeting, starts at next question's chime phase
9. No regressions to existing practice or interview functionality
</verification>

<success_criteria>
- Practice session persistence works end-to-end (SESS-02)
- Interview session persistence works end-to-end (SESS-03)
- Practice preserves category config and timer state
- Interview preserves mode, counts, and question progress
- Sessions auto-clean on completion
- No regressions to existing functionality (sounds, navigation lock, TTS, recording)
</success_criteria>

<output>
After completion, create `.planning/phases/20-session-persistence/20-06-SUMMARY.md`
</output>
