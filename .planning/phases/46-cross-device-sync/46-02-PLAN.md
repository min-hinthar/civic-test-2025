---
phase: 46-cross-device-sync
plan: 2
type: execute
wave: 2
depends_on: ["46-01"]
files_modified:
  - src/contexts/ThemeContext.tsx
  - src/contexts/LanguageContext.tsx
  - src/contexts/TTSContext.tsx
  - src/hooks/useTestDate.ts
  - src/hooks/useBookmarks.ts
  - src/lib/bookmarks/index.ts
autonomous: true
requirements:
  - SYNC-02
  - SYNC-03

must_haves:
  truths:
    - "Theme change fires settings sync to Supabase"
    - "Language mode change fires settings sync to Supabase"
    - "TTS settings change fires settings sync to Supabase"
    - "Test date change fires settings sync to Supabase"
    - "Bookmark toggle fires bookmark sync to Supabase"
    - "Settings push only fires after initial pull has completed (hasSynced flag)"
    - "Sync push is fire-and-forget (non-blocking, never shows errors to user)"
  artifacts:
    - path: "src/contexts/ThemeContext.tsx"
      provides: "Theme context with settings sync on change"
      contains: "syncSettingsToSupabase"
    - path: "src/contexts/LanguageContext.tsx"
      provides: "Language context with settings sync on change"
      contains: "syncSettingsToSupabase"
    - path: "src/contexts/TTSContext.tsx"
      provides: "TTS context with settings sync on change"
      contains: "syncSettingsToSupabase"
    - path: "src/hooks/useTestDate.ts"
      provides: "Test date hook with settings sync on change"
      contains: "syncSettingsToSupabase"
    - path: "src/hooks/useBookmarks.ts"
      provides: "Bookmarks hook with bookmark sync on toggle"
      contains: "syncBookmarksToSupabase"
  key_links:
    - from: "src/contexts/ThemeContext.tsx"
      to: "src/lib/settings/settingsSync.ts"
      via: "import syncSettingsToSupabase"
      pattern: "import.*syncSettingsToSupabase.*from.*settings"
    - from: "src/hooks/useBookmarks.ts"
      to: "src/lib/bookmarks/bookmarkSync.ts"
      via: "import syncBookmarksToSupabase"
      pattern: "import.*syncBookmarksToSupabase.*from.*bookmarks"
---

<objective>
Wire fire-and-forget sync pushes into every settings context and the bookmarks hook so that each user change immediately persists to Supabase.

Purpose: Ensures every setting change and bookmark toggle is pushed to Supabase in real-time, enabling cross-device consistency. The push is non-blocking -- UI never waits for sync.
Output: Modified ThemeContext, LanguageContext, TTSContext, useTestDate, and useBookmarks with sync push calls.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-cross-device-sync/46-CONTEXT.md
@.planning/phases/46-cross-device-sync/46-RESEARCH.md
@.planning/phases/46-cross-device-sync/46-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 outputs -->

From src/lib/settings/settingsSync.ts (created in Plan 01):
```typescript
export interface UserSettings {
  theme: 'light' | 'dark';
  languageMode: 'bilingual' | 'english-only';
  ttsRate: 'slow' | 'normal' | 'fast';
  ttsPitch: number;
  ttsAutoRead: boolean;
  ttsAutoReadLang: 'english' | 'burmese' | 'both';
  testDate: string | null;
}
export async function syncSettingsToSupabase(userId: string, settings: UserSettings): Promise<void>;
export async function loadSettingsFromSupabase(userId: string): Promise<UserSettings | null>;
```

From src/lib/bookmarks/bookmarkSync.ts (created in Plan 01):
```typescript
export async function syncBookmarksToSupabase(userId: string, questionIds: string[]): Promise<void>;
export async function loadBookmarksFromSupabase(userId: string): Promise<string[]>;
export function mergeBookmarks(localIds: string[], remoteIds: string[]): string[];
```

From src/contexts/SupabaseAuthContext.tsx (existing):
```typescript
export const useAuth = () => AuthContextValue;
interface AuthContextValue {
  user: User | null;  // User has id: string
  // ...
}
```

From src/contexts/ThemeContext.tsx (existing):
```typescript
type Theme = 'light' | 'dark';
// localStorage key: 'civic-theme'
```

From src/contexts/LanguageContext.tsx (existing):
```typescript
type LanguageMode = 'bilingual' | 'english-only';
// localStorage key: 'civic-test-language-mode'
```

From src/contexts/TTSContext.tsx (existing):
```typescript
interface TTSSettings {
  rate: 'slow' | 'normal' | 'fast';
  pitch: number;
  lang: string;
  autoRead: boolean;
  autoReadLang: 'english' | 'burmese' | 'both';
  preferredVoiceName?: string;
}
// localStorage key: 'civic-prep-tts-settings'
```

From src/hooks/useTestDate.ts (existing):
```typescript
// localStorage key: 'civic-prep-test-date'
export function useTestDate(): {
  testDate: string | null;
  setTestDate: (date: string | null) => void;
  postTestAction: PostTestAction;
  setPostTestAction: (action: PostTestAction) => void;
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire settings sync push into ThemeContext, LanguageContext, TTSContext, and useTestDate</name>
  <files>src/contexts/ThemeContext.tsx, src/contexts/LanguageContext.tsx, src/contexts/TTSContext.tsx, src/hooks/useTestDate.ts</files>
  <action>
    Each context/hook must fire a settings sync to Supabase whenever the user changes a setting. The approach is the same for all four:

    **Pattern for each context/hook:**
    1. Import `useAuth` from `@/contexts/SupabaseAuthContext` and `syncSettingsToSupabase` from `@/lib/settings`
    2. Get `user` from `useAuth()` inside the provider/hook
    3. Create a helper function `gatherAndSyncSettings()` that:
       - Checks `if (!user?.id) return` (skip for unauthenticated users)
       - Reads ALL current settings from their respective localStorage keys:
         - `civic-theme` -> theme
         - `civic-test-language-mode` -> languageMode
         - `civic-prep-tts-settings` -> parse JSON for ttsRate, ttsPitch, ttsAutoRead, ttsAutoReadLang
         - `civic-prep-test-date` -> testDate
       - Calls `syncSettingsToSupabase(user.id, gatheredSettings)` (fire-and-forget, no await needed in caller)
    4. Call `gatherAndSyncSettings()` after each setting change (in the setTheme/setMode/updateSettings/setTestDate functions)

    **CRITICAL: Pitfall 3 prevention (settings overwrite before first sync):**
    Each context needs a `hasSynced` ref (`useRef(false)`) that starts as false. The sync push should only fire when `hasSynced.current === true`. Plan 03 will set this flag to true after the initial pull completes. For now, add the ref and guard but default it to `true` (Plan 03 will change the initialization to false and set it after pull).

    **Actually, simpler approach:** Since all settings are gathered from localStorage at push time (not from React state), and Plan 03 handles the pull-then-enable pattern, just add the sync call after each change. Plan 03's visibility sync and login hydration will write to localStorage first, then the contexts will read the synced values on next mount. There is no race condition because:
    - On first login, Plan 03 pulls settings and writes to localStorage
    - Contexts read from localStorage on mount (they already do this)
    - Fire-and-forget push only happens on user-initiated changes (toggle theme, etc.)

    **ThemeContext.tsx changes:**
    - Import `{ useAuth }` from `@/contexts/SupabaseAuthContext`
    - Import `{ syncSettingsToSupabase }` from `@/lib/settings`
    - Inside `ThemeProvider`, call `const { user } = useAuth();`
    - In the `useEffect` that runs on theme change (the one that sets `localStorage.setItem('civic-theme', theme)` on line ~44), after writing to localStorage, add a fire-and-forget sync call. Use a helper:
      ```typescript
      function gatherCurrentSettings(): UserSettings {
        return {
          theme: (localStorage.getItem('civic-theme') as 'light' | 'dark') ?? 'light',
          languageMode: (localStorage.getItem('civic-test-language-mode') as 'bilingual' | 'english-only') ?? 'bilingual',
          ttsRate: (() => { try { return JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').rate ?? 'normal'; } catch { return 'normal'; } })(),
          ttsPitch: (() => { try { return JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').pitch ?? 1.02; } catch { return 1.02; } })(),
          ttsAutoRead: (() => { try { return JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').autoRead ?? true; } catch { return true; } })(),
          ttsAutoReadLang: (() => { try { return JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').autoReadLang ?? 'both'; } catch { return 'both'; } })(),
          testDate: localStorage.getItem('civic-prep-test-date'),
        };
      }
      ```

    **WAIT -- Better approach:** Instead of duplicating the gather function in each context, create a shared `gatherCurrentSettings()` utility in `src/lib/settings/settingsSync.ts` (it's a pure localStorage reader). Then each context just imports and calls it.

    **Revised approach:**
    1. In `src/lib/settings/settingsSync.ts`, add an exported `gatherCurrentSettings(): UserSettings` function that reads all setting values from their respective localStorage keys and returns a `UserSettings` object. This centralizes the localStorage key knowledge.

    2. In each context/hook, after writing the setting to localStorage:
       ```typescript
       if (user?.id) {
         const settings = gatherCurrentSettings();
         syncSettingsToSupabase(user.id, settings);  // fire-and-forget, no await
       }
       ```

    **ThemeContext.tsx:**
    - Import `useAuth` and `{ syncSettingsToSupabase, gatherCurrentSettings }` from `@/lib/settings`
    - Call `const { user } = useAuth()` inside ThemeProvider
    - In the `useEffect` that runs on `[theme, mounted]` (after `window.localStorage.setItem('civic-theme', theme)` on line ~44), add:
      ```typescript
      if (user?.id) {
        const settings = gatherCurrentSettings();
        syncSettingsToSupabase(user.id, settings);
      }
      ```

    **LanguageContext.tsx:**
    - Import `useAuth` and `{ syncSettingsToSupabase, gatherCurrentSettings }` from `@/lib/settings`
    - Call `const { user } = useAuth()` inside LanguageProvider
    - In the `setMode` callback (after `localStorage.setItem(STORAGE_KEY, newMode)` on line ~50), add the sync call

    **TTSContext.tsx:**
    - Import `useAuth` and `{ syncSettingsToSupabase, gatherCurrentSettings }` from `@/lib/settings`
    - Call `const { user } = useAuth()` inside TTSProvider
    - In the `updateSettings` callback (after `localStorage.setItem(SETTINGS_KEY, JSON.stringify(next))` on line ~145), add the sync call

    **useTestDate.ts:**
    - Import `useAuth` and `{ syncSettingsToSupabase, gatherCurrentSettings }` from `@/lib/settings`
    - Call `const { user } = useAuth()` inside useTestDate hook
    - In `setTestDate` callback (after `localStorage.setItem(TEST_DATE_KEY, date)` on line ~70), add the sync call
    - In `setPostTestAction` callback when action === 'passed' (after `localStorage.removeItem(TEST_DATE_KEY)` on line ~85), also sync (testDate will be null)

    **Important notes:**
    - ALL sync calls are fire-and-forget: call the function but do NOT `await` it. The function handles its own errors internally.
    - Do NOT sync `preferredVoiceName` -- it is device-specific per user decision.
    - Each context already has `useAuth` available in its provider tree (AuthProvider wraps all contexts in ClientProviders).
  </action>
  <verify>
    <automated>pnpm build</automated>
  </verify>
  <done>
    - ThemeContext fires syncSettingsToSupabase on theme change
    - LanguageContext fires syncSettingsToSupabase on language mode change
    - TTSContext fires syncSettingsToSupabase on TTS settings change
    - useTestDate fires syncSettingsToSupabase on test date change
    - All sync calls are fire-and-forget (no await, no error UI)
    - gatherCurrentSettings() utility centralizes localStorage reads
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire bookmark sync push into useBookmarks hook</name>
  <files>src/hooks/useBookmarks.ts, src/lib/bookmarks/index.ts</files>
  <action>
    **useBookmarks.ts:**
    1. Import `useAuth` from `@/contexts/SupabaseAuthContext`
    2. Import `syncBookmarksToSupabase` from `@/lib/bookmarks`
    3. Call `const { user } = useAuth()` at the top of the hook
    4. In the `toggleBookmark` callback, after the successful `await persistBookmark(questionId, !wasBookmarked)` call (line ~44), fire a sync push:
       ```typescript
       // Fire-and-forget sync to Supabase
       if (user?.id) {
         // Get the current full bookmark set after this toggle
         getAllBookmarkIds().then(allIds => {
           syncBookmarksToSupabase(user.id, allIds);
         });
       }
       ```
       Place this AFTER the IndexedDB persist succeeds (inside the try block, after `await persistBookmark`). This ensures we sync the actual committed state, not the optimistic state.

    5. Do NOT sync on the error/revert path (line ~47 catch block).

    **bookmarks/index.ts:** Update barrel export to include bookmarkSync exports:
    ```typescript
    export { isBookmarked, setBookmark, getAllBookmarkIds, clearAllBookmarks } from './bookmarkStore';
    export { syncBookmarksToSupabase, loadBookmarksFromSupabase, mergeBookmarks } from './bookmarkSync';
    ```
  </action>
  <verify>
    <automated>pnpm build</automated>
  </verify>
  <done>
    - useBookmarks fires syncBookmarksToSupabase after successful IndexedDB persist
    - Sync is fire-and-forget (no await blocking UI)
    - bookmarks/index.ts re-exports all bookmarkSync functions
    - Bookmark sync sends the full current set of IDs (not just the toggled one)
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with no TypeScript errors
2. `pnpm test -- --run` passes all existing tests
3. ThemeContext, LanguageContext, TTSContext, useTestDate all import and call syncSettingsToSupabase
4. useBookmarks imports and calls syncBookmarksToSupabase
5. No `await` on sync calls in the hot path (fire-and-forget pattern verified)
</verification>

<success_criteria>
- Every settings context fires sync on change (theme, language, TTS, test date)
- Bookmark toggle fires sync after IndexedDB persist
- All sync calls are non-blocking fire-and-forget
- No UI changes (no loading spinners, no sync indicators, no error toasts per user decision)
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/46-cross-device-sync/46-02-SUMMARY.md`
</output>
