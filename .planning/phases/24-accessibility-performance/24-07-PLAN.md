---
phase: 24-accessibility-performance
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - instrumentation-client.ts
  - next.config.mjs
  - src/pages/_document.tsx
  - src/lib/pwa/sw.ts
autonomous: true

must_haves:
  truths:
    - "Web Vitals (LCP, INP, CLS) are captured and reported to Sentry"
    - "Bundle analyzer generates treemap when ANALYZE=true"
    - "Myanmar font is preloaded to reduce layout shift"
    - "Sentry production sample rate is reduced from 100% to 20%"
  artifacts:
    - path: "instrumentation-client.ts"
      provides: "Explicit browserTracingIntegration for Web Vitals"
      contains: "browserTracingIntegration"
    - path: "next.config.mjs"
      provides: "Bundle analyzer wrapper"
      contains: "withBundleAnalyzer"
  key_links:
    - from: "instrumentation-client.ts"
      to: "Sentry dashboard"
      via: "browserTracingIntegration captures and sends Web Vitals"
      pattern: "browserTracingIntegration"
    - from: "next.config.mjs"
      to: "@next/bundle-analyzer"
      via: "config wrapper"
      pattern: "withBundleAnalyzer"
---

<objective>
Configure explicit Web Vitals capture via Sentry, add @next/bundle-analyzer to the build chain, optimize Myanmar font loading, and audit service worker caching.

Purpose: Establish performance monitoring (PERF-01, PERF-02) and optimize loading performance for the primary audience.
Output: Sentry capturing Web Vitals, bundle analyzer available, font optimized, SW caching reviewed.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@instrumentation-client.ts
@next.config.mjs
@src/pages/_document.tsx
@src/lib/pwa/sw.ts
@.planning/phases/24-accessibility-performance/24-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sentry Web Vitals + bundle analyzer configuration</name>
  <files>instrumentation-client.ts, next.config.mjs</files>
  <action>
    **Sentry Web Vitals (PERF-01):**

    1. Update `instrumentation-client.ts`:
       - Add `Sentry.browserTracingIntegration()` to the integrations array (explicitly, for clarity)
       - Reduce `tracesSampleRate` for production: `process.env.NODE_ENV === 'production' ? 0.2 : 1`
       - This is sufficient -- Sentry SDK v10+ auto-captures LCP, INP, CLS, FCP, TTFB when browserTracingIntegration is active
       - Do NOT install a separate `web-vitals` library (per research recommendation)

    2. Result:
       ```typescript
       Sentry.init({
         dsn: '...',
         integrations: [
           Sentry.browserTracingIntegration(),
           Sentry.replayIntegration(),
         ],
         tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1,
         // ... rest stays the same
       });
       ```

    **Bundle Analyzer (PERF-02):**

    1. Update `next.config.mjs`:
       - Import: `import withBundleAnalyzer from '@next/bundle-analyzer';`
       - Configure: `const analyzer = withBundleAnalyzer({ enabled: process.env.ANALYZE === 'true' });`
       - Wrap the config chain. Current chain is: `withSentryConfig(withSerwist(nextConfig), sentryOpts)`
       - New chain: `withSentryConfig(analyzer(withSerwist(nextConfig)), sentryOpts)`
       - The analyzer wraps INSIDE Sentry (Sentry must be outermost for source map upload)

    2. Verify: `ANALYZE=true pnpm build` should generate `.next/analyze/client.html` (don't run this in CI, just document the command).

    3. Add to package.json scripts (optional convenience):
       ```json
       "analyze": "ANALYZE=true next build"
       ```
       Note: On Windows, this may need `cross-env ANALYZE=true` or just document the manual command.
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - `pnpm run build` passes (without ANALYZE=true, just normal build)
    - Grep for `browserTracingIntegration` in instrumentation-client.ts
    - Grep for `withBundleAnalyzer` in next.config.mjs
  </verify>
  <done>Sentry captures Web Vitals via explicit browserTracingIntegration. Bundle analyzer available via ANALYZE=true flag.</done>
</task>

<task type="auto">
  <name>Task 2: Font optimization + service worker caching audit</name>
  <files>src/pages/_document.tsx, src/lib/pwa/sw.ts</files>
  <action>
    **Myanmar Font Optimization (locked decision: preload, font-display: swap):**

    1. Check current font loading:
       - Inter is loaded via Google Fonts CDN
       - Myanmar (Noto Sans Myanmar) is loaded via @fontsource
       - Find the actual woff2 file path by checking `node_modules/@fontsource/noto-sans-myanmar/` for CSS imports

    2. In `src/pages/_document.tsx`, add a preload link for the Myanmar font's most critical weight (400 regular):
       ```tsx
       <Head>
         <link
           rel="preload"
           href="/_next/static/media/[myanmar-font-file].woff2"
           as="font"
           type="font/woff2"
           crossOrigin="anonymous"
         />
       </Head>
       ```
       Note: The exact path depends on how @fontsource bundles the file. Check the built output or the package structure.

       WARNING (per Research Pitfall 6): Do NOT preload a file that @fontsource CSS is already loading via @font-face -- this causes double download. Instead:
       - Check if @fontsource v5 already uses `font-display: swap` (it does by default)
       - If the font file is bundled via webpack/next, find the hashed filename in `.next/static/media/`
       - If preloading is risky (path unknown at build time), skip the preload and just verify font-display: swap is set

    3. Alternative approach if preload path is uncertain:
       - Add a CSS `font-display: swap` override in globals.css for the Myanmar font
       - Verify the @fontsource import already sets font-display: swap
       - This is lower risk than a preload link with wrong path

    **Service Worker Caching Audit (locked decision: review):**

    1. Read `src/lib/pwa/sw.ts` and document current caching strategy.
    2. Check:
       - Are static assets (JS, CSS, fonts) cached with a long-lived strategy?
       - Are API calls (Supabase) excluded from caching?
       - Is the offline page cached properly?
       - Are audio files (/audio/my-MM/) cached for offline Burmese playback?
    3. If audio files are NOT cached, add a runtime caching route:
       ```typescript
       // In sw.ts registerRoute or equivalent
       {
         urlPattern: /\/audio\/my-MM\/.+\.mp3$/,
         handler: 'CacheFirst',
         options: { cacheName: 'burmese-audio', expiration: { maxEntries: 300, maxAgeSeconds: 30 * 24 * 60 * 60 } }
       }
       ```
    4. Document findings even if no changes needed.
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - `pnpm run build` passes
    - Font loading verified (either preload link added or font-display: swap confirmed)
    - SW caching strategy documented / audio caching added if missing
  </verify>
  <done>Myanmar font optimized for fast loading. Service worker caching reviewed and audio files cached for offline.</done>
</task>

</tasks>

<verification>
- `pnpm run typecheck` passes
- `pnpm run lint` passes
- `pnpm run build` passes
- instrumentation-client.ts has browserTracingIntegration
- next.config.mjs has withBundleAnalyzer
- Font optimization applied or verified
- SW caching reviewed
</verification>

<success_criteria>
- Web Vitals (LCP, INP, CLS, FCP, TTFB) captured by Sentry with 20% production sample rate
- Bundle analyzer available via ANALYZE=true pnpm build
- Myanmar font uses font-display: swap and loads without layout shift
- Service worker caching strategy reviewed and audio files cached
</success_criteria>

<output>
After completion, create `.planning/phases/24-accessibility-performance/24-07-SUMMARY.md`
</output>
