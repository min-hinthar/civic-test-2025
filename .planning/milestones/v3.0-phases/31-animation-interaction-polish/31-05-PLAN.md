---
phase: 31-animation-interaction-polish
plan: 05
type: execute
wave: 2
depends_on: [04]
files_modified:
  - src/components/animations/StaggeredList.tsx
  - src/lib/motion-config.ts
autonomous: true
requirements: [ANIM-02, ANIM-06]

must_haves:
  truths:
    - "StaggeredList timing scales with child count: ~60ms for 1-3 items, ~40ms for 4-8 items, capped formula for 9-14"
    - "Lists with 15+ items skip stagger animation entirely (all items appear at once)"
    - "Stagger is auto-disabled on low-end devices (hardwareConcurrency <= 4)"
    - "prefers-reduced-motion removes stagger entirely (all items appear simultaneously)"
    - "Item enter animation slides up from ~10-15px below while fading in with spring physics"
    - "StaggeredList plays on every mount, not just first visit"
    - "StaggeredGrid uses row-by-row left-to-right stagger for grid layouts"
  artifacts:
    - path: "src/components/animations/StaggeredList.tsx"
      provides: "Adaptive StaggeredList with length-based timing, low-end detection, viewport trigger"
      contains: "getAdaptiveConfig"
    - path: "src/lib/motion-config.ts"
      provides: "Updated stagger timing presets"
      exports: ["STAGGER_FAST", "STAGGER_DEFAULT", "STAGGER_SLOW"]
  key_links:
    - from: "src/components/animations/StaggeredList.tsx"
      to: "src/lib/motion-config.ts"
      via: "imports stagger timing presets"
      pattern: "import.*STAGGER.*motion-config"
    - from: "src/components/animations/StaggeredList.tsx"
      to: "motion/react"
      via: "motion.div with variants and whileInView"
      pattern: "whileInView|useReducedMotion"
---

<objective>
Enhance StaggeredList with adaptive timing that scales to list length, skips for long lists, and auto-disables on low-end devices. Audit all 22 consumer files for correct usage.

Purpose: Fixed stagger timing (60ms) works fine for 5-item lists but creates noticeable delays on 12-item lists and painful waits on 20+ item lists. Adaptive timing ensures every list feels snappy regardless of length. Low-end device detection prevents animation jank on budget phones. Coverage audit ensures all lists in the app benefit from stagger, not just the ones that happened to adopt it early.

Output: Enhanced StaggeredList.tsx with adaptive `getAdaptiveConfig()`, viewport-triggered stagger, and verified coverage across all list-rendering screens.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/animations/StaggeredList.tsx
@src/lib/motion-config.ts
@.planning/phases/31-animation-interaction-polish/31-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance StaggeredList with adaptive timing and low-end device detection</name>
  <files>src/components/animations/StaggeredList.tsx, src/lib/motion-config.ts</files>
  <action>
**StaggeredList.tsx — Core enhancements:**

1. **Add `getAdaptiveConfig` helper** that calculates stagger timing based on child count:
   ```typescript
   interface AdaptiveConfig {
     shouldAnimate: boolean;
     stagger: number; // seconds
     delay: number;   // seconds
   }

   function getAdaptiveConfig(
     childCount: number,
     prefersReduced: boolean,
     customStagger?: number // ms, from prop
   ): AdaptiveConfig {
     // Reduced motion or 15+ items: skip entirely
     if (prefersReduced || childCount >= 15) {
       return { shouldAnimate: false, stagger: 0, delay: 0 };
     }

     // Low-end device detection
     const isLowEnd = typeof navigator !== 'undefined'
       && navigator.hardwareConcurrency != null
       && navigator.hardwareConcurrency <= 4;
     if (isLowEnd) {
       return { shouldAnimate: false, stagger: 0, delay: 0 };
     }

     // If custom stagger provided, use it (backward compat)
     if (customStagger !== undefined) {
       return { shouldAnimate: true, stagger: customStagger / 1000, delay: 0.05 };
     }

     // Adaptive timing based on count
     if (childCount <= 3) return { shouldAnimate: true, stagger: 0.06, delay: 0.1 };  // luxurious
     if (childCount <= 8) return { shouldAnimate: true, stagger: 0.04, delay: 0.05 }; // fast cascade
     // 9-14 items: cap total animation at ~400ms
     return {
       shouldAnimate: true,
       stagger: Math.min(0.04, 0.4 / childCount),
       delay: 0.03,
     };
   }
   ```

2. **Update StaggeredList to use adaptive config.** Count children via `Children.count(children)` and pass to `getAdaptiveConfig`:
   ```typescript
   export function StaggeredList({
     children,
     className,
     delay = 100,
     stagger,        // Make optional (was required-ish via default)
   }: StaggeredListProps) {
     const shouldReduceMotion = useReducedMotion();
     const childCount = Children.count(children);
     const config = getAdaptiveConfig(childCount, shouldReduceMotion, stagger);

     if (!config.shouldAnimate) {
       // Skip animation: render children directly
       return <div className={className}>{children}</div>;
     }

     const containerVariants: Variants = {
       hidden: {},
       visible: {
         transition: {
           staggerChildren: config.stagger,
           delayChildren: config.delay,
         },
       },
     };

     return (
       <motion.div
         variants={containerVariants}
         initial="hidden"
         animate="visible"
         className={className}
       >
         {children}
       </motion.div>
     );
   }
   ```

3. **Update item variants** for "slide up from below" per user decision:
   ```typescript
   const itemVariants: Variants = {
     hidden: {
       opacity: 0,
       y: 12, // Slide up from ~12px below (user said 10-15px)
     },
     visible: {
       opacity: 1,
       y: 0,
       transition: SPRING_BOUNCY,
     },
   };
   ```
   The current variant uses `y: 20` and `scale: 0.9`. User decision says "slide from below — items translateY up from ~10-15px below while fading in." Remove the `scale: 0.9` from the item variant (scale is for cards via ANIM-04, not for list items). Update `y: 20` to `y: 12` (middle of 10-15px range). Keep spring physics.

   **WAIT — User decision also says:** "Cards in lists get BOTH stagger timing AND the card scale(0.95→1)+fade animation — layered effect." This means scale stays on cards (via Card's own animation or via a variant). The stagger ITEM handles y+opacity, the card itself handles scale. Since Plan 04 added enter animation to Card.tsx (but it should be disabled inside StaggeredList via `animate={false}`), the stagger item variant should NOT include scale. The stagger handles timing + y-slide + opacity. Card handles its own scale (disabled when inside stagger).

   Reconciliation: Remove `scale` from `itemVariants`. Stagger item = y + opacity only. Card enter animation = scale + opacity. When a Card is inside a StaggeredList, the StaggeredItem provides y + opacity animation, and the Card has `animate={false}` so it doesn't double-animate. The card's static scale is 1 (normal).

   Actually, re-reading the user decision: "Cards in lists get BOTH stagger timing (delayed entrance) AND the card scale(0.95→1)+fade animation — layered effect." This means the card SHOULD animate scale even inside a stagger. The stagger provides the TIMING (delay between items), and the card provides the VISUAL (scale+fade). So the StaggeredItem just provides the timing wrapper, and the Card.tsx enter animation (scale+fade) plays with the stagger-applied delay.

   But that means StaggeredItem should NOT animate opacity/y — it should ONLY provide stagger timing. That's a significant change from the current behavior.

   Better approach: Keep StaggeredItem animating y + opacity (slide up + fade in). Cards inside stagger can optionally ALSO do scale. The user said "layered effect" — meaning BOTH happen. So:
   - StaggeredItem: y(12→0) + opacity(0→1) via spring
   - Card inside StaggeredItem: scale(0.95→1) via its own enter animation
   - These layer together: the card slides up while fading in AND scaling in

   This means Card `animate` prop should remain `true` inside StaggeredList (contrary to what Plan 04 says about disabling). The potential issue is opacity fighting: both StaggeredItem and Card animate opacity(0→1). If they both start at opacity 0, they'd compound (0 * 0 = 0, fine). If they both animate to 1, it's fine (1 * 1 = 1). The issue is during animation: StaggeredItem at opacity 0.5 and Card at opacity 0.5 would show 0.25 total, which might look odd.

   Resolution: When Card is inside StaggeredList, Card should ONLY animate `scale` (not opacity). Add a prop `animateScale` to Card that does only scale(0.95→1) without opacity. Or simpler: StaggeredItem handles all visual animation (y + opacity + scale), and Card does `animate={false}`.

   **Final decision (Claude's discretion):** Keep it simple. StaggeredItem handles y(12→0) + opacity(0→1). Card inside StaggeredList has `animate={false}` (no double animation). The user's "layered effect" can be achieved by having StaggeredItem's variant include a subtle scale(0.97→1) alongside the y+opacity. This gives the visual of scale+slide+fade without requiring two animation systems on the same element.

   ```typescript
   const itemVariants: Variants = {
     hidden: {
       opacity: 0,
       y: 12,
       scale: 0.97, // Subtle scale for cards-in-lists "layered" feel
     },
     visible: {
       opacity: 1,
       y: 0,
       scale: 1,
       transition: SPRING_BOUNCY,
     },
   };
   ```

4. **Skip stagger for single-child or empty lists** (pitfall from research):
   ```typescript
   if (childCount <= 1) {
     // No stagger needed for single item
     return <div className={className}>{children}</div>;
   }
   ```
   Actually, even a single item should get the enter animation (fade in + slide up). Just skip the stagger delay:
   ```typescript
   if (childCount === 1) {
     config.stagger = 0; // No stagger, but still animate
   }
   ```

5. **StaggeredGrid row-by-row stagger** (already correct — `StaggeredGrid` wraps children in `StaggeredItem` and uses `StaggeredList` container which applies stagger sequentially. For visual row-by-row in a grid, the children are rendered in DOM order which is left-to-right, top-to-bottom. This naturally creates row-by-row stagger. No change needed.)

6. **Update `StaggeredListProps`** to make `stagger` optional with `undefined` default (enables adaptive mode). When explicitly provided, it overrides adaptive calculation for backward compatibility.

**motion-config.ts — No changes needed.** `STAGGER_FAST` (0.04) and `STAGGER_DEFAULT` (0.06) already exist and match the adaptive values. The adaptive function uses inline values but the exports remain for consumers that want explicit control.
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- StaggeredList with 3 items uses 60ms stagger
- StaggeredList with 8 items uses 40ms stagger
- StaggeredList with 15+ items shows all items at once (no stagger)
- `getAdaptiveConfig` function is defined and used
- `Children.count` is imported from React
  </verify>
  <done>
StaggeredList uses adaptive timing: ~60ms for 1-3 items (luxurious), ~40ms for 4-8 items (fast cascade), capped at ~400ms total for 9-14 items, and skipped entirely for 15+ items. Low-end devices (hardwareConcurrency <= 4) skip stagger. Reduced motion shows all items at once. Item animation slides up from 12px below with spring physics. Custom stagger prop still works for backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit StaggeredList coverage across all consumer files</name>
  <files>src/components/animations/StaggeredList.tsx</files>
  <action>
Audit all 22 files that currently use StaggeredList/StaggeredItem/StaggeredGrid/FadeIn to verify correct usage with the new adaptive system.

**Audit steps:**

1. **Search for all StaggeredList imports:**
   ```
   grep -r "import.*StaggeredList\|import.*StaggeredItem\|import.*StaggeredGrid\|import.*FadeIn" src/
   ```

2. **For each consumer, verify:**
   - Is `stagger` prop explicitly set? If so, is it appropriate or can it be removed to use adaptive mode?
   - Is the list count known at compile time? If fixed short list (3-5 items), explicit stagger is fine.
   - Is the list dynamic length? If so, remove explicit `stagger` to use adaptive mode.
   - Are cards inside StaggeredItem? If so, ensure `animate={false}` is set on the Card component (per Plan 04 — only if that plan established the `animate` prop).

3. **Search for lists NOT using StaggeredList** that should be:
   ```
   grep -r "\.map(" src/components/ src/pages/ --include="*.tsx" | grep -v "StaggeredList\|import"
   ```
   Focus on lists that render visible cards or items. Internal data mapping (like question arrays for logic) don't need stagger.

4. **Document findings** in a comment block at the top of StaggeredList.tsx:
   ```typescript
   /**
    * Coverage audit (Phase 31):
    * - Dashboard: stat cards (StaggeredGrid) ✓
    * - Study Guide: category cards (StaggeredList) ✓
    * - ... etc
    *
    * Lists NOT using stagger (intentionally):
    * - Quiz answer options: appear instantly for fast interaction
    * - ... etc
    */
   ```

5. **Do NOT modify consumer files in this task** — just document what needs changing. Consumer file modifications risk conflicts with other plans in Wave 1. Any needed changes will be handled as follow-up or are already covered by the adaptive system (consumers with explicit `stagger` prop get backward-compatible behavior).

6. **Verify FadeIn still works** — `FadeIn` is a simpler single-element animation. It should not be affected by StaggeredList changes. Verify it still compiles and works independently.
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- Coverage audit documentation is in StaggeredList.tsx as a comment
- FadeIn component still works independently
- All existing StaggeredList consumers still compile (no breaking API changes)
  </verify>
  <done>
StaggeredList coverage audited across all 22+ consumer files. Usage documented with correct tier assignments. Backward compatibility verified — all existing consumers compile without changes. Adaptive timing applies automatically to consumers without explicit stagger prop.
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with no errors
- `npm run lint` passes
- `npm run build` completes without errors
- StaggeredList has `getAdaptiveConfig` function
- Adaptive timing scales correctly for different list lengths
- All 22+ consumer files still compile
- FadeIn component works independently
</verification>

<success_criteria>
Every list in the app staggers at a timing appropriate to its length: short lists feel luxurious (60ms), medium lists cascade quickly (40ms), and long lists (15+) appear instantly without painful delays. Low-end devices skip animation for smooth performance. The adaptive system is backward-compatible — consumers with explicit `stagger` prop keep their setting, while those without get smart defaults.
</success_criteria>

<output>
After completion, create `.planning/phases/31-animation-interaction-polish/31-05-SUMMARY.md`
</output>
