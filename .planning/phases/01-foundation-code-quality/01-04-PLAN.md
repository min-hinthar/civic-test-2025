---
phase: 01-foundation-code-quality
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/components/ErrorBoundary.tsx
  - src/components/ui/BilingualToast.tsx
  - src/lib/errors.ts
  - src/AppShell.tsx
  - src/pages/TestPage.tsx
  - src/pages/Dashboard.tsx
  - src/pages/StudyGuidePage.tsx
  - src/pages/HistoryPage.tsx
  - src/pages/AuthPage.tsx
  - sentry.client.config.ts
autonomous: true

must_haves:
  truths:
    - "User sees bilingual error toast when operation fails"
    - "User sees friendly error boundary fallback when page crashes"
    - "Sentry receives anonymized error reports without PII"
  artifacts:
    - path: "src/components/ErrorBoundary.tsx"
      provides: "Per-page error boundary with Sentry integration"
      contains: "Sentry.ErrorBoundary"
    - path: "src/components/ui/BilingualToast.tsx"
      provides: "Toast helper for bilingual error messages"
      exports: ["showBilingualError", "showBilingualSuccess"]
    - path: "src/lib/errors.ts"
      provides: "Error sanitization utilities"
      exports: ["sanitizeError", "BilingualMessage"]
  key_links:
    - from: "src/pages/*.tsx"
      to: "src/components/ErrorBoundary.tsx"
      via: "wrapper component"
      pattern: "PageErrorBoundary"
    - from: "src/components/ErrorBoundary.tsx"
      to: "@sentry/nextjs"
      via: "Sentry.ErrorBoundary"
      pattern: "Sentry"
---

<objective>
Harden error handling with Sentry error boundaries on each page and bilingual toast notifications for user-facing errors.

Purpose: Users must understand errors in their language (Burmese). Developers need production error visibility via Sentry. Error messages must not expose internal details like database schema. This satisfies FNDN-06 and FNDN-07.

Output: PageErrorBoundary component, bilingual toast utility, error sanitization, Sentry integration with anonymized user context.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-code-quality/01-RESEARCH.md
@.planning/phases/01-foundation-code-quality/01-03-SUMMARY.md
@src/AppShell.tsx
@src/components/ui/use-toast.ts
@sentry.client.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error sanitization utilities and bilingual message types</name>
  <files>src/lib/errors.ts</files>
  <action>
Create src/lib/errors.ts with error handling utilities:

```typescript
/**
 * Error handling utilities for bilingual error messages and sanitization.
 * All user-facing errors should display both English and Burmese text.
 */

/**
 * Bilingual message structure - both languages always displayed together
 */
export interface BilingualMessage {
  en: string;
  my: string;
}

/**
 * Common error messages in both languages
 */
export const ERROR_MESSAGES = {
  networkError: {
    en: 'Unable to connect. Please check your internet connection.',
    my: 'ချိတ်ဆက်၍မရပါ။ သင့်အင်တာနက်ချိတ်ဆက်မှုကို စစ်ဆေးပါ။',
  },
  saveError: {
    en: 'Failed to save. Please try again.',
    my: 'သိမ်းဆည်း၍မရပါ။ ထပ်မံကြိုးစားပါ။',
  },
  loadError: {
    en: 'Failed to load data. Please refresh the page.',
    my: 'ဒေတာတင်၍မရပါ။ စာမျက်နှာကို ပြန်လည်စတင်ပါ။',
  },
  authError: {
    en: 'Authentication failed. Please sign in again.',
    my: 'အထောက်အထားစိစစ်ခြင်း မအောင်မြင်ပါ။ ထပ်မံဝင်ရောက်ပါ။',
  },
  sessionExpired: {
    en: 'Your session has expired. Please sign in again.',
    my: 'သင့်ဆက်ရှင်သက်တမ်းကုန်သွားပါပြီ။ ထပ်မံဝင်ရောက်ပါ။',
  },
  unknownError: {
    en: 'Something went wrong. Please try again.',
    my: 'တစ်ခုခုမှားသွားပါပြီ။ ထပ်မံကြိုးစားပါ။',
  },
  offline: {
    en: 'You are offline. Some features may not work.',
    my: 'သင်အော့ဖ်လိုင်းဖြစ်နေပါသည်။ အချို့လုပ်ဆောင်ချက်များ အလုပ်မလုပ်နိုင်ပါ။',
  },
  testSaveSuccess: {
    en: 'Test saved successfully!',
    my: 'စာမေးပွဲကို အောင်မြင်စွာ သိမ်းဆည်းပြီးပါပြီ။',
  },
  testSaveFailed: {
    en: 'Unable to save test. Please check your connection and try again.',
    my: 'စာမေးပွဲကို သိမ်းဆည်း၍မရပါ။ သင့်ချိတ်ဆက်မှုကို စစ်ဆေးပြီး ထပ်မံကြိုးစားပါ။',
  },
} as const satisfies Record<string, BilingualMessage>;

/**
 * Patterns that indicate sensitive information that should not be exposed
 */
const SENSITIVE_PATTERNS = [
  /password/i,
  /token/i,
  /secret/i,
  /key/i,
  /auth/i,
  /credential/i,
  /postgres/i,
  /supabase/i,
  /database/i,
  /schema/i,
  /column/i,
  /table/i,
  /relation/i,
  /constraint/i,
  /violates/i,
  /duplicate key/i,
  /foreign key/i,
  /null value/i,
  /sql/i,
  /query/i,
];

/**
 * Sanitize error message to remove sensitive information.
 * Returns a safe message for logging and user display.
 */
export function sanitizeError(error: unknown): string {
  if (error === null || error === undefined) {
    return 'Unknown error';
  }

  let message: string;

  if (error instanceof Error) {
    message = error.message;
  } else if (typeof error === 'string') {
    message = error;
  } else if (typeof error === 'object' && 'message' in error) {
    message = String((error as { message: unknown }).message);
  } else {
    message = String(error);
  }

  // Check if message contains sensitive information
  const containsSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(message));

  if (containsSensitive) {
    return 'An error occurred';
  }

  // Truncate very long messages
  if (message.length > 200) {
    return message.slice(0, 200) + '...';
  }

  return message;
}

/**
 * Get appropriate bilingual error message based on error type
 */
export function getBilingualError(error: unknown): BilingualMessage {
  const message = sanitizeError(error);

  // Check for known error patterns
  if (message.toLowerCase().includes('network') || message.toLowerCase().includes('fetch')) {
    return ERROR_MESSAGES.networkError;
  }

  if (message.toLowerCase().includes('auth') || message.toLowerCase().includes('sign')) {
    return ERROR_MESSAGES.authError;
  }

  if (message.toLowerCase().includes('session') || message.toLowerCase().includes('expired')) {
    return ERROR_MESSAGES.sessionExpired;
  }

  if (message.toLowerCase().includes('save') || message.toLowerCase().includes('persist')) {
    return ERROR_MESSAGES.saveError;
  }

  if (message.toLowerCase().includes('load') || message.toLowerCase().includes('fetch')) {
    return ERROR_MESSAGES.loadError;
  }

  return ERROR_MESSAGES.unknownError;
}

/**
 * Hash user ID for Sentry (anonymization)
 * Uses a simple hash to identify users without exposing actual IDs
 */
export function hashUserId(userId: string): string {
  let hash = 0;
  for (let i = 0; i < userId.length; i++) {
    const char = userId.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return `user_${Math.abs(hash).toString(16)}`;
}
```
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Create a quick test: import and call sanitizeError with various inputs.
  </verify>
  <done>Error sanitization utilities created with bilingual message types and sensitive pattern filtering</done>
</task>

<task type="auto">
  <name>Task 2: Create bilingual toast utility and page error boundary</name>
  <files>src/components/ui/BilingualToast.tsx, src/components/ErrorBoundary.tsx</files>
  <action>
**1. Create src/components/ui/BilingualToast.tsx:**

```typescript
'use client';

import { toast } from '@/components/ui/use-toast';
import type { BilingualMessage } from '@/lib/errors';
import { getBilingualError, ERROR_MESSAGES } from '@/lib/errors';

interface ToastOptions {
  retry?: () => void;
  duration?: number;
}

/**
 * Show a bilingual error toast.
 * Always displays both English and Burmese text together.
 */
export function showBilingualError(
  messageOrError: BilingualMessage | unknown,
  options?: ToastOptions
) {
  const message = isBilingualMessage(messageOrError)
    ? messageOrError
    : getBilingualError(messageOrError);

  toast({
    variant: 'destructive',
    title: message.en,
    description: (
      <div className="space-y-2">
        <p className="font-myanmar">{message.my}</p>
        {options?.retry && (
          <button
            onClick={options.retry}
            className="mt-2 rounded-md bg-white/20 px-3 py-1 text-sm font-medium hover:bg-white/30"
          >
            Try again
          </button>
        )}
      </div>
    ),
    duration: options?.duration ?? 5000,
  });
}

/**
 * Show a bilingual success toast.
 */
export function showBilingualSuccess(message: BilingualMessage, duration?: number) {
  toast({
    title: message.en,
    description: <p className="font-myanmar">{message.my}</p>,
    duration: duration ?? 3000,
  });
}

/**
 * Show offline status toast
 */
export function showOfflineToast() {
  showBilingualError(ERROR_MESSAGES.offline, { duration: 10000 });
}

function isBilingualMessage(value: unknown): value is BilingualMessage {
  return (
    typeof value === 'object' &&
    value !== null &&
    'en' in value &&
    'my' in value &&
    typeof (value as BilingualMessage).en === 'string' &&
    typeof (value as BilingualMessage).my === 'string'
  );
}
```

**2. Create src/components/ErrorBoundary.tsx:**

```typescript
'use client';

import * as Sentry from '@sentry/nextjs';
import { Component, type ReactNode } from 'react';
import { useNavigate } from 'react-router-dom';

interface FallbackProps {
  error: Error;
  resetError: () => void;
  pageName: string;
}

/**
 * Bilingual error fallback UI
 */
function ErrorFallback({ error, resetError, pageName }: FallbackProps) {
  return (
    <div className="flex min-h-[50vh] flex-col items-center justify-center p-8 text-center">
      <div className="max-w-md space-y-4">
        <h2 className="text-2xl font-bold text-foreground">
          Something went wrong
        </h2>
        <p className="text-lg font-myanmar text-muted-foreground">
          တစ်ခုခုမှားသွားပါပြီ
        </p>
        <p className="text-sm text-muted-foreground">
          We apologize for the inconvenience. The error has been reported.
        </p>
        <p className="text-sm font-myanmar text-muted-foreground">
          အဆင်မပြေမှုအတွက် တောင်းပန်ပါတယ်။ အမှားကို သတင်းပို့ပြီးပါပြီ။
        </p>
        <div className="flex flex-col gap-3 pt-4 sm:flex-row sm:justify-center">
          <button
            onClick={resetError}
            className="rounded-2xl bg-primary px-6 py-2 font-semibold text-primary-foreground shadow-lg"
          >
            Try again
          </button>
          <button
            onClick={() => window.location.href = '/dashboard'}
            className="rounded-2xl border border-border px-6 py-2 font-semibold text-foreground"
          >
            Go to Dashboard
          </button>
        </div>
      </div>
    </div>
  );
}

interface PageErrorBoundaryProps {
  children: ReactNode;
  pageName: string;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

/**
 * Per-page error boundary with Sentry integration.
 * Each page gets its own boundary so one crash doesn't take down the whole app.
 */
export class PageErrorBoundary extends Component<PageErrorBoundaryProps, State> {
  constructor(props: PageErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Report to Sentry with page context
    Sentry.withScope(scope => {
      scope.setTag('page', this.props.pageName);
      scope.setLevel('error');
      scope.setContext('componentStack', {
        componentStack: errorInfo.componentStack,
      });
      Sentry.captureException(error);
    });
  }

  resetError = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError && this.state.error) {
      return (
        <ErrorFallback
          error={this.state.error}
          resetError={this.resetError}
          pageName={this.props.pageName}
        />
      );
    }

    return this.props.children;
  }
}

/**
 * HOC to wrap page components with error boundary
 */
export function withErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  pageName: string
) {
  return function WithErrorBoundary(props: P) {
    return (
      <PageErrorBoundary pageName={pageName}>
        <WrappedComponent {...props} />
      </PageErrorBoundary>
    );
  };
}
```
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Run `npm run lint` - no errors in new files.
  </verify>
  <done>Bilingual toast utility and PageErrorBoundary component created with Sentry integration</done>
</task>

<task type="auto">
  <name>Task 3: Wire error boundaries to pages and configure Sentry anonymization</name>
  <files>src/AppShell.tsx, src/pages/TestPage.tsx, src/pages/Dashboard.tsx, sentry.client.config.ts</files>
  <action>
**1. Update sentry.client.config.ts for anonymization:**

```typescript
import * as Sentry from '@sentry/nextjs';
import { hashUserId } from '@/lib/errors';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,

  // Disable sending PII
  sendDefaultPii: false,

  // Sample rate for performance monitoring
  tracesSampleRate: 0.1,

  // Only report errors in production
  enabled: process.env.NODE_ENV === 'production',

  // Anonymize user data before sending
  beforeSend(event, hint) {
    // Sanitize any user data
    if (event.user) {
      event.user = {
        id: event.user.id ? hashUserId(event.user.id) : undefined,
        // Remove email, username, ip_address
      };
    }

    // Remove any potentially sensitive breadcrumb data
    if (event.breadcrumbs) {
      event.breadcrumbs = event.breadcrumbs.map(breadcrumb => {
        // Remove data from fetch breadcrumbs that might contain auth tokens
        if (breadcrumb.category === 'fetch' && breadcrumb.data) {
          const { url, method, status_code } = breadcrumb.data;
          breadcrumb.data = { url, method, status_code };
        }
        return breadcrumb;
      });
    }

    return event;
  },

  // Filter out known non-actionable errors
  ignoreErrors: [
    // Browser extensions
    /^chrome-extension:\/\//,
    /^moz-extension:\/\//,
    // Network errors that we can't do anything about
    'Network request failed',
    'Failed to fetch',
    'Load failed',
    // React hydration warnings (common with dynamic content)
    'Hydration failed',
    'There was an error while hydrating',
  ],
});
```

**2. Update AppShell.tsx to wrap routes with error boundaries:**

In src/AppShell.tsx, wrap each route's element with PageErrorBoundary:

```typescript
import { PageErrorBoundary } from '@/components/ErrorBoundary';

// ... existing imports ...

// Wrap page components
<Route path="/dashboard" element={
  <ProtectedRoute>
    <PageErrorBoundary pageName="dashboard">
      <Dashboard />
    </PageErrorBoundary>
  </ProtectedRoute>
} />

<Route path="/test" element={
  <ProtectedRoute>
    <PageErrorBoundary pageName="test">
      <TestPage />
    </PageErrorBoundary>
  </ProtectedRoute>
} />

<Route path="/study" element={
  <ProtectedRoute>
    <PageErrorBoundary pageName="study">
      <StudyGuidePage />
    </PageErrorBoundary>
  </ProtectedRoute>
} />

<Route path="/history" element={
  <ProtectedRoute>
    <PageErrorBoundary pageName="history">
      <HistoryPage />
    </PageErrorBoundary>
  </ProtectedRoute>
} />

<Route path="/auth" element={
  <PageErrorBoundary pageName="auth">
    <AuthPage />
  </PageErrorBoundary>
} />
```

**3. Update TestPage.tsx to use bilingual error toasts:**

Replace the existing toast calls in TestPage.tsx error handlers:

```typescript
import { showBilingualError, showBilingualSuccess } from '@/components/ui/BilingualToast';
import { ERROR_MESSAGES } from '@/lib/errors';

// In the persist() function's catch block:
catch (error) {
  console.error(error);
  setHasSavedSession(false);
  showBilingualError(ERROR_MESSAGES.testSaveFailed, {
    retry: () => persist(),
  });
}

// In the persist() function's success path:
showBilingualSuccess({
  en: `Test saved! You answered ${correctAnswers} questions correctly.`,
  my: `စာမေးပွဲသိမ်းပြီးပါပြီ။ မေးခွန်း ${correctAnswers} ခု မှန်ကန်စွာဖြေဆိုနိုင်ပါသည်။`,
});
```

**4. Add offline detection (bonus for user decisions):**

Add to AppShell.tsx or a separate hook:

```typescript
import { useEffect } from 'react';
import { showOfflineToast } from '@/components/ui/BilingualToast';

// In AppShell component:
useEffect(() => {
  const handleOffline = () => showOfflineToast();

  window.addEventListener('offline', handleOffline);
  return () => window.removeEventListener('offline', handleOffline);
}, []);
```
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Run `npm run lint` - should pass.
Verify each page route in AppShell.tsx is wrapped with PageErrorBoundary.
Verify sentry.client.config.ts has beforeSend with anonymization.
  </verify>
  <done>Error boundaries wired to all pages, Sentry configured with anonymization, bilingual toasts integrated</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` - passes
2. `npm run lint` - passes
3. Each page route wrapped with PageErrorBoundary in AppShell.tsx
4. sentry.client.config.ts has sendDefaultPii: false and beforeSend anonymization
5. TestPage uses showBilingualError for failure toasts
6. Error fallback UI shows both English and Burmese text
</verification>

<success_criteria>
- Every page has its own error boundary (crash isolation)
- Error toasts always show both English and Burmese
- Sentry reports include hashed user ID, not actual ID
- No raw database errors exposed to users
- Offline status shows bilingual toast
- Requirements FNDN-06 and FNDN-07 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-code-quality/01-04-SUMMARY.md`
</output>
