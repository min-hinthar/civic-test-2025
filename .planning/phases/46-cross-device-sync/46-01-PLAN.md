---
phase: 46-cross-device-sync
plan: 1
type: tdd
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
  - src/lib/settings/settingsSync.ts
  - src/lib/settings/settingsSync.test.ts
  - src/lib/settings/index.ts
  - src/lib/bookmarks/bookmarkSync.ts
  - src/lib/bookmarks/bookmarkSync.test.ts
  - src/lib/social/streakSync.ts
  - src/lib/social/streakSync.test.ts
autonomous: true
requirements:
  - SYNC-02
  - SYNC-03
  - SYNC-04

must_haves:
  truths:
    - "Settings can be pushed to and pulled from Supabase user_settings table"
    - "Bookmarks can be pushed to and pulled from Supabase user_bookmarks table"
    - "Streak merge recalculates freezes (returns freed freezes when other device was active on missed day)"
    - "Streak merge recomputes longest streak from full merged date set"
    - "mergeBookmarks produces union of local and remote bookmark IDs"
    - "mapRowToSettings correctly maps snake_case DB columns to camelCase settings"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "user_settings and user_bookmarks table definitions with RLS"
      contains: "create table if not exists public.user_settings"
    - path: "src/lib/settings/settingsSync.ts"
      provides: "Settings push/pull/mapping functions"
      exports: ["syncSettingsToSupabase", "loadSettingsFromSupabase", "mapRowToSettings", "mapSettingsToRow"]
    - path: "src/lib/bookmarks/bookmarkSync.ts"
      provides: "Bookmark push/pull/merge functions"
      exports: ["syncBookmarksToSupabase", "loadBookmarksFromSupabase", "mergeBookmarks"]
    - path: "src/lib/social/streakSync.ts"
      provides: "Enhanced mergeStreakData with freeze recalculation"
      exports: ["mergeStreakData", "syncStreakToSupabase", "loadStreakFromSupabase"]
  key_links:
    - from: "src/lib/settings/settingsSync.ts"
      to: "supabase user_settings table"
      via: "supabase.from('user_settings').upsert/select"
      pattern: "supabase\\.from\\('user_settings'\\)"
    - from: "src/lib/bookmarks/bookmarkSync.ts"
      to: "supabase user_bookmarks table"
      via: "supabase.from('user_bookmarks').upsert/select"
      pattern: "supabase\\.from\\('user_bookmarks'\\)"
    - from: "src/lib/social/streakSync.ts"
      to: "src/lib/social/streakTracker.ts"
      via: "calculateStreak import for longest recomputation"
      pattern: "import.*calculateStreak.*from.*streakTracker"
---

<objective>
Create Supabase schema for settings and bookmarks tables, implement sync functions following established streakSync.ts patterns, and enhance the streak merge to recalculate freezes and longest streak from merged activity dates.

Purpose: Establishes the data layer for cross-device sync. All sync functions are pure or isolated async operations suitable for TDD. Later plans wire these into React contexts.
Output: `user_settings` + `user_bookmarks` Supabase tables, `settingsSync.ts`, `bookmarkSync.ts`, enhanced `streakSync.ts`, all with unit tests.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-cross-device-sync/46-CONTEXT.md
@.planning/phases/46-cross-device-sync/46-RESEARCH.md

<interfaces>
<!-- Existing interfaces the executor needs -->

From src/lib/social/streakSync.ts:
```typescript
interface StreakDataRow {
  user_id: string;
  activity_dates: string[];
  freezes_available: number;
  freezes_used: string[];
  longest_streak: number;
  updated_at: string;
}
export async function syncStreakToSupabase(userId: string, streakData: StreakData): Promise<void>;
export async function loadStreakFromSupabase(userId: string): Promise<StreakData | null>;
export function mergeStreakData(local: StreakData, remote: StreakData): StreakData;
```

From src/lib/social/streakStore.ts:
```typescript
export interface StreakData {
  activityDates: string[];
  freezesAvailable: number;
  freezesUsed: string[];
  longestStreak: number;
  lastSyncedAt: string | null;
  dailyActivityCounts: DailyActivityCounts;
}
```

From src/lib/social/streakTracker.ts:
```typescript
export function calculateStreak(
  activityDates: string[],
  freezesUsed: string[]
): { current: number; longest: number };
```

From src/lib/async/withRetry.ts:
```typescript
export async function withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>;
```

From src/lib/bookmarks/bookmarkStore.ts:
```typescript
export async function getAllBookmarkIds(): Promise<string[]>;
export async function setBookmark(questionId: string, starred: boolean): Promise<void>;
```

From src/lib/sentry.ts:
```typescript
export function captureError(error: unknown, context?: Record<string, unknown>): void;
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Supabase schema + settingsSync + bookmarkSync with tests</name>
  <files>supabase/schema.sql, src/lib/settings/settingsSync.ts, src/lib/settings/settingsSync.test.ts, src/lib/settings/index.ts, src/lib/bookmarks/bookmarkSync.ts, src/lib/bookmarks/bookmarkSync.test.ts, src/lib/bookmarks/index.ts</files>
  <behavior>
    - mapRowToSettings: maps snake_case DB row to camelCase UserSettings (theme, languageMode, ttsRate, ttsPitch, ttsAutoRead, ttsAutoReadLang, testDate)
    - mapSettingsToRow: maps camelCase UserSettings to snake_case DB columns for upsert
    - mapRowToSettings returns defaults for missing fields
    - mergeBookmarks: union of two string arrays, deduplicated and sorted
    - mergeBookmarks([A,B], [B,C]) returns [A,B,C]
    - mergeBookmarks([], [A]) returns [A] (first-time sync)
    - mergeBookmarks([A], []) returns [A] (no remote data)
    - syncSettingsToSupabase skips silently when offline (navigator.onLine === false)
    - syncBookmarksToSupabase skips silently when offline
    - loadSettingsFromSupabase returns null when no row exists
    - loadBookmarksFromSupabase returns empty array when no row exists
  </behavior>
  <action>
    **Schema (supabase/schema.sql):** Append two new tables after the existing `push_subscriptions` section and before the leaderboard functions:

    ```sql
    -- User settings for cross-device sync (Phase 46)
    create table if not exists public.user_settings (
      user_id uuid primary key references public.profiles (id) on delete cascade,
      theme text not null default 'light' check (theme in ('light', 'dark')),
      language_mode text not null default 'bilingual' check (language_mode in ('bilingual', 'english-only')),
      tts_rate text not null default 'normal' check (tts_rate in ('slow', 'normal', 'fast')),
      tts_pitch numeric not null default 1.02,
      tts_auto_read boolean not null default true,
      tts_auto_read_lang text not null default 'both' check (tts_auto_read_lang in ('english', 'burmese', 'both')),
      test_date text,
      updated_at timestamptz not null default now()
    );
    alter table public.user_settings enable row level security;
    drop policy if exists "Users can manage own settings" on public.user_settings;
    create policy "Users can manage own settings" on public.user_settings
      for all using (auth.uid() = user_id);
    drop policy if exists "Users can insert own settings" on public.user_settings;
    create policy "Users can insert own settings" on public.user_settings
      for insert with check (auth.uid() = user_id);

    -- User bookmarks for cross-device sync (Phase 46)
    create table if not exists public.user_bookmarks (
      user_id uuid primary key references public.profiles (id) on delete cascade,
      question_ids text[] not null default '{}',
      updated_at timestamptz not null default now()
    );
    alter table public.user_bookmarks enable row level security;
    drop policy if exists "Users can manage own bookmarks" on public.user_bookmarks;
    create policy "Users can manage own bookmarks" on public.user_bookmarks
      for all using (auth.uid() = user_id);
    drop policy if exists "Users can insert own bookmarks" on public.user_bookmarks;
    create policy "Users can insert own bookmarks" on public.user_bookmarks
      for insert with check (auth.uid() = user_id);
    ```

    **settingsSync.ts:** Create `src/lib/settings/settingsSync.ts` following the exact pattern from `streakSync.ts`:

    Define `UserSettings` interface with fields: `theme` ('light'|'dark'), `languageMode` ('bilingual'|'english-only'), `ttsRate` ('slow'|'normal'|'fast'), `ttsPitch` (number), `ttsAutoRead` (boolean), `ttsAutoReadLang` ('english'|'burmese'|'both'), `testDate` (string|null).

    Define `UserSettingsRow` interface for snake_case DB columns.

    Implement:
    - `mapRowToSettings(row: UserSettingsRow): UserSettings` — pure mapping function
    - `mapSettingsToRow(userId: string, settings: UserSettings): object` — pure mapping function for upsert payload
    - `syncSettingsToSupabase(userId: string, settings: UserSettings): Promise<void>` — fire-and-forget with `withRetry`, skip if offline, catch+captureError
    - `loadSettingsFromSupabase(userId: string): Promise<UserSettings | null>` — select with `maybeSingle()`, return null if no row

    NOTE: Do NOT sync `preferredVoiceName` (per user decision — voices differ by device/OS). Only sync portable TTS settings: rate, pitch, autoRead, autoReadLang.

    **settingsSync.test.ts:** Test the pure mapping functions (mapRowToSettings, mapSettingsToRow) and mergeBookmarks. Mock Supabase for push/pull tests.

    **src/lib/settings/index.ts:** Create barrel export re-exporting all from settingsSync.

    **bookmarkSync.ts:** Create `src/lib/bookmarks/bookmarkSync.ts` following streakSync pattern:

    Implement:
    - `mergeBookmarks(localIds: string[], remoteIds: string[]): string[]` — pure: union, dedup via Set, sort
    - `syncBookmarksToSupabase(userId: string, questionIds: string[]): Promise<void>` — upsert full set of IDs as text[] array, fire-and-forget pattern
    - `loadBookmarksFromSupabase(userId: string): Promise<string[]>` — select question_ids array, return [] if no row

    **bookmarkSync.test.ts:** Test mergeBookmarks pure function exhaustively. Mock Supabase for push/pull.

    **bookmarks/index.ts:** Update to also re-export from bookmarkSync.
  </action>
  <verify>
    <automated>pnpm test -- --run src/lib/settings/settingsSync.test.ts src/lib/bookmarks/bookmarkSync.test.ts</automated>
  </verify>
  <done>
    - user_settings and user_bookmarks tables defined in schema.sql with RLS policies
    - settingsSync.ts exports push/pull/mapping functions following streakSync pattern
    - bookmarkSync.ts exports push/pull/merge functions following streakSync pattern
    - All tests pass for mapping functions and merge logic
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Enhanced mergeStreakData with freeze recalculation and longest streak recomputation</name>
  <files>src/lib/social/streakSync.ts, src/lib/social/streakSync.test.ts</files>
  <behavior>
    - mergeStreakData unions activity dates (dedup + sort) -- existing behavior preserved
    - mergeStreakData unions freezes used (dedup + sort) -- existing behavior preserved
    - mergeStreakData removes freezes for dates that now have activity after merge (freeze recalculation)
    - mergeStreakData returns freed freeze count to freezesAvailable (capped at 3)
    - mergeStreakData recomputes longestStreak from full merged date set using calculateStreak (not max of both)
    - Edge: freezesAvailable never exceeds 3 after recalculation
    - Edge: merging with empty remote returns local data with recalculated longest
    - Edge: freeze on date that both devices have activity gets properly recalculated
    - Example: local has freeze on "2026-02-28" (missed day), remote has activity on "2026-02-28" -- after merge, freeze is removed and returned to pool
  </behavior>
  <action>
    **streakSync.test.ts:** Create or extend test file for `mergeStreakData`. Write tests covering:
    1. Basic union of activity dates (existing behavior)
    2. Basic union of freezes used (existing behavior)
    3. Freeze recalculation: freeze on a date that now has activity after merge is removed
    4. Freed freeze count returned to freezesAvailable (with cap at 3)
    5. Longest streak recomputed from merged dates using calculateStreak (verify it differs from simple max)
    6. Edge case: freezesAvailable cap at 3 even when multiple freezes freed
    7. Edge case: empty remote data
    8. Edge case: dailyActivityCounts kept from local (current device state)

    **streakSync.ts:** Modify `mergeStreakData` function:

    1. Union activity dates (keep existing)
    2. Union freezes used (keep existing)
    3. **NEW: Recalculate freezes** — filter out any freeze date that now appears in the merged activity dates set:
       ```typescript
       const activitySet = new Set(activityDates);
       const validFreezes = allFreezesUsed.filter(date => !activitySet.has(date));
       ```
    4. **NEW: Return freed freezes** — count freed = original - valid. Add freed count to max(local.freezesAvailable, remote.freezesAvailable), cap at 3:
       ```typescript
       const freedCount = allFreezesUsed.length - validFreezes.length;
       const freezesAvailable = Math.min(
         Math.max(local.freezesAvailable, remote.freezesAvailable) + freedCount,
         3
       );
       ```
    5. **NEW: Recompute longest from merged dates** using `calculateStreak(activityDates, validFreezes).longest` instead of `Math.max(local.longestStreak, remote.longestStreak)`:
       ```typescript
       import { calculateStreak } from './streakTracker';
       const { longest } = calculateStreak(activityDates, validFreezes);
       ```
    6. Return merged data with `longestStreak: longest` and `freezesUsed: validFreezes`.

    Add `import { calculateStreak } from './streakTracker';` at the top of streakSync.ts if not already present.
  </action>
  <verify>
    <automated>pnpm test -- --run src/lib/social/streakSync.test.ts</automated>
  </verify>
  <done>
    - mergeStreakData recalculates freezes after merge (removes freezes on days that now have activity)
    - Freed freezes returned to available pool (capped at 3)
    - Longest streak computed from full merged date set via calculateStreak
    - All existing streak sync behavior preserved (union dates, dedup, sort)
    - Tests cover edge cases (cap, empty remote, freeze recalculation)
  </done>
</task>

</tasks>

<verification>
1. `pnpm test -- --run src/lib/settings/settingsSync.test.ts` -- all settings mapping and sync tests pass
2. `pnpm test -- --run src/lib/bookmarks/bookmarkSync.test.ts` -- all bookmark merge and sync tests pass
3. `pnpm test -- --run src/lib/social/streakSync.test.ts` -- all enhanced streak merge tests pass
4. `pnpm build` -- no TypeScript errors from new files
5. supabase/schema.sql contains `user_settings` and `user_bookmarks` table definitions
</verification>

<success_criteria>
- user_settings table: theme, language_mode, tts_rate, tts_pitch, tts_auto_read, tts_auto_read_lang, test_date columns with RLS
- user_bookmarks table: question_ids text[] column with RLS
- settingsSync.ts: syncSettingsToSupabase, loadSettingsFromSupabase, mapRowToSettings, mapSettingsToRow exported
- bookmarkSync.ts: syncBookmarksToSupabase, loadBookmarksFromSupabase, mergeBookmarks exported
- streakSync.ts: mergeStreakData uses calculateStreak for longest, recalculates freezes, caps at 3
- All test files pass
</success_criteria>

<output>
After completion, create `.planning/phases/46-cross-device-sync/46-01-SUMMARY.md`
</output>
