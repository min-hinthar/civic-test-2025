---
phase: 06-interview-simulation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useInterviewTTS.ts
  - src/hooks/useAudioRecorder.ts
  - src/pages/SettingsPage.tsx
autonomous: true

must_haves:
  truths:
    - "TTS speaks text and fires onEnd callback when finished"
    - "TTS has timeout fallback in case browser onend event does not fire"
    - "Audio recorder captures microphone input and produces a playable blob URL"
    - "Recorder degrades gracefully if microphone permission is denied"
    - "User can select speech rate (slow/normal/fast) in settings"
  artifacts:
    - path: "src/hooks/useInterviewTTS.ts"
      provides: "Extended TTS hook with onEnd callbacks and timeout fallback"
      exports: ["useInterviewTTS"]
    - path: "src/hooks/useAudioRecorder.ts"
      provides: "MediaRecorder hook with waveform support and graceful degradation"
      exports: ["useAudioRecorder"]
    - path: "src/pages/SettingsPage.tsx"
      provides: "Speech rate selector setting"
      contains: "speech-rate"
  key_links:
    - from: "src/hooks/useInterviewTTS.ts"
      to: "src/lib/useSpeechSynthesis.ts"
      via: "extends findVoice logic"
      pattern: "findVoice|voicesRef|SpeechSynthesisUtterance"
    - from: "src/hooks/useAudioRecorder.ts"
      to: "MediaRecorder API"
      via: "navigator.mediaDevices.getUserMedia"
      pattern: "getUserMedia|MediaRecorder"
---

<objective>
Create the audio hooks that power the interview experience: TTS with sequencing callbacks and audio recording with waveform support.

Purpose: The interview flow requires precise orchestration of TTS playback (chime -> greeting -> question -> answer reading) with callbacks that trigger the next step. Audio recording captures user responses for self-review. Both hooks must degrade gracefully when browser APIs are unavailable.

Output: Two custom hooks (useInterviewTTS, useAudioRecorder) and a speech rate setting on the Settings page.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-interview-simulation/06-CONTEXT.md
@.planning/phases/06-interview-simulation/06-RESEARCH.md

@src/lib/useSpeechSynthesis.ts
@src/pages/SettingsPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extended TTS hook with onEnd callbacks and speech rate</name>
  <files>
    src/hooks/useInterviewTTS.ts
    src/pages/SettingsPage.tsx
  </files>
  <action>
    1. Create `src/hooks/useInterviewTTS.ts`:
       - Import and use the voice-finding logic pattern from existing `useSpeechSynthesis` hook (don't compose it directly since we need manual utterance control for onEnd). Replicate the voice loading (useEffect with retry polling + voiceschanged listener) and findVoice logic from useSpeechSynthesis.
       - State: `isSpeaking: boolean`, `isSupported: boolean`
       - Read speech rate from localStorage key `'civic-prep-speech-rate'` (values: 'slow' | 'normal' | 'fast', default 'normal')
       - Speech rate values: slow=0.7, normal=0.98, fast=1.3
       - Export `speakWithCallback(text: string, options?: { onEnd?: () => void; rate?: number }): void`:
         - Creates SpeechSynthesisUtterance with text
         - Selects voice via findVoice('en-US')
         - Sets rate from options.rate or localStorage preference
         - Attaches `utterance.onend` callback
         - Attaches `utterance.onerror` callback (calls onEnd as fallback)
         - **CRITICAL: Timeout fallback** - estimate duration as `(text.split(/\s+/).length / 2.5) * 1000 / rate + 3000` ms. Set a setTimeout that fires onEnd if utterance.onend hasn't fired yet. Clear timeout if onend fires first. This handles Chrome/Android onend unreliability.
         - Sets isSpeaking=true on start, isSpeaking=false when done
         - If `!isSupported`, immediately call onEnd (text-only fallback)
         - Calls `synth.cancel()` before speaking to clear any queued utterances
       - Export `cancel(): void` - cancels current speech and clears timeout
       - Export `isSpeaking: boolean`
       - Export `isSupported: boolean`

       **React Compiler rules to follow:**
       - Do NOT access ref.current during render
       - Use `useCallback` for speakWithCallback and cancel
       - Store synthesisRef, voicesRef, timeoutRef as useRef (access only in handlers/effects)

    2. Add speech rate setting to `src/pages/SettingsPage.tsx`:
       - Add a new settings section after the existing notification settings
       - Section heading: "Speech Rate" / "စကားပြောနှုန်း" using SectionHeading
       - Three radio-style buttons in a row: Slow / Normal / Fast
       - Store selection in localStorage key `'civic-prep-speech-rate'`
       - Default: 'normal'
       - Use Card component for the section wrapper
       - Use design token colors for active/inactive states
       - Import speech rate bilingual strings from strings.ts (if plan 01 is not yet complete, use inline strings temporarily and note they should match)
  </action>
  <verify>Run `npx tsc --noEmit`. Verify useInterviewTTS exports speakWithCallback, cancel, isSpeaking, isSupported. Verify SettingsPage renders speech rate selector without errors.</verify>
  <done>useInterviewTTS hook speaks text with onEnd callback, has timeout fallback for unreliable onend events, reads speech rate from localStorage. SettingsPage has a speech rate selector (slow/normal/fast) persisted to localStorage.</done>
</task>

<task type="auto">
  <name>Task 2: Audio recorder hook with graceful degradation</name>
  <files>src/hooks/useAudioRecorder.ts</files>
  <action>
    Create `src/hooks/useAudioRecorder.ts`:

    Export `useAudioRecorder()` hook returning:
    - `isRecording: boolean`
    - `hasPermission: boolean | null` (null = not yet asked, true = granted, false = denied)
    - `audioURL: string | null` (blob URL of last recording)
    - `stream: MediaStream | null` (exposed for waveform visualization component)
    - `requestPermission(): Promise<boolean>` - call getUserMedia({ audio: true }), store stream, set hasPermission. Return success boolean. Wrap in try-catch, return false on error.
    - `startRecording(): void` - if no stream, skip (graceful degradation). Create MediaRecorder from stream. Collect chunks via ondataavailable. On stop, create blob URL. Set isRecording=true.
    - `stopRecording(): void` - stop MediaRecorder, set isRecording=false. The onstop handler creates blob URL.
    - `clearRecording(): void` - revoke current blob URL (prevent memory leak), set audioURL to null.
    - `cleanup(): void` - stop all stream tracks, revoke blob URLs, reset state. Call this when leaving interview.

    **Implementation details:**
    - Store MediaRecorder in ref (access in handlers only, not render)
    - Store chunks in ref (not state - intermediate data)
    - Store stream in ref AND expose via state for waveform component
    - When creating new recording, revoke previous blob URL first (memory leak prevention per pitfall #5)
    - MediaRecorder mimeType: omit to let browser choose default (per research recommendation)
    - On unmount effect: call cleanup to stop tracks and revoke URLs

    **React Compiler rules:**
    - Refs accessed only in handlers/effects, never in render
    - Use useCallback for all exported functions
    - Lazy state for stream exposure: set stream state in requestPermission handler (not effect)

    **Graceful degradation:**
    - If navigator.mediaDevices is undefined (no HTTPS or unsupported): hasPermission stays null, all recording functions are no-ops
    - If permission denied: hasPermission=false, recording functions are no-ops
    - This enables the interview to work in "honor system" mode without recording
  </action>
  <verify>Run `npx tsc --noEmit`. Verify hook compiles and exports all required members. Verify that calling startRecording when hasPermission is null/false is a no-op (doesn't throw).</verify>
  <done>useAudioRecorder hook captures microphone input, produces blob URLs for playback, gracefully degrades if mic is unavailable, and properly cleans up blob URLs and stream tracks.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. useInterviewTTS hook has timeout fallback (search for setTimeout in the file)
3. useInterviewTTS reads speech rate from localStorage
4. useAudioRecorder handles permission denial without throwing
5. useAudioRecorder revokes blob URLs on cleanup (search for revokeObjectURL)
6. SettingsPage renders speech rate radio buttons
</verification>

<success_criteria>
Both hooks compile cleanly, handle all edge cases (no TTS support, no mic, permission denied), and follow React Compiler ESLint rules. Speech rate setting persists to localStorage.
</success_criteria>

<output>
After completion, create `.planning/phases/06-interview-simulation/06-02-SUMMARY.md`
</output>
