---
phase: 13-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pages/api/push/subscribe.ts
  - src/lib/pwa/pushNotifications.ts
  - src/hooks/usePushNotifications.ts
autonomous: true

must_haves:
  truths:
    - "Push subscribe endpoint rejects requests without a valid JWT with HTTP 401 and JSON error body"
    - "Push subscribe endpoint derives userId from verified JWT, never from request body"
    - "Rapid-fire subscription attempts from the same user are rate-limited"
    - "Failed auth attempts are logged to Sentry for monitoring"
    - "Client-side push code sends Authorization header with Supabase access token"
  artifacts:
    - path: "pages/api/push/subscribe.ts"
      provides: "JWT-verified push subscription API with rate limiting"
      contains: "supabase.auth.getUser"
    - path: "src/lib/pwa/pushNotifications.ts"
      provides: "Auth-aware push subscription client"
      contains: "Authorization"
  key_links:
    - from: "src/lib/pwa/pushNotifications.ts"
      to: "pages/api/push/subscribe.ts"
      via: "fetch with Authorization Bearer header"
      pattern: "Authorization.*Bearer"
    - from: "pages/api/push/subscribe.ts"
      to: "@supabase/supabase-js"
      via: "JWT verification with getUser()"
      pattern: "auth\\.getUser"
---

<objective>
Harden the push subscription API endpoint with JWT authentication, per-user rate limiting, and Sentry error logging. Update the client-side push notification code to send the user's Supabase access token.

Purpose: The `/api/push/subscribe` endpoint currently trusts client-provided `userId` with zero authentication, using `SUPABASE_SERVICE_ROLE_KEY` (admin access). Any unauthenticated request can create/modify/delete push subscriptions for arbitrary users. This is the most critical security gap in the application.

Output: Secure push subscription API + auth-aware client code.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@pages/api/push/subscribe.ts
@src/lib/pwa/pushNotifications.ts
@src/hooks/usePushNotifications.ts
@src/lib/supabaseClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite push subscribe API with JWT verification and rate limiting</name>
  <files>pages/api/push/subscribe.ts</files>
  <action>
Rewrite `pages/api/push/subscribe.ts` to add JWT authentication, per-user rate limiting, and Sentry error logging:

**JWT Verification (both POST and DELETE):**
1. Extract `Authorization` header from the request. If missing or not `Bearer <token>` format, return 401 JSON: `{ error: 'Missing authorization header' }`.
2. Create a per-request Supabase client using the anon key and the user's Bearer token in the `global.headers.Authorization` field.
3. Call `supabaseUser.auth.getUser()` to verify the token server-side.
4. If verification fails (error or no user), log to Sentry using `captureException` (or import from `@sentry/nextjs`) with context tags: `{ reason: error?.message ?? 'no user', ip: req.headers['x-forwarded-for'] }`. Return 401 JSON: `{ error: 'Invalid or expired token' }`.
5. Use `user.id` (from verified JWT) as the userId -- completely ignore any `userId` field from `req.body`.

**Rate Limiting (POST and DELETE):**
1. Create an in-memory `Map<string, { count: number; resetAt: number }>` at module level (outside the handler).
2. Constants: `WINDOW_MS = 60_000` (1 minute), `MAX_REQUESTS = 10` (per user per minute).
3. Before processing, check rate limit for the verified `user.id`. If over limit, return 429 JSON: `{ error: 'Too many requests' }` with `Retry-After` header.
4. Add a cleanup step: delete entries where `Date.now() > resetAt` (run occasionally, e.g., every 100th request).

**Keep the existing Supabase admin client** (`SUPABASE_SERVICE_ROLE_KEY`) for the actual upsert/delete operations -- the admin client bypasses RLS, which is correct here since we've already verified the user's identity via JWT. The push_subscriptions table may not yet have RLS policies (that's Plan 03's job).

**Request body changes:**
- POST: Accept `{ subscription, reminderFrequency }` (remove `userId` from expected body).
- DELETE: Accept empty body or `{}` (userId comes from JWT).

**Error handling:** Wrap all operations in try/catch. Internal errors return 500. Auth errors return 401. Rate limit errors return 429.
  </action>
  <verify>
1. Read the file and confirm: `auth.getUser` is called, `req.body.userId` is NOT used for database operations, rate limit map exists, Sentry capture is present for auth failures, 401/429 responses are JSON.
2. Run `pnpm run typecheck` to verify TypeScript compiles.
  </verify>
  <done>
- POST requests without Authorization header get 401 JSON response
- POST requests with invalid JWT get 401 JSON response with Sentry logging
- POST requests use verified user.id from JWT for database upsert
- Rapid-fire requests (>10/min) from same user get 429 response
- DELETE requests also require JWT verification
- No reference to req.body.userId for database operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Update client-side push code to send Authorization header</name>
  <files>src/lib/pwa/pushNotifications.ts, src/hooks/usePushNotifications.ts</files>
  <action>
**Update `src/lib/pwa/pushNotifications.ts`:**

1. Change `subscribeToPush` signature: Remove `userId` parameter. Add `accessToken: string` parameter. New signature: `subscribeToPush(accessToken: string, reminderFrequency: ReminderFrequency)`.
2. In the fetch call, add `Authorization: Bearer ${accessToken}` header. Remove `userId` from the JSON body (only send `subscription` and `reminderFrequency`).
3. Handle 401 response specifically: if `response.status === 401`, log a warning `console.warn('Push subscribe auth failed - session may be expired')` and return false.
4. Change `unsubscribeFromPush` signature: Remove `userId` parameter. Add `accessToken: string` parameter. New signature: `unsubscribeFromPush(accessToken: string)`.
5. In the DELETE fetch call, add `Authorization: Bearer ${accessToken}` header. Send empty object `{}` as body (no userId needed).
6. Handle 401 response in unsubscribe too.

**Update `src/hooks/usePushNotifications.ts`:**

1. The hook currently receives `userId: string | null`. It needs to also get the access token. Import `supabase` from `@/lib/supabaseClient`.
2. In the `subscribe` callback: Before calling `subscribeToPush`, get the session via `supabase.auth.getSession()`. If no session or no `access_token`, return false with a console warning. Pass `session.data.session.access_token` instead of `userId` to `subscribeToPush`.
3. In the `unsubscribe` callback: Same pattern -- get session, extract access_token, pass to `unsubscribeFromPush`.
4. In the `updateFrequency` callback: Same pattern for the subscribeToPush call inside it.
5. The hook's `userId` parameter is still needed for the null check (no push if not logged in), but it's no longer passed to the API functions.
  </action>
  <verify>
1. Read both files and confirm: no `userId` in fetch body, `Authorization` header is present in all API calls, `supabase.auth.getSession()` is called before API requests.
2. Run `pnpm run typecheck` to verify no TypeScript errors from signature changes.
3. Search for any other callers of `subscribeToPush` or `unsubscribeFromPush` that need updating: `grep -r "subscribeToPush\|unsubscribeFromPush" src/` -- update any found.
  </verify>
  <done>
- subscribeToPush sends Authorization header, not userId in body
- unsubscribeFromPush sends Authorization header, not userId in body
- Hook gets access token from supabase.auth.getSession() before each API call
- 401 responses handled gracefully (console warning, return false)
- TypeScript compiles with no errors
  </done>
</task>

</tasks>

<verification>
1. `pnpm run typecheck` passes
2. `pnpm run build` succeeds (no build-time errors)
3. No reference to `req.body.userId` in subscribe.ts for database operations
4. Authorization header present in both subscribe and unsubscribe client calls
5. Rate limit logic present with configurable window and max requests
</verification>

<success_criteria>
- Push API endpoint requires valid JWT and returns 401 without one
- User ID derived from verified JWT, never from client request body
- Per-user rate limiting active (10 req/min default)
- Failed auth attempts logged to Sentry
- Client code sends Supabase access token in Authorization header
</success_criteria>

<output>
After completion, create `.planning/phases/13-security-hardening/13-01-SUMMARY.md`
</output>
