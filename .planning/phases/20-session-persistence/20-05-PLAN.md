---
phase: 20-session-persistence
plan: 05
type: execute
wave: 3
depends_on: ["20-01", "20-02", "20-03"]
files_modified:
  - src/pages/TestPage.tsx
autonomous: true

must_haves:
  truths:
    - "User who closes browser mid-mock-test sees resume prompt with session info when returning to /test"
    - "Resumed mock test restores exact question set, progress, and results"
    - "Timer resets to full 20 minutes on resume (fresh timer per user decision)"
    - "Countdown (5-4-3-2-1-Go!) shows before every timed mock test start (new or resumed)"
    - "Session is saved to IndexedDB after every answer"
    - "Session is deleted from IndexedDB when test completes/scores"
    - "Not Now dismisses modal, keeps session saved, re-appears on next visit to /test"
  artifacts:
    - path: "src/pages/TestPage.tsx"
      provides: "Mock test page with session persistence, resume prompt, and countdown integration"
      contains: "saveSession"
  key_links:
    - from: "src/pages/TestPage.tsx"
      to: "src/lib/sessions/sessionStore.ts"
      via: "saveSession after each answer, deleteSession on completion"
      pattern: "import.*saveSession.*deleteSession"
    - from: "src/pages/TestPage.tsx"
      to: "src/components/sessions/ResumePromptModal.tsx"
      via: "Shows modal when saved sessions exist on mount"
      pattern: "ResumePromptModal"
    - from: "src/pages/TestPage.tsx"
      to: "src/components/sessions/SessionCountdown.tsx"
      via: "Countdown before test start"
      pattern: "SessionCountdown"
---

<objective>
Integrate session persistence into TestPage: save progress after each answer, show resume prompt on mount, add countdown before test start, clean up on completion.

Purpose: This is the primary SESS-01 implementation. Users never lose mock test progress when closing the browser, and see a polished countdown before every timed test.

Output: Modified TestPage.tsx with full session persistence lifecycle.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-session-persistence/20-RESEARCH.md
@.planning/phases/20-session-persistence/20-CONTEXT.md
@.planning/phases/20-session-persistence/20-01-SUMMARY.md
@.planning/phases/20-session-persistence/20-02-SUMMARY.md
@.planning/phases/20-session-persistence/20-03-SUMMARY.md
@src/pages/TestPage.tsx
@src/lib/sessions/sessionTypes.ts
@src/lib/sessions/sessionStore.ts
@src/components/sessions/ResumePromptModal.tsx
@src/components/sessions/SessionCountdown.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: TestPage session persistence integration</name>
  <files>src/pages/TestPage.tsx</files>
  <action>
Modify `src/pages/TestPage.tsx` to add session persistence. This is a significant modification to an existing 840-line file. Be surgical -- add new functionality without restructuring existing code.

**New imports:**
```typescript
import { saveSession, getSessionsByType, deleteSession } from '@/lib/sessions/sessionStore';
import type { MockTestSnapshot } from '@/lib/sessions/sessionTypes';
import { SESSION_VERSION } from '@/lib/sessions/sessionTypes';
import { ResumePromptModal } from '@/components/sessions/ResumePromptModal';
import { SessionCountdown } from '@/components/sessions/SessionCountdown';
```

**New state flow (extends existing PreTest -> Active -> Finished):**

The TestPage currently has this flow:
1. `showPreTest = true` -> PreTestScreen
2. `showPreTest = false` -> Active test (timer running, questions showing)
3. `isFinished = true` -> Results view

New flow:
1. `showPreTest = true` -> Check for saved sessions -> Show ResumePromptModal if sessions exist
2. User clicks "I'm Ready" OR "Resume" -> Show SessionCountdown (5-4-3-2-1-Go!)
3. Countdown completes -> Active test (timer running)
4. `isFinished = true` -> Results view + delete saved session

**Implementation changes:**

1. **Add new state variables** (at the top of the component, after existing state):
   ```typescript
   const [savedSessions, setSavedSessions] = useState<MockTestSnapshot[]>([]);
   const [showResumeModal, setShowResumeModal] = useState(false);
   const [showCountdown, setShowCountdown] = useState(false);
   const [sessionId] = useState(() => `session-mock-test-${Date.now()}`);
   const [isResuming, setIsResuming] = useState(false);
   ```

2. **Check for saved sessions on mount:**
   Add a useEffect that checks IndexedDB for saved mock-test sessions:
   ```typescript
   useEffect(() => {
     let cancelled = false;
     getSessionsByType('mock-test').then(sessions => {
       if (!cancelled && sessions.length > 0) {
         setSavedSessions(sessions as MockTestSnapshot[]);
         setShowResumeModal(true);
       }
     }).catch(() => {
       // IndexedDB not available
     });
     return () => { cancelled = true; };
   }, []);
   ```

3. **Modify the questions memo to support resume:**
   Currently `questions` is a `useMemo(() => fisherYatesShuffle(allQuestions)..., [])`. This needs to support restoring from a saved session.

   Change approach: Use `useState` with lazy init instead of `useMemo`:
   ```typescript
   const [questions, setQuestions] = useState(() =>
     fisherYatesShuffle(allQuestions)
       .slice(0, 20)
       .map(question => ({
         ...question,
         answers: fisherYatesShuffle(question.answers),
       }))
   );
   ```
   This allows `setQuestions` to be called when resuming a saved session.

4. **Handle Resume action:**
   ```typescript
   const handleResume = useCallback((session: SessionSnapshot) => {
     const mockSession = session as MockTestSnapshot;
     setQuestions(mockSession.questions);
     setResults(mockSession.results);
     setCurrentIndex(mockSession.currentIndex);
     // Timer resets to full duration (user decision: fresh timer on resume)
     setTimeLeft(TEST_DURATION_SECONDS);
     setShowResumeModal(false);
     setIsResuming(true);
     setShowPreTest(false);
     // Show countdown before resuming
     setShowCountdown(true);
   }, []);
   ```

5. **Handle Start Fresh action:**
   ```typescript
   const handleStartFresh = useCallback((session: SessionSnapshot) => {
     deleteSession(session.id).catch(() => {});
     setSavedSessions([]);
     setShowResumeModal(false);
     // Continue to normal PreTestScreen
   }, []);
   ```

6. **Handle Not Now action:**
   ```typescript
   const handleNotNow = useCallback(() => {
     setShowResumeModal(false);
     // Session stays saved, modal re-appears on next visit
   }, []);
   ```

7. **Modify the PreTestScreen "I'm Ready" handler:**
   Change `onReady={() => setShowPreTest(false)}` to:
   ```typescript
   onReady={() => {
     setShowPreTest(false);
     setShowCountdown(true);
   }}
   ```
   So the countdown shows for ALL timed test starts, not just resumed ones (per user decision).

8. **Handle countdown complete:**
   ```typescript
   const handleCountdownComplete = useCallback(() => {
     setShowCountdown(false);
   }, []);
   ```

9. **Save session after each answer:**
   In the `handleAnswerSelect` callback, after creating the `result` object and before the feedback timeout, add a fire-and-forget save:
   ```typescript
   // Fire-and-forget: persist session snapshot
   const snapshot: MockTestSnapshot = {
     id: sessionId,
     type: 'mock-test',
     savedAt: new Date().toISOString(),
     version: SESSION_VERSION,
     questions,
     results: [...results, result],
     currentIndex: currentIndex + 1,
     timeLeft,
   };
   saveSession(snapshot).catch(() => {});
   ```

10. **Delete session on completion:**
    In the existing save-session-on-finish effect (the one that calls `saveTestSession`), after the save succeeds, delete the IndexedDB session:
    ```typescript
    // Clean up saved session from IndexedDB
    deleteSession(sessionId).catch(() => {});
    ```

11. **Update the render logic:**
    - If `showResumeModal` is true, show the ResumePromptModal overlay (even while PreTestScreen is visible underneath)
    - If `showCountdown` is true, show SessionCountdown overlay
    - Countdown subtitle: for resume show "Mock Test — Q{currentIndex+1}/{questions.length}", for new show "Mock Test — {questions.length} Questions"

    In the PreTestScreen section:
    ```tsx
    if (showPreTest) {
      return (
        <div className="page-shell" data-tour="mock-test">
          <UpdateBanner showBurmese={showBurmese} />
          <PreTestScreen
            questionCount={20}
            durationMinutes={20}
            onReady={() => {
              setShowPreTest(false);
              setShowCountdown(true);
            }}
          />
          <ResumePromptModal
            sessions={savedSessions}
            open={showResumeModal}
            onResume={handleResume}
            onStartFresh={handleStartFresh}
            onNotNow={handleNotNow}
          />
        </div>
      );
    }

    if (showCountdown) {
      return (
        <div className="page-shell" data-tour="mock-test">
          <SessionCountdown
            onComplete={handleCountdownComplete}
            subtitle={isResuming
              ? `Mock Test — Q${currentIndex + 1}/${questions.length}`
              : `Mock Test — ${questions.length} Questions`}
          />
        </div>
      );
    }
    ```

**IMPORTANT constraints:**
- Do NOT restructure the existing code. Add new state and handlers alongside existing ones.
- The `questions` must change from `useMemo` to `useState` with lazy init to allow resume to set questions.
- `questionsById` memo still derives from `questions` state -- this works automatically.
- The timer countdown effect already resets properly since `timeLeft` is set to `TEST_DURATION_SECONDS` on resume.
- The `processResult` callback already works with the new state since it reads `results` and `questions.length`.
  </action>
  <verify>
`npm run typecheck` passes. `npm run lint` passes. `npm run build` passes. Test the flow:
1. Start a mock test, answer a few questions, close browser tab
2. Navigate back to /test -- resume modal should appear with session info
3. Click Resume -- countdown plays, then test resumes at the correct question
4. Complete the test -- session is deleted from IndexedDB
  </verify>
  <done>
TestPage saves mock test progress after every answer, checks for saved sessions on mount, shows ResumePromptModal when sessions exist, shows SessionCountdown before every test start (new and resumed), deletes session on completion. Full SESS-01 implementation.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. `npm run build` passes (no SSR issues)
4. Mock test session is saved after each answer
5. Resume modal appears on /test when saved session exists
6. Resume restores questions, results, and currentIndex
7. Timer resets to full 20 minutes on resume
8. Countdown shows before every timed test start
9. Session is deleted on test completion
10. Start Fresh deletes session and shows normal PreTestScreen
11. Not Now dismisses modal but keeps session for next visit
</verification>

<success_criteria>
- User who closes browser mid-mock-test sees resume prompt on return (SESS-01)
- Resumed test has exact same questions and progress
- Timer gets full reset on resume (user decision)
- Countdown plays before every timed test (user decision)
- Session auto-cleans on completion (user decision)
- No regressions to existing test functionality
</success_criteria>

<output>
After completion, create `.planning/phases/20-session-persistence/20-05-SUMMARY.md`
</output>
