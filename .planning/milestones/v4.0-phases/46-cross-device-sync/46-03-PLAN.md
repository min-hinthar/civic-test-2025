---
phase: 46-cross-device-sync
plan: 3
type: execute
wave: 2
depends_on: ["46-01"]
files_modified:
  - src/hooks/useVisibilitySync.ts
  - src/contexts/SupabaseAuthContext.tsx
  - src/contexts/SocialContext.tsx
autonomous: true
requirements:
  - SYNC-01
  - SYNC-02
  - SYNC-03
  - SYNC-04

must_haves:
  truths:
    - "Settings are pulled from Supabase on login and written to localStorage (server wins)"
    - "Bookmarks are pulled from Supabase on login and merged with local (add-wins)"
    - "Streak merge is triggered on login with enhanced freeze recalculation"
    - "Settings, bookmarks, and streaks re-pull from Supabase when tab becomes visible"
    - "Visibility re-pull is throttled (minimum 5-second gap between pulls)"
    - "SRS cards continue to sync on visibility change (existing behavior preserved)"
    - "SYNC-01 answer history is confirmed working via existing SRS sync + visibility trigger"
  artifacts:
    - path: "src/hooks/useVisibilitySync.ts"
      provides: "Centralized visibility-change sync trigger for all data types"
      exports: ["useVisibilitySync"]
    - path: "src/contexts/SupabaseAuthContext.tsx"
      provides: "Login hydration triggers settings and bookmark pull"
      contains: "loadSettingsFromSupabase"
    - path: "src/contexts/SocialContext.tsx"
      provides: "Enhanced streak merge on login with freeze recalculation"
      contains: "mergeStreakData"
  key_links:
    - from: "src/hooks/useVisibilitySync.ts"
      to: "src/lib/settings/settingsSync.ts"
      via: "import loadSettingsFromSupabase"
      pattern: "import.*loadSettingsFromSupabase.*from.*settings"
    - from: "src/hooks/useVisibilitySync.ts"
      to: "src/lib/bookmarks/bookmarkSync.ts"
      via: "import loadBookmarksFromSupabase"
      pattern: "import.*loadBookmarksFromSupabase.*from.*bookmarks"
    - from: "src/contexts/SupabaseAuthContext.tsx"
      to: "src/lib/settings/settingsSync.ts"
      via: "settings pull on login"
      pattern: "loadSettingsFromSupabase"
    - from: "src/contexts/SupabaseAuthContext.tsx"
      to: "src/lib/bookmarks/bookmarkSync.ts"
      via: "bookmark pull on login"
      pattern: "loadBookmarksFromSupabase"
---

<objective>
Create a visibility sync hook and integrate settings/bookmark pull into the login hydration flow, ensuring all synced data refreshes when the user returns to the app or logs in on a new device.

Purpose: Completes the pull side of cross-device sync. Plan 02 handles push (on change), this plan handles pull (on login and on tab visibility). Together they provide seamless cross-device sync.
Output: `useVisibilitySync` hook, enhanced SupabaseAuthContext hydration, and enhanced SocialContext streak merge.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-cross-device-sync/46-CONTEXT.md
@.planning/phases/46-cross-device-sync/46-RESEARCH.md
@.planning/phases/46-cross-device-sync/46-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 outputs -->

From src/lib/settings/settingsSync.ts (created in Plan 01):
```typescript
export interface UserSettings {
  theme: 'light' | 'dark';
  languageMode: 'bilingual' | 'english-only';
  ttsRate: 'slow' | 'normal' | 'fast';
  ttsPitch: number;
  ttsAutoRead: boolean;
  ttsAutoReadLang: 'english' | 'burmese' | 'both';
  testDate: string | null;
}
export async function syncSettingsToSupabase(userId: string, settings: UserSettings): Promise<void>;
export async function loadSettingsFromSupabase(userId: string): Promise<UserSettings | null>;
```

From src/lib/bookmarks/bookmarkSync.ts (created in Plan 01):
```typescript
export async function syncBookmarksToSupabase(userId: string, questionIds: string[]): Promise<void>;
export async function loadBookmarksFromSupabase(userId: string): Promise<string[]>;
export function mergeBookmarks(localIds: string[], remoteIds: string[]): string[];
```

From src/lib/social/streakSync.ts (enhanced in Plan 01):
```typescript
export function mergeStreakData(local: StreakData, remote: StreakData): StreakData;
// Now recalculates freezes and recomputes longest from merged dates
```

From src/lib/bookmarks/bookmarkStore.ts (existing):
```typescript
export async function getAllBookmarkIds(): Promise<string[]>;
export async function setBookmark(questionId: string, starred: boolean): Promise<void>;
export async function clearAllBookmarks(): Promise<void>;
```

From src/contexts/SupabaseAuthContext.tsx (existing):
```typescript
// hydrateFromSupabase(session) is called on login and auth state change
// It fetches profiles and mock_tests data
// user.id is available after hydration
```

From src/contexts/SocialContext.tsx (existing):
```typescript
// init() function loads social profile and merges streak data on mount
// Uses: loadStreakFromSupabase, mergeStreakData, syncStreakToSupabase
```

From src/hooks/useLeaderboard.ts (established pattern):
```typescript
// Visibility change with throttle:
// if (now - lastFetchRef.current < MIN_REFRESH_INTERVAL_MS) return;
```

From src/contexts/SRSContext.tsx (existing):
```typescript
// Already has visibilitychange listener that calls refreshDeck()
// No changes needed for SYNC-01
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useVisibilitySync hook for re-pull on tab focus</name>
  <files>src/hooks/useVisibilitySync.ts</files>
  <action>
    Create `src/hooks/useVisibilitySync.ts` -- a hook that triggers re-pull for settings, bookmarks, and streaks when the tab becomes visible.

    **Implementation:**

    ```typescript
    'use client';

    import { useEffect, useRef } from 'react';

    const MIN_SYNC_INTERVAL_MS = 5000; // Minimum 5 seconds between visibility syncs

    /**
     * Hook that triggers data re-pull from Supabase when the tab becomes visible.
     *
     * Uses a throttle (5-second minimum interval) to prevent rapid-fire pulls
     * from quick tab switches. Pattern adapted from useLeaderboard.ts.
     *
     * @param userId - Current authenticated user ID (null/undefined skips sync)
     * @param callbacks - Pull functions to call on visibility change
     */
    export function useVisibilitySync(
      userId: string | undefined,
      callbacks: {
        pullSettings: () => Promise<void>;
        pullBookmarks: () => Promise<void>;
        pullStreaks: () => Promise<void>;
      }
    ): void {
      const lastSyncRef = useRef<number>(0);
      const callbacksRef = useRef(callbacks);
      callbacksRef.current = callbacks;

      useEffect(() => {
        if (!userId) return;

        const handleVisibilityChange = () => {
          if (document.visibilityState !== 'visible') return;

          const now = Date.now();
          if (now - lastSyncRef.current < MIN_SYNC_INTERVAL_MS) return;
          lastSyncRef.current = now;

          // Fire all pulls concurrently, each handles its own errors
          callbacksRef.current.pullSettings();
          callbacksRef.current.pullBookmarks();
          callbacksRef.current.pullStreaks();
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
        };
      }, [userId]);
    }
    ```

    **Key design decisions:**
    - `callbacksRef` avoids stale closure issues (callbacks change every render due to closure over state)
    - 5-second throttle matches the pattern from research (prevents race conditions from rapid tab switches)
    - Each pull function handles its own errors internally (fire-and-forget)
    - No `isSyncing` flag needed because pulls are independent and idempotent
    - No Promise.all -- intentionally fire concurrently without waiting for all to complete
  </action>
  <verify>
    <automated>pnpm build</automated>
  </verify>
  <done>
    - useVisibilitySync hook created at src/hooks/useVisibilitySync.ts
    - Listens for visibilitychange events when userId is provided
    - Throttles to 5-second minimum interval between syncs
    - Calls pullSettings, pullBookmarks, pullStreaks concurrently
    - Uses callbacksRef to avoid stale closures
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate settings and bookmark pull into login hydration + wire useVisibilitySync into SocialContext</name>
  <files>src/contexts/SupabaseAuthContext.tsx, src/contexts/SocialContext.tsx</files>
  <action>
    **SupabaseAuthContext.tsx -- Settings and Bookmark pull on login:**

    1. Import at top:
       ```typescript
       import { loadSettingsFromSupabase } from '@/lib/settings';
       import { loadBookmarksFromSupabase, mergeBookmarks } from '@/lib/bookmarks';
       import { getAllBookmarkIds, setBookmark } from '@/lib/bookmarks';
       ```

    2. Inside `hydrateFromSupabase` callback, AFTER the existing `Promise.all` that fetches profileData and testsData (line ~114), add settings and bookmark pull:

       ```typescript
       // Pull settings from Supabase (server wins) -- Phase 46
       loadSettingsFromSupabase(authUser.id).then(remoteSettings => {
         if (!remoteSettings) return;
         // Write synced values to existing localStorage keys
         // so contexts hydrate correctly on next mount
         try {
           localStorage.setItem('civic-theme', remoteSettings.theme);
           localStorage.setItem('civic-test-language-mode', remoteSettings.languageMode);
           localStorage.setItem('civic-prep-tts-settings', JSON.stringify({
             rate: remoteSettings.ttsRate,
             pitch: remoteSettings.ttsPitch,
             autoRead: remoteSettings.ttsAutoRead,
             autoReadLang: remoteSettings.ttsAutoReadLang,
             // Preserve device-local preferredVoiceName
             ...((() => { try { return { preferredVoiceName: JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').preferredVoiceName }; } catch { return {}; } })()),
           }));
           if (remoteSettings.testDate) {
             localStorage.setItem('civic-prep-test-date', remoteSettings.testDate);
           } else {
             localStorage.removeItem('civic-prep-test-date');
           }
         } catch {
           // localStorage unavailable
         }
       }).catch(() => { /* silent -- settings pull failure is non-critical */ });

       // Pull and merge bookmarks from Supabase (add-wins) -- Phase 46
       Promise.all([
         loadBookmarksFromSupabase(authUser.id),
         getAllBookmarkIds(),
       ]).then(async ([remoteIds, localIds]) => {
         const merged = mergeBookmarks(localIds, remoteIds);

         // Write merged set to IndexedDB
         // For add-wins merge: add any remote IDs not in local
         const localSet = new Set(localIds);
         for (const id of merged) {
           if (!localSet.has(id)) {
             await setBookmark(id, true);
           }
         }

         // Push merged set back to Supabase for consistency
         // (in case local had bookmarks not yet in cloud)
         if (merged.length > localIds.length || merged.length > remoteIds.length) {
           const { syncBookmarksToSupabase } = await import('@/lib/bookmarks');
           syncBookmarksToSupabase(authUser.id, merged);
         }
       }).catch(() => { /* silent -- bookmark pull failure is non-critical */ });
       ```

    **IMPORTANT:** These pulls are fire-and-forget (`.then()` chains with `.catch()` swallowing errors). They do NOT block the existing hydration flow. The `setUser` call happens before these resolve.

    **SocialContext.tsx -- Wire useVisibilitySync + enhanced streak merge:**

    1. Import `useVisibilitySync` from `@/hooks/useVisibilitySync`:
       ```typescript
       import { useVisibilitySync } from '@/hooks/useVisibilitySync';
       ```

    2. Import bookmark and settings pull functions:
       ```typescript
       import { loadSettingsFromSupabase } from '@/lib/settings';
       import { loadBookmarksFromSupabase, mergeBookmarks } from '@/lib/bookmarks';
       import { getAllBookmarkIds, setBookmark as persistBookmark } from '@/lib/bookmarks';
       ```

    3. Inside `SocialProvider`, AFTER the existing `useEffect` that does init (line ~99-152), add the `useVisibilitySync` hook:

       ```typescript
       // Visibility sync: re-pull all synced data when tab becomes visible
       useVisibilitySync(user?.id, {
         pullSettings: async () => {
           if (!user?.id) return;
           const remote = await loadSettingsFromSupabase(user.id);
           if (!remote) return;
           try {
             localStorage.setItem('civic-theme', remote.theme);
             localStorage.setItem('civic-test-language-mode', remote.languageMode);
             localStorage.setItem('civic-prep-tts-settings', JSON.stringify({
               rate: remote.ttsRate,
               pitch: remote.ttsPitch,
               autoRead: remote.ttsAutoRead,
               autoReadLang: remote.ttsAutoReadLang,
               ...((() => { try { return { preferredVoiceName: JSON.parse(localStorage.getItem('civic-prep-tts-settings') ?? '{}').preferredVoiceName }; } catch { return {}; } })()),
             }));
             if (remote.testDate) {
               localStorage.setItem('civic-prep-test-date', remote.testDate);
             } else {
               localStorage.removeItem('civic-prep-test-date');
             }
           } catch { /* localStorage unavailable */ }
         },
         pullBookmarks: async () => {
           if (!user?.id) return;
           const [remoteIds, localIds] = await Promise.all([
             loadBookmarksFromSupabase(user.id),
             getAllBookmarkIds(),
           ]);
           const merged = mergeBookmarks(localIds, remoteIds);
           const localSet = new Set(localIds);
           for (const id of merged) {
             if (!localSet.has(id)) {
               await persistBookmark(id, true);
             }
           }
         },
         pullStreaks: async () => {
           if (!user?.id) return;
           const [remoteStreak, localStreak] = await Promise.all([
             loadStreakFromSupabase(user.id),
             getStreakData(),
           ]);
           if (remoteStreak) {
             const merged = mergeStreakData(localStreak, remoteStreak);
             await saveStreakData(merged);
             syncStreakToSupabase(user.id, merged);
           }
         },
       });
       ```

    4. Add `import { saveStreakData } from '@/lib/social/streakStore'` if not already imported (it imports `getStreakData` already -- add `saveStreakData` to the import).

    **Note on existing streak merge in SocialContext:** The `init()` function already calls `mergeStreakData` on login. Since we enhanced that function in Plan 01, the enhanced merge (freeze recalculation, longest recomputation) automatically applies to the existing login flow without any code changes to init(). No modification needed to the existing init logic.

    **Note on SRSContext.tsx (SYNC-01):** The SRSContext already has a visibility change handler (line 141-152) that calls `refreshDeck()` on visibility change. This already handles SYNC-01 (answer history/mastery data re-pull). No changes needed.
  </action>
  <verify>
    <automated>pnpm build</automated>
  </verify>
  <done>
    - SupabaseAuthContext pulls settings (server-wins) and bookmarks (add-wins merge) on login
    - SocialContext wires useVisibilitySync for re-pull on tab visibility
    - Settings pull writes to existing localStorage keys so contexts hydrate correctly
    - Bookmark pull merges local+remote and writes new IDs to IndexedDB
    - Streak re-pull on visibility triggers enhanced merge (freeze recalculation)
    - SRS visibility sync (SYNC-01) confirmed already working, no changes needed
    - All pull operations are fire-and-forget (non-blocking, silent errors)
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with no TypeScript errors
2. `pnpm test -- --run` passes all existing tests
3. SupabaseAuthContext.tsx contains `loadSettingsFromSupabase` and `loadBookmarksFromSupabase` calls
4. SocialContext.tsx contains `useVisibilitySync` hook call
5. useVisibilitySync.ts exists with throttled visibility change listener
6. SRSContext.tsx still has its existing visibility change handler (unchanged)
</verification>

<success_criteria>
- Settings pulled from Supabase on login and written to localStorage (server wins)
- Bookmarks pulled from Supabase on login and merged with local IndexedDB (add-wins)
- Streak merge on login uses enhanced freeze recalculation (from Plan 01)
- All synced data re-pulls on tab visibility with 5-second throttle
- SRS data continues to sync on visibility change (existing behavior, SYNC-01)
- No loading spinners, no sync indicators, no user-visible sync operations
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/46-cross-device-sync/46-03-SUMMARY.md`
</output>
