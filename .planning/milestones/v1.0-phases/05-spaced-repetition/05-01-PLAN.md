---
phase: 05-spaced-repetition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/srs/srsTypes.ts
  - src/lib/srs/fsrsEngine.ts
  - src/lib/srs/srsStore.ts
  - src/lib/srs/index.ts
autonomous: true

must_haves:
  truths:
    - "FSRS engine can create new cards and grade them with binary Easy/Hard rating"
    - "SRS card state persists in IndexedDB across page refreshes"
    - "Due cards can be queried from IndexedDB by comparing due date to now"
  artifacts:
    - path: "src/lib/srs/srsTypes.ts"
      provides: "SRSCardRecord interface, SupabaseSRSRow type, session types"
      contains: "SRSCardRecord"
    - path: "src/lib/srs/fsrsEngine.ts"
      provides: "FSRS singleton, createNewSRSCard, gradeCard, isDue, getNextReviewText"
      exports: ["createNewSRSCard", "gradeCard", "isDue", "getNextReviewText"]
    - path: "src/lib/srs/srsStore.ts"
      provides: "IndexedDB CRUD for SRS cards via idb-keyval"
      exports: ["getSRSCard", "setSRSCard", "removeSRSCard", "getAllSRSCards"]
    - path: "src/lib/srs/index.ts"
      provides: "Barrel re-exports for all SRS module"
  key_links:
    - from: "src/lib/srs/fsrsEngine.ts"
      to: "ts-fsrs"
      via: "import { createEmptyCard, fsrs, Rating }"
      pattern: "import.*from 'ts-fsrs'"
    - from: "src/lib/srs/srsStore.ts"
      to: "idb-keyval"
      via: "createStore for dedicated SRS IndexedDB"
      pattern: "createStore\\('civic-prep-srs'"
---

<objective>
Create the FSRS algorithm engine wrapper and IndexedDB persistence layer for SRS cards.

Purpose: This is the data foundation for all spaced repetition features. The FSRS engine handles scheduling math, and the IndexedDB store provides offline-first persistence.
Output: `src/lib/srs/` module with types, FSRS engine, and IndexedDB CRUD operations.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-spaced-repetition/05-RESEARCH.md
@src/lib/mastery/masteryStore.ts
@src/lib/mastery/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ts-fsrs and create SRS types + FSRS engine wrapper</name>
  <files>
    src/lib/srs/srsTypes.ts
    src/lib/srs/fsrsEngine.ts
  </files>
  <action>
    1. Install ts-fsrs: `pnpm add ts-fsrs`

    2. Create `src/lib/srs/srsTypes.ts` with:
       - `SRSCardRecord` interface: `{ questionId: string; card: Card; addedAt: string; lastReviewedAt?: string }` where Card is from ts-fsrs
       - `SupabaseSRSRow` type matching the Supabase table schema (see RESEARCH.md Pattern 3): `{ id?: string; user_id: string; question_id: string; due: string; stability: number; difficulty: number; scheduled_days: number; learning_steps: number; reps: number; lapses: number; state: number; last_review: string | null; added_at: string; updated_at: string }`
       - `cardToRow(userId: string, questionId: string, record: SRSCardRecord): SupabaseSRSRow` -- serializes Card dates to ISO strings
       - `rowToCard(row: SupabaseSRSRow): SRSCardRecord` -- deserializes ISO strings back to Date objects for FSRS Card. CRITICAL: `card.due` and `card.last_review` must be `new Date()` objects, not strings. Set `elapsed_days: 0` (deprecated field, required for type compat).
       - `ReviewResult` type: `{ questionId: string; rating: 'easy' | 'hard'; newInterval: string }`
       - `SessionPhase` type: `'setup' | 'reviewing' | 'summary'`

    3. Create `src/lib/srs/fsrsEngine.ts` with:
       - Module-level FSRS singleton: `const f = fsrs({ enable_fuzz: true, enable_short_term: true, maximum_interval: 365 })`
       - `createNewSRSCard(): Card` -- wraps `createEmptyCard(new Date())`
       - `gradeCard(card: Card, isEasy: boolean): RecordLogItem` -- maps Easy to `Rating.Good`, Hard to `Rating.Again` (per user decision: CRITICAL - do NOT use Rating.Hard, it means successful-but-difficult in FSRS)
       - `isDue(card: Card): boolean` -- returns `card.due <= new Date()`
       - `getNextReviewText(card: Card): { en: string; my: string }` -- bilingual next review interval text. Logic: diffDays <= 0 = "Now"/"ယခု", 1 = "1 day"/"၁ ရက်", < 7 = "X days"/"X ရက်", < 30 = "X weeks"/"X ပတ်", else "X months"/"X လ". Use Burmese numerals for my text.
       - `getCardStatusLabel(card: Card): { label: string; labelMy: string; color: string }` -- New (blue-500), Due (warning-500), Done (success-500) per research Pattern: Card State to UI Label Mapping
       - `getIntervalStrengthColor(card: Card): string` -- returns Tailwind bg class based on scheduled_days: <=1 = 'bg-red-500', <=7 = 'bg-orange-500', <=30 = 'bg-yellow-500', else 'bg-green-500'

    IMPORTANT: Do NOT use `useMemo<T>()` generic syntax anywhere. Use `const x: T = useMemo(...)` pattern instead (React Compiler ESLint rule).
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes with no errors in srs files
    - Manually verify: `import { gradeCard, createNewSRSCard } from '@/lib/srs'` resolves
  </verify>
  <done>
    - ts-fsrs installed in package.json
    - FSRS engine creates cards, grades with binary rating (Easy->Good, Hard->Again), checks due status
    - Bilingual next-review text generation works
    - Card status labels and interval strength colors exported
    - All types properly defined with Card date serialization helpers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SRS IndexedDB store and barrel exports</name>
  <files>
    src/lib/srs/srsStore.ts
    src/lib/srs/index.ts
  </files>
  <action>
    1. Create `src/lib/srs/srsStore.ts` following the exact pattern from `src/lib/mastery/masteryStore.ts`:
       - Dedicated IDB store: `const srsDb = createStore('civic-prep-srs', 'cards')`
       - `getSRSCard(questionId: string): Promise<SRSCardRecord | undefined>` -- get single card by questionId
       - `setSRSCard(record: SRSCardRecord): Promise<void>` -- upsert card by questionId key
       - `removeSRSCard(questionId: string): Promise<void>` -- delete card from deck
       - `getAllSRSCards(): Promise<SRSCardRecord[]>` -- get all cards in deck. Iterate over keys, get each record, filter nulls. Same pattern as research example.
       - `getDueSRSCards(): Promise<SRSCardRecord[]>` -- convenience: getAllSRSCards filtered by `isDue(record.card)`. Import isDue from fsrsEngine.
       - `getSRSCardCount(): Promise<number>` -- return `(await keys(srsDb)).length` for quick count without loading all cards

    2. Create `src/lib/srs/index.ts` barrel file re-exporting everything:
       - `export * from './srsTypes'`
       - `export * from './fsrsEngine'`
       - `export * from './srsStore'`
       This follows the pattern from `src/lib/mastery/index.ts`.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - Imports like `import { getSRSCard, gradeCard, SRSCardRecord } from '@/lib/srs'` resolve correctly
  </verify>
  <done>
    - IndexedDB store with dedicated 'civic-prep-srs' database created
    - Full CRUD operations (get, set, remove, getAll, getDue, getCount) working
    - Barrel index re-exports all types, engine functions, and store functions
    - Pattern matches existing masteryStore.ts convention
  </done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes with zero errors
- All files in src/lib/srs/ exist and export correctly via barrel
- No React Compiler ESLint violations (no useMemo<T>() generics used)
</verification>

<success_criteria>
- ts-fsrs is installed and importable
- FSRS engine correctly maps Easy -> Rating.Good, Hard -> Rating.Again
- IndexedDB store provides offline-first SRS card persistence
- All types support Supabase row serialization/deserialization with proper Date handling
- Module follows existing project conventions (idb-keyval stores, barrel exports)
</success_criteria>

<output>
After completion, create `.planning/phases/05-spaced-repetition/05-01-SUMMARY.md`
</output>
