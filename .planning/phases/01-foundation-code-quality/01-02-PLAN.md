---
phase: 01-foundation-code-quality
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/shuffle.ts
  - src/__tests__/shuffle.test.ts
  - src/lib/saveSession.ts
  - src/__tests__/saveSession.test.ts
  - src/pages/TestPage.tsx
  - src/contexts/SupabaseAuthContext.tsx
autonomous: true

must_haves:
  truths:
    - "User takes multiple tests and sees uniform question distribution"
    - "User can submit a test once without duplicate records appearing"
    - "User navigating during test does not cause browser history overflow"
  artifacts:
    - path: "src/lib/shuffle.ts"
      provides: "Fisher-Yates shuffle algorithm"
      exports: ["fisherYatesShuffle"]
    - path: "src/__tests__/shuffle.test.ts"
      provides: "Statistical distribution test for shuffle"
      contains: "chi-squared"
    - path: "src/lib/saveSession.ts"
      provides: "Mutex-protected save operation"
      contains: "Mutex"
  key_links:
    - from: "src/pages/TestPage.tsx"
      to: "src/lib/shuffle.ts"
      via: "import fisherYatesShuffle"
      pattern: "fisherYatesShuffle"
    - from: "src/contexts/SupabaseAuthContext.tsx"
      to: "src/lib/saveSession.ts"
      via: "import mutex save"
      pattern: "saveMutex|withMutex"
---

<objective>
Fix three critical bugs using TDD: biased shuffle algorithm, race condition in test save, and history.pushState memory leak.

Purpose: These bugs directly impact user experience and data integrity. The shuffle bias affects test fairness, the race condition causes duplicate records, and the history leak degrades browser performance during long test sessions.

Output: Fisher-Yates shuffle with statistical regression tests, mutex-protected save operation, and fixed navigation prevention using replaceState.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-code-quality/01-RESEARCH.md
@.planning/phases/01-foundation-code-quality/01-01-SUMMARY.md
@src/pages/TestPage.tsx
@src/contexts/SupabaseAuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Fisher-Yates shuffle with statistical regression test</name>
  <files>src/lib/shuffle.ts, src/__tests__/shuffle.test.ts, src/pages/TestPage.tsx</files>
  <action>
**RED PHASE - Write failing test first:**

Create src/__tests__/shuffle.test.ts:

```typescript
import { describe, it, expect } from 'vitest';
import { fisherYatesShuffle } from '@/lib/shuffle';

describe('Fisher-Yates Shuffle', () => {
  it('returns array of same length', () => {
    const input = [1, 2, 3, 4, 5];
    const result = fisherYatesShuffle(input);
    expect(result).toHaveLength(input.length);
  });

  it('contains all original elements', () => {
    const input = [1, 2, 3, 4, 5];
    const result = fisherYatesShuffle(input);
    expect(result.sort()).toEqual(input.sort());
  });

  it('does not mutate original array', () => {
    const input = [1, 2, 3, 4, 5];
    const original = [...input];
    fisherYatesShuffle(input);
    expect(input).toEqual(original);
  });

  it('produces uniform distribution (chi-squared test)', () => {
    // Statistical test: Run 10,000 shuffles and verify each element
    // appears in each position with roughly equal frequency
    const input = [0, 1, 2, 3, 4];
    const iterations = 10000;
    const positionCounts: number[][] = input.map(() => new Array(input.length).fill(0));

    for (let i = 0; i < iterations; i++) {
      const shuffled = fisherYatesShuffle(input);
      shuffled.forEach((value, position) => {
        positionCounts[value][position]++;
      });
    }

    // Expected count per position = iterations / array length
    const expected = iterations / input.length;

    // Calculate chi-squared statistic
    let chiSquared = 0;
    for (const valueCounts of positionCounts) {
      for (const count of valueCounts) {
        chiSquared += Math.pow(count - expected, 2) / expected;
      }
    }

    // Chi-squared critical value for df=20, p=0.001 is ~45.3
    // We use a generous threshold of 50 to avoid flaky tests
    // A biased shuffle (like Math.random() - 0.5 sort) will produce values > 100
    expect(chiSquared).toBeLessThan(50);
  });

  it('handles empty array', () => {
    expect(fisherYatesShuffle([])).toEqual([]);
  });

  it('handles single element array', () => {
    expect(fisherYatesShuffle([42])).toEqual([42]);
  });

  it('works with objects', () => {
    const input = [{ id: 1 }, { id: 2 }, { id: 3 }];
    const result = fisherYatesShuffle(input);
    expect(result).toHaveLength(3);
    expect(result.map(x => x.id).sort()).toEqual([1, 2, 3]);
  });
});
```

Run `npm test -- --run shuffle` - tests should FAIL (module not found).

**GREEN PHASE - Implement Fisher-Yates:**

Create src/lib/shuffle.ts:

```typescript
/**
 * Fisher-Yates (Knuth) shuffle algorithm.
 * Produces uniformly distributed permutations.
 * Does not mutate the original array.
 *
 * @param array - The array to shuffle
 * @returns A new shuffled array
 */
export function fisherYatesShuffle<T>(array: readonly T[]): T[] {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
```

Run `npm test -- --run shuffle` - tests should PASS.

**WIRE UP - Update TestPage.tsx:**

Replace the biased shuffle function in src/pages/TestPage.tsx:

1. Remove the local `shuffle` function (lines 17-19)
2. Add import: `import { fisherYatesShuffle } from '@/lib/shuffle';`
3. Update useMemo to use `fisherYatesShuffle(civicsQuestions)` and `fisherYatesShuffle(question.answers)`
  </action>
  <verify>
Run `npm test -- --run shuffle` - all tests pass including chi-squared distribution test.
Run `npm run typecheck` - no type errors.
  </verify>
  <done>Fisher-Yates shuffle implemented with statistical regression test proving uniform distribution</done>
</task>

<task type="auto">
  <name>Task 2: TDD - Mutex-protected save operation to prevent race condition</name>
  <files>src/lib/saveSession.ts, src/__tests__/saveSession.test.ts, src/contexts/SupabaseAuthContext.tsx</files>
  <action>
**RED PHASE - Write failing test first:**

Create src/__tests__/saveSession.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createSaveSessionGuard, SaveState } from '@/lib/saveSession';

describe('Save Session Guard', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('starts in idle state', () => {
    const guard = createSaveSessionGuard();
    expect(guard.getState()).toBe('idle');
  });

  it('transitions through saving -> saved states on success', async () => {
    const guard = createSaveSessionGuard();
    const mockSave = vi.fn().mockResolvedValue({ id: '123' });

    const states: SaveState[] = [];
    guard.onStateChange(state => states.push(state));

    await guard.save(mockSave);

    expect(states).toContain('saving');
    expect(states).toContain('saved');
    expect(guard.getState()).toBe('saved');
  });

  it('transitions to error state on failure', async () => {
    const guard = createSaveSessionGuard();
    const mockSave = vi.fn().mockRejectedValue(new Error('Network error'));

    const states: SaveState[] = [];
    guard.onStateChange(state => states.push(state));

    await expect(guard.save(mockSave)).rejects.toThrow('Network error');

    expect(states).toContain('saving');
    expect(states).toContain('error');
    expect(guard.getState()).toBe('error');
  });

  it('prevents concurrent saves (mutex behavior)', async () => {
    const guard = createSaveSessionGuard();
    let callCount = 0;

    const slowSave = vi.fn().mockImplementation(async () => {
      callCount++;
      await new Promise(resolve => setTimeout(resolve, 50));
      return { id: `save-${callCount}` };
    });

    // Start two saves simultaneously
    const promise1 = guard.save(slowSave);
    const promise2 = guard.save(slowSave);

    await Promise.all([promise1, promise2]);

    // Only one actual save should have executed
    expect(slowSave).toHaveBeenCalledTimes(1);
  });

  it('allows save after previous save completes', async () => {
    const guard = createSaveSessionGuard();
    const mockSave = vi.fn().mockResolvedValue({ id: '123' });

    await guard.save(mockSave);
    guard.reset(); // Reset to allow another save

    await guard.save(mockSave);

    expect(mockSave).toHaveBeenCalledTimes(2);
  });

  it('can reset from error state', async () => {
    const guard = createSaveSessionGuard();
    const failingSave = vi.fn().mockRejectedValue(new Error('Fail'));
    const successSave = vi.fn().mockResolvedValue({ id: '123' });

    await expect(guard.save(failingSave)).rejects.toThrow();
    expect(guard.getState()).toBe('error');

    guard.reset();
    expect(guard.getState()).toBe('idle');

    await guard.save(successSave);
    expect(guard.getState()).toBe('saved');
  });
});
```

Run `npm test -- --run saveSession` - tests should FAIL.

**GREEN PHASE - Implement save guard:**

Create src/lib/saveSession.ts:

```typescript
import { Mutex } from 'async-mutex';

export type SaveState = 'idle' | 'saving' | 'saved' | 'error';

export interface SaveSessionGuard {
  getState: () => SaveState;
  save: <T>(operation: () => Promise<T>) => Promise<T>;
  reset: () => void;
  onStateChange: (callback: (state: SaveState) => void) => () => void;
}

/**
 * Creates a save session guard with mutex protection.
 * Prevents duplicate saves through state machine + mutex pattern.
 *
 * State machine:
 *   idle -> saving -> saved
 *                  -> error
 *   saved -> idle (via reset)
 *   error -> idle (via reset)
 */
export function createSaveSessionGuard(): SaveSessionGuard {
  const mutex = new Mutex();
  let state: SaveState = 'idle';
  const listeners = new Set<(state: SaveState) => void>();

  const setState = (newState: SaveState) => {
    state = newState;
    listeners.forEach(cb => cb(newState));
  };

  return {
    getState: () => state,

    save: async <T>(operation: () => Promise<T>): Promise<T> => {
      // If already saving or saved, skip
      if (state === 'saving' || state === 'saved') {
        return Promise.resolve(undefined as T);
      }

      const release = await mutex.acquire();
      try {
        // Double-check after acquiring mutex
        if (state === 'saving' || state === 'saved') {
          return Promise.resolve(undefined as T);
        }

        setState('saving');
        const result = await operation();
        setState('saved');
        return result;
      } catch (error) {
        setState('error');
        throw error;
      } finally {
        release();
      }
    },

    reset: () => {
      setState('idle');
    },

    onStateChange: (callback: (state: SaveState) => void) => {
      listeners.add(callback);
      return () => listeners.delete(callback);
    },
  };
}
```

Run `npm test -- --run saveSession` - tests should PASS.

**WIRE UP - Update SupabaseAuthContext.tsx:**

The existing `hasSavedSession` ref in TestPage.tsx provides some protection, but we need to ensure the context's `saveTestSession` also prevents duplicates:

1. Import at top of SupabaseAuthContext.tsx:
   `import { createSaveSessionGuard } from '@/lib/saveSession';`

2. Add a ref inside AuthProvider:
   `const saveGuardRef = useRef(createSaveSessionGuard());`

3. Wrap the saveTestSession implementation:
   ```typescript
   const saveTestSession = useCallback(
     async (session: Omit<TestSession, 'id'>) => {
       if (!user) {
         throw new Error('User must be signed in to save a mock test');
       }

       return saveGuardRef.current.save(async () => {
         // ... existing save logic ...
       });
     },
     [/* existing deps */]
   );
   ```

4. Export a method to reset the guard after save or on new test start if needed.

Note: The TestPage.tsx `hasSavedSession` state works at the component level. The mutex in SupabaseAuthContext ensures database-level protection against race conditions from effect re-runs.
  </action>
  <verify>
Run `npm test -- --run saveSession` - all tests pass.
Run `npm run typecheck` - no type errors.
  </verify>
  <done>Mutex-protected save operation prevents duplicate test submissions with state machine (idle/saving/saved/error)</done>
</task>

<task type="auto">
  <name>Task 3: Fix history.pushState memory leak in navigation lock</name>
  <files>src/pages/TestPage.tsx, src/__tests__/navigationLock.test.ts</files>
  <action>
**The Problem:**
Current code pushes a new history entry on EVERY popstate event, creating unbounded stack growth:
```typescript
const handlePopState = () => {
  window.history.pushState(null, '', window.location.href); // Called on every back button!
  toast({ ... });
};
```

**The Fix:**
Use `replaceState` instead of `pushState`, and only push once on mount:

Update the navigation lock useEffect in src/pages/TestPage.tsx:

```typescript
useEffect(() => {
  if (isFinished) return;

  // Push ONE entry when test starts - this is our "lock"
  window.history.pushState({ testLock: true }, '', window.location.href);

  const beforeUnload = (event: BeforeUnloadEvent) => {
    event.preventDefault();
    event.returnValue = '';
  };

  const handlePopState = (event: PopStateEvent) => {
    // User tried to navigate back - replace state to stay on page
    // Using replaceState instead of pushState prevents stack growth
    window.history.replaceState({ testLock: true }, '', window.location.href);

    toast({
      title: 'Please finish the mock test first!',
      description: lockMessage,
      variant: 'destructive',
    });

    // Push forward to restore navigation position
    window.history.pushState({ testLock: true }, '', window.location.href);
  };

  window.addEventListener('beforeunload', beforeUnload);
  window.addEventListener('popstate', handlePopState);

  return () => {
    window.removeEventListener('beforeunload', beforeUnload);
    window.removeEventListener('popstate', handlePopState);
  };
}, [isFinished, lockMessage]);
```

**Write regression test:**

Create src/__tests__/navigationLock.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

describe('Navigation Lock', () => {
  let pushStateSpy: ReturnType<typeof vi.spyOn>;
  let replaceStateSpy: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    pushStateSpy = vi.spyOn(window.history, 'pushState');
    replaceStateSpy = vi.spyOn(window.history, 'replaceState');
  });

  afterEach(() => {
    pushStateSpy.mockRestore();
    replaceStateSpy.mockRestore();
  });

  it('does not spam pushState on repeated popstate events', () => {
    // Simulate the fixed behavior
    const handlePopState = () => {
      window.history.replaceState({ testLock: true }, '', window.location.href);
      window.history.pushState({ testLock: true }, '', window.location.href);
    };

    // Simulate 10 back button presses
    for (let i = 0; i < 10; i++) {
      handlePopState();
    }

    // Each popstate should result in 1 replaceState + 1 pushState
    // Total: 10 replaceState + 10 pushState
    // The key is that we're not accumulating infinite stack entries
    expect(replaceStateSpy).toHaveBeenCalledTimes(10);
    expect(pushStateSpy).toHaveBeenCalledTimes(10);

    // Old buggy behavior would have been: 10 pushState calls
    // accumulating on top of existing stack
    // New behavior: replaceState cleans up, then pushState restores position
  });

  it('uses replaceState for navigation blocking, not just pushState', () => {
    const handlePopState = () => {
      window.history.replaceState({ testLock: true }, '', window.location.href);
      window.history.pushState({ testLock: true }, '', window.location.href);
    };

    handlePopState();

    // Verify replaceState is called (this was missing in the buggy version)
    expect(replaceStateSpy).toHaveBeenCalled();
  });
});
```

Run tests to verify the fix doesn't break navigation locking behavior.
  </action>
  <verify>
Run `npm test -- --run navigationLock` - all tests pass.
Run `npm run typecheck` - no type errors.
Manual verification: Start a test, press back button 10+ times rapidly, verify browser doesn't slow down or crash.
  </verify>
  <done>Navigation lock uses replaceState to prevent history stack overflow, with regression test</done>
</task>

</tasks>

<verification>
1. `npm test -- --run shuffle` - statistical chi-squared test passes
2. `npm test -- --run saveSession` - mutex prevents concurrent saves
3. `npm test -- --run navigationLock` - replaceState pattern verified
4. `npm run typecheck` - all files pass type checking
5. Manual test: Take 2 tests, verify no duplicate records in history
</verification>

<success_criteria>
- Fisher-Yates shuffle passes chi-squared distribution test (< 50 statistic)
- Save guard prevents duplicate submissions (mutex + state machine)
- Navigation lock uses replaceState, not pushState spam
- All three bug fixes have regression tests
- Requirements FNDN-01, FNDN-02, FNDN-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-code-quality/01-02-SUMMARY.md`
</output>
