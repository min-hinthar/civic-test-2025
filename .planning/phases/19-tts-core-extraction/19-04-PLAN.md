---
phase: 19-tts-core-extraction
plan: 04
type: execute
wave: 3
depends_on: ["19-03"]
files_modified:
  - src/components/ui/SpeechButton.tsx
autonomous: true

must_haves:
  truths:
    - "SpeechButton uses useTTS() hook instead of useSpeechSynthesis"
    - "SpeechButton shows animated visual feedback when isSpeaking is true (SVG sound waves + expanding rings + color shift)"
    - "SpeechButton has full ARIA: aria-pressed toggle, dynamic aria-label ('Listen'/'Stop'), aria-live announcements"
    - "SpeechButton keeps all current props backward-compatible (text, label, lang, pitch, rate, voiceName, className, stopPropagation)"
    - "SpeechButton reflects global engine state (shows active whenever ANY speech is happening)"
  artifacts:
    - path: "src/components/ui/SpeechButton.tsx"
      provides: "Migrated SpeechButton with animation and ARIA"
      exports: ["SpeechButton"]
  key_links:
    - from: "src/components/ui/SpeechButton.tsx"
      to: "src/hooks/useTTS.ts"
      via: "useTTS() hook for speech and state"
      pattern: "useTTS"
    - from: "src/components/ui/SpeechButton.tsx"
      to: "motion/react"
      via: "SVG sound wave animation"
      pattern: "motion\\.rect|motion\\.circle"
---

<objective>
Migrate SpeechButton from useSpeechSynthesis to useTTS and add rich animated visual feedback for the speaking state including SVG sound waves, expanding rings, pulsing border, and dedicated TTS color.

Purpose: SpeechButton is the most visible TTS consumer. The animation makes it obvious when speech is active across the app. Full ARIA support ensures accessibility. Backward-compatible props prevent breaking the 6 existing consumer components.

Output: Fully migrated `src/components/ui/SpeechButton.tsx` with speaking animation and ARIA attributes.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-RESEARCH.md
@.planning/phases/19-tts-core-extraction/19-03-SUMMARY.md
@src/components/ui/SpeechButton.tsx
@src/hooks/useTTS.ts
@src/lib/ttsTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate SpeechButton to useTTS with speaking toggle and ARIA</name>
  <files>src/components/ui/SpeechButton.tsx</files>
  <action>
Rewrite SpeechButton to use the new `useTTS()` hook while keeping all existing props backward-compatible.

**Props interface (keep ALL current props, same names):**
```ts
interface SpeechButtonProps {
  text: string;
  label: string;
  ariaLabel?: string;
  lang?: string;
  pitch?: number;
  rate?: number;
  voiceName?: string;     // maps to preferredVoiceName in speak options
  className?: string;
  stopPropagation?: boolean;
}
```

**Hook usage:**
```ts
const { speak, cancel, isSpeaking, isSupported } = useTTS();
```

**Click handler:**
- If `isSpeaking`: call `cancel()` (toggle behavior -- clicking while speaking stops it).
- If not speaking: call `speak(text, { lang, pitch, rate, voice: /* use voiceName */ })`. Props become per-call overrides. Do NOT await the promise (fire-and-forget for button click).
- If `stopPropagation`: call `event.stopPropagation()`.

**Focus management (per locked decision):**
- Use a `useRef<HTMLButtonElement>` for the button.
- When `isSpeaking` transitions from false to true, call `buttonRef.current?.focus()`. Use a `useEffect` watching `isSpeaking` to detect transition. Be careful with React Compiler: do NOT access ref.current during render.

**ARIA attributes (per locked decision):**
- `aria-pressed={isSpeaking}` -- toggle button semantics
- `aria-label`: Dynamic -- when speaking: `'Stop speaking'`, when not: `ariaLabel ?? label`
- Add a visually hidden `<span role="status" aria-live="polite">` that announces state changes: "Speaking" when starts, "Stopped" when ends. Use `isSpeaking` to control content.

**Button structure:**
```tsx
<button
  ref={buttonRef}
  type="button"
  aria-pressed={isSpeaking}
  aria-label={isSpeaking ? 'Stop speaking' : (ariaLabel ?? label)}
  onClick={handleClick}
  disabled={!isSupported || !text?.trim()}
  className={clsx(
    // Base styles (keep current)
    'inline-flex items-center gap-2 rounded-full border px-4 py-2 text-xs font-semibold shadow-sm transition min-h-[44px]',
    // Speaking state: dedicated TTS color + pulsing border (CSS)
    isSpeaking
      ? 'border-tts bg-tts/10 text-tts animate-pulse-subtle'
      : 'border-border bg-card/80 text-foreground hover:-translate-y-0.5 hover:border-primary hover:text-primary',
    // Disabled
    'disabled:cursor-not-allowed disabled:opacity-60',
    className
  )}
>
  {/* Icon: sound wave SVG when speaking, Volume2 when idle */}
  {isSpeaking ? <SoundWaveIcon /> : <Volume2 className="h-4 w-4" aria-hidden="true" />}
  <span>{label}</span>
  {/* Expanding rings (only when speaking) */}
  {isSpeaking && <ExpandingRings />}
  {/* ARIA live region */}
  <span className="sr-only" role="status" aria-live="polite">
    {isSpeaking ? 'Speaking' : ''}
  </span>
</button>
```

**Dedicated TTS color:** Add CSS custom properties in Tailwind (or inline) for the TTS speaking color. Use a vibrant blue-purple that works in both light and dark modes. Define as Tailwind extend color or use inline style. Claude has discretion on exact values -- suggested:
- Light mode: `hsl(250, 70%, 55%)` (vibrant indigo-purple)
- Dark mode: `hsl(250, 80%, 70%)` (lighter indigo for dark backgrounds)

Add to `globals.css` or the component:
```css
:root { --color-tts: 250 70% 55%; }
.dark { --color-tts: 250 80% 70%; }
```
And extend Tailwind if needed, or use `text-[hsl(var(--color-tts))]` utility. Keep it simple.

Add a subtle pulse animation for the speaking state border:
```css
@keyframes pulse-subtle {
  0%, 100% { border-color: hsl(var(--color-tts)); }
  50% { border-color: hsl(var(--color-tts) / 0.5); }
}
.animate-pulse-subtle { animation: pulse-subtle 2s ease-in-out infinite; }
```

**Export:** Keep as default export for backward compatibility with all 6 consumer files.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run lint`. Verify SpeechButton still has default export. Verify no changes needed in consumer files (TestPage, StudyGuidePage, PracticeSession, PracticeResults, HistoryTab, Flashcard3D) -- they all import `SpeechButton` default.</verify>
  <done>SpeechButton uses useTTS(), has click-to-toggle behavior, all ARIA attributes, focus management, and base speaking state styles. All current props preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Add rich speaking animation (SVG sound waves + expanding rings)</name>
  <files>src/components/ui/SpeechButton.tsx</files>
  <action>
Add the animated sub-components to SpeechButton. These are defined as private components within the same file (not exported).

**SoundWaveIcon component (motion/react SVG):**
Animated equalizer-bar pattern (3 rects) per research Example 5:
```tsx
import { motion } from 'motion/react';

function SoundWaveIcon() {
  const bars = [
    { delay: 0, heights: { idle: 4, active: 12 } },
    { delay: 0.1, heights: { idle: 8, active: 16 } },
    { delay: 0.2, heights: { idle: 4, active: 10 } },
  ];

  return (
    <svg width="16" height="16" viewBox="0 0 16 16" aria-hidden="true" className="h-4 w-4">
      {bars.map((bar, i) => (
        <motion.rect
          key={i}
          x={2 + i * 5}
          width={3}
          rx={1.5}
          fill="currentColor"
          animate={{
            height: [bar.heights.idle, bar.heights.active, bar.heights.idle],
            y: [8 - bar.heights.idle / 2, 8 - bar.heights.active / 2, 8 - bar.heights.idle / 2],
          }}
          transition={{
            repeat: Infinity,
            duration: 0.6,
            delay: bar.delay,
            ease: 'easeInOut',
          }}
        />
      ))}
    </svg>
  );
}
```

**ExpandingRings component (motion/react):**
Concentric circles that expand and fade out from the button, creating a "broadcasting" effect:
```tsx
function ExpandingRings() {
  return (
    <span className="pointer-events-none absolute inset-0 flex items-center justify-center" aria-hidden="true">
      {[0, 1, 2].map(i => (
        <motion.span
          key={i}
          className="absolute rounded-full border border-tts/40"
          initial={{ width: '100%', height: '100%', opacity: 0.6 }}
          animate={{
            width: ['100%', '180%'],
            height: ['100%', '180%'],
            opacity: [0.4, 0],
          }}
          transition={{
            repeat: Infinity,
            duration: 2,
            delay: i * 0.6,
            ease: 'easeOut',
          }}
        />
      ))}
    </span>
  );
}
```

**Button container update:**
The button needs `relative overflow-visible` for the expanding rings to render outside the button bounds. Add these to the className.

**Reduced motion support:**
Import `useReducedMotion` from `@/hooks/useReducedMotion`. When reduced motion is preferred:
- SoundWaveIcon: render static bars (no animation) -- just use the idle heights.
- ExpandingRings: don't render at all.
- Pulse border animation: use `animation: none` override.

The SoundWaveIcon should accept an `animate` boolean prop. When false, render plain SVG rects without motion.

**Performance:** motion/react handles animation cleanup automatically. No manual cleanup needed. The `key` prop on motion elements ensures proper lifecycle.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run lint`. Run `npm run build` to verify no build errors. Verify the component handles reduced motion preference.</verify>
  <done>SpeechButton has full rich animation: animated SVG sound waves, expanding concentric rings, pulsing TTS-colored border, all with reduced-motion fallbacks. Component compiles and builds cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run lint` passes
3. `npm run build` succeeds
4. SpeechButton default export preserved -- no changes needed in 6 consumer files
5. All current props still work (text, label, ariaLabel, lang, pitch, rate, voiceName, className, stopPropagation)
6. ARIA: aria-pressed, dynamic aria-label, aria-live region present
7. Animation: SVG sound waves + expanding rings + color shift when isSpeaking
8. Reduced motion: animations disabled gracefully
</verification>

<success_criteria>
- SpeechButton migrated from useSpeechSynthesis to useTTS()
- Click toggles between speak and cancel (was fire-only before)
- Full ARIA with aria-pressed, dynamic aria-label, aria-live announcements
- Rich animation: SVG equalizer bars, expanding rings, TTS color, pulsing border
- Reduced motion: static icon, no rings, no pulse
- Backward compatible: all 6 consumer files require zero changes
- Focus management: button focused when speaking begins
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-04-SUMMARY.md`
</output>
