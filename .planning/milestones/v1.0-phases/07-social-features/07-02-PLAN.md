---
phase: 07-social-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
autonomous: true

must_haves:
  truths:
    - "Social profiles table stores display name, opt-in status, and composite score"
    - "Streak data table allows cross-device streak sync for authenticated users"
    - "Earned badges table tracks per-user badge achievements"
    - "Leaderboard RPC returns top 25 opted-in users ranked by composite score"
    - "Unauthenticated users can read opted-in social profiles (public leaderboard)"
    - "Only profile owners can write their own social data"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "Social tables, RLS policies, and leaderboard RPC function"
      contains: "social_profiles"
  key_links:
    - from: "social_profiles"
      to: "profiles"
      via: "foreign key user_id"
      pattern: "references public.profiles"
    - from: "get_leaderboard RPC"
      to: "social_profiles"
      via: "server-side ranking query"
      pattern: "SECURITY DEFINER"
---

<objective>
Extend the Supabase schema with social feature tables: social_profiles (leaderboard identity + opt-in), streak_data (cross-device sync), earned_badges (achievements), plus the leaderboard RPC function.

Purpose: Database foundation required by streak sync (Plan 06), leaderboard display (Plan 07), and social opt-in flow (Plan 06). Running in Wave 1 allows all sync/leaderboard plans to proceed in parallel in Wave 2.
Output: Updated supabase/schema.sql with 3 new tables, RLS policies, indexes, and 1 RPC function.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-social-features/07-RESEARCH.md
@supabase/schema.sql (existing schema to extend)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Social tables with RLS policies</name>
  <files>supabase/schema.sql</files>
  <action>
    Append to `supabase/schema.sql` (after the interview_sessions section) the following tables with idempotent DDL (matching existing pattern of `CREATE TABLE IF NOT EXISTS` and `DROP POLICY IF EXISTS ... CREATE POLICY`):

    **1. social_profiles table:**
    ```sql
    CREATE TABLE IF NOT EXISTS public.social_profiles (
      user_id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
      display_name text NOT NULL,
      social_opt_in boolean NOT NULL DEFAULT false,
      composite_score numeric NOT NULL DEFAULT 0,
      current_streak int NOT NULL DEFAULT 0,
      longest_streak int NOT NULL DEFAULT 0,
      top_badge text,
      is_weekly_winner boolean NOT NULL DEFAULT false,
      weekly_score_updated_at timestamptz,
      created_at timestamptz NOT NULL DEFAULT now(),
      updated_at timestamptz NOT NULL DEFAULT now()
    );
    ```

    RLS policies (4 policies):
    - `"Anyone can view opted-in social profiles"` — SELECT, USING (social_opt_in = true). This enables unauthenticated leaderboard viewing.
    - `"Users can view own social profile"` — SELECT, USING (auth.uid() = user_id). Owner can always see their profile regardless of opt-in.
    - `"Users can upsert own social profile"` — INSERT, WITH CHECK (auth.uid() = user_id).
    - `"Users can update own social profile"` — UPDATE, USING (auth.uid() = user_id).

    **2. streak_data table:**
    ```sql
    CREATE TABLE IF NOT EXISTS public.streak_data (
      user_id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
      activity_dates text[] NOT NULL DEFAULT '{}',
      freezes_available int NOT NULL DEFAULT 0,
      freezes_used text[] NOT NULL DEFAULT '{}',
      longest_streak int NOT NULL DEFAULT 0,
      updated_at timestamptz NOT NULL DEFAULT now()
    );
    ```

    RLS policies (2 policies):
    - `"Users can manage own streak data"` — ALL (select, update, delete), USING (auth.uid() = user_id).
    - `"Users can insert own streak data"` — INSERT, WITH CHECK (auth.uid() = user_id).

    **3. earned_badges table:**
    ```sql
    CREATE TABLE IF NOT EXISTS public.earned_badges (
      id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
      badge_id text NOT NULL,
      earned_at timestamptz NOT NULL DEFAULT now(),
      UNIQUE (user_id, badge_id)
    );
    ```

    RLS policies (3 policies):
    - `"Anyone can view opted-in users badges"` — SELECT, USING (EXISTS (SELECT 1 FROM public.social_profiles sp WHERE sp.user_id = earned_badges.user_id AND sp.social_opt_in = true)). Enables badge display on leaderboard profiles.
    - `"Users can manage own badges"` — SELECT/UPDATE/DELETE, USING (auth.uid() = user_id).
    - `"Users can insert own badges"` — INSERT, WITH CHECK (auth.uid() = user_id).

    Add indexes:
    - `CREATE INDEX IF NOT EXISTS social_profiles_score_idx ON public.social_profiles (composite_score DESC) WHERE social_opt_in = true;`
    - `CREATE INDEX IF NOT EXISTS earned_badges_user_idx ON public.earned_badges (user_id);`
  </action>
  <verify>SQL syntax is valid (no syntax errors in the appended statements). All `CREATE TABLE IF NOT EXISTS` and `DROP POLICY IF EXISTS` patterns match existing schema conventions.</verify>
  <done>Three social tables exist in schema.sql with proper RLS: public read for opted-in profiles/badges, owner-only write for all tables.</done>
</task>

<task type="auto">
  <name>Task 2: Leaderboard RPC function</name>
  <files>supabase/schema.sql</files>
  <action>
    Append the leaderboard RPC function after the social tables section:

    ```sql
    -- Leaderboard ranking function (server-side for security)
    CREATE OR REPLACE FUNCTION public.get_leaderboard(
      board_type text DEFAULT 'all-time',
      result_limit int DEFAULT 25
    )
    RETURNS TABLE (
      rank bigint,
      user_id uuid,
      display_name text,
      composite_score numeric,
      current_streak int,
      top_badge text,
      is_weekly_winner boolean
    )
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
    AS $$
    BEGIN
      RETURN QUERY
      SELECT
        row_number() OVER (ORDER BY sp.composite_score DESC)::bigint AS rank,
        sp.user_id,
        sp.display_name,
        sp.composite_score,
        sp.current_streak,
        sp.top_badge,
        sp.is_weekly_winner
      FROM social_profiles sp
      WHERE sp.social_opt_in = true
        AND (board_type = 'all-time' OR sp.weekly_score_updated_at >= date_trunc('week', now()))
      ORDER BY sp.composite_score DESC
      LIMIT result_limit;
    END;
    $$;
    ```

    Also add a function to get a user's own rank:

    ```sql
    CREATE OR REPLACE FUNCTION public.get_user_rank(target_user_id uuid)
    RETURNS bigint
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
    AS $$
    DECLARE
      user_rank bigint;
    BEGIN
      SELECT r.rank INTO user_rank
      FROM (
        SELECT sp.user_id, row_number() OVER (ORDER BY sp.composite_score DESC) AS rank
        FROM social_profiles sp
        WHERE sp.social_opt_in = true
      ) r
      WHERE r.user_id = target_user_id;
      RETURN user_rank;
    END;
    $$;
    ```

    Grant execution to authenticated and anon roles:
    ```sql
    GRANT EXECUTE ON FUNCTION public.get_leaderboard TO authenticated, anon;
    GRANT EXECUTE ON FUNCTION public.get_user_rank TO authenticated;
    ```
  </action>
  <verify>SQL is syntactically valid. Functions use SECURITY DEFINER (bypasses RLS for server-side ranking). GRANT statements allow both authenticated and anon users to call get_leaderboard.</verify>
  <done>Leaderboard RPC returns top N users ranked by composite score with all-time and weekly filtering. User rank function returns authenticated user's position. Both functions accessible via `supabase.rpc()`.</done>
</task>

</tasks>

<verification>
1. schema.sql has 3 new tables: social_profiles, streak_data, earned_badges
2. All tables have RLS enabled with appropriate policies
3. Public SELECT on social_profiles has `USING (social_opt_in = true)` (not `USING (true)`)
4. get_leaderboard function supports 'all-time' and 'weekly' board types
5. GRANT statements allow anon to call get_leaderboard (public leaderboard viewing)
6. All DDL is idempotent (IF NOT EXISTS, CREATE OR REPLACE, DROP POLICY IF EXISTS)
</verification>

<success_criteria>
- Social profiles table supports leaderboard identity with opt-in control
- Streak data table enables cross-device streak sync
- Earned badges table tracks achievements per user
- RLS prevents unauthorized writes while allowing public leaderboard reads
- RPC function computes rankings server-side (no client-side score exposure)
- Schema follows existing conventions (idempotent DDL, consistent naming)
</success_criteria>

<output>
After completion, create `.planning/phases/07-social-features/07-02-SUMMARY.md`
</output>
