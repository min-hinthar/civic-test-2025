---
phase: 02-pwa-offline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/pwa/offlineDb.ts
  - src/hooks/useOnlineStatus.ts
  - src/components/pwa/OnlineStatusIndicator.tsx
  - src/components/AppNavigation.tsx
  - src/contexts/OfflineContext.tsx
autonomous: true

must_haves:
  truths:
    - "User sees green dot in header when online"
    - "User sees orange dot in header when offline"
    - "Questions are cached in IndexedDB on first load"
    - "Cached questions load instantly on subsequent visits"
  artifacts:
    - path: "src/lib/pwa/offlineDb.ts"
      provides: "IndexedDB operations for questions and sync queue"
      exports: ["cacheQuestions", "getCachedQuestions"]
    - path: "src/hooks/useOnlineStatus.ts"
      provides: "React hook for online/offline detection"
      exports: ["useOnlineStatus"]
    - path: "src/components/pwa/OnlineStatusIndicator.tsx"
      provides: "Header status badge component"
      exports: ["OnlineStatusIndicator"]
    - path: "src/contexts/OfflineContext.tsx"
      provides: "Context for offline state and cached data"
      exports: ["OfflineProvider", "useOffline"]
  key_links:
    - from: "src/components/pwa/OnlineStatusIndicator.tsx"
      to: "src/hooks/useOnlineStatus.ts"
      via: "hook import"
      pattern: "useOnlineStatus"
    - from: "src/contexts/OfflineContext.tsx"
      to: "src/lib/pwa/offlineDb.ts"
      via: "function import"
      pattern: "getCachedQuestions|cacheQuestions"
---

<objective>
Implement IndexedDB question caching and online/offline status indicator.

Purpose: Users need to know their connection status (per user decision: green dot = online, orange dot = offline) and questions must be cached for offline study.
Output: All 100+ questions cached in IndexedDB, visible online/offline indicator in header.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pwa-offline/02-RESEARCH.md
@.planning/phases/02-pwa-offline/02-01-SUMMARY.md

@src/constants/civicsQuestions.ts
@src/components/AppNavigation.tsx
@src/AppShell.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexedDB wrapper and online status hook</name>
  <files>
    src/lib/pwa/offlineDb.ts
    src/hooks/useOnlineStatus.ts
  </files>
  <action>
1. Create src/lib/pwa/offlineDb.ts using idb-keyval:
   ```typescript
   import { get, set, del, keys, createStore } from "idb-keyval";
   import type { Question } from "@/types";

   // Separate stores for different data types
   const questionsStore = createStore("civic-prep-questions", "questions");
   const syncQueueStore = createStore("civic-prep-sync", "pending-results");

   // Cache all questions on first load
   export async function cacheQuestions(questions: Question[]): Promise<void> {
     await set("all-questions", questions, questionsStore);
     await set("cached-at", Date.now(), questionsStore);
   }

   // Get cached questions (returns undefined if not cached)
   export async function getCachedQuestions(): Promise<Question[] | undefined> {
     return get("all-questions", questionsStore);
   }

   // Check if questions are cached
   export async function hasQuestionsCache(): Promise<boolean> {
     const cachedAt = await get("cached-at", questionsStore);
     return cachedAt !== undefined;
   }

   // Export sync queue store for later plans
   export { syncQueueStore };
   ```

2. Create src/hooks/useOnlineStatus.ts using useSyncExternalStore:
   ```typescript
   import { useSyncExternalStore } from "react";

   function subscribe(callback: () => void): () => void {
     window.addEventListener("online", callback);
     window.addEventListener("offline", callback);
     return () => {
       window.removeEventListener("online", callback);
       window.removeEventListener("offline", callback);
     };
   }

   function getSnapshot(): boolean {
     return navigator.onLine;
   }

   function getServerSnapshot(): boolean {
     return true; // Assume online during SSR
   }

   export function useOnlineStatus(): boolean {
     return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
   }
   ```
  </action>
  <verify>
    pnpm run typecheck passes
    pnpm run lint passes
  </verify>
  <done>
    offlineDb.ts exports caching functions, useOnlineStatus hook uses useSyncExternalStore correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OfflineContext and OnlineStatusIndicator</name>
  <files>
    src/contexts/OfflineContext.tsx
    src/components/pwa/OnlineStatusIndicator.tsx
  </files>
  <action>
1. Create src/contexts/OfflineContext.tsx:
   ```typescript
   import React, { createContext, useContext, useEffect, useState, useCallback } from "react";
   import { cacheQuestions, getCachedQuestions, hasQuestionsCache } from "@/lib/pwa/offlineDb";
   import { civicsQuestions } from "@/constants/civicsQuestions";
   import type { Question } from "@/types";

   interface OfflineContextValue {
     questions: Question[];
     isQuestionsLoaded: boolean;
     isCached: boolean;
     pendingSyncCount: number;
     refreshCache: () => Promise<void>;
   }

   const OfflineContext = createContext<OfflineContextValue | undefined>(undefined);

   export function OfflineProvider({ children }: { children: React.ReactNode }) {
     const [questions, setQuestions] = useState<Question[]>(civicsQuestions);
     const [isQuestionsLoaded, setIsQuestionsLoaded] = useState(false);
     const [isCached, setIsCached] = useState(false);
     const [pendingSyncCount, setPendingSyncCount] = useState(0);

     // Load questions from cache or cache them
     useEffect(() => {
       async function initQuestions() {
         try {
           const hasCached = await hasQuestionsCache();
           if (hasCached) {
             const cached = await getCachedQuestions();
             if (cached) {
               setQuestions(cached);
               setIsCached(true);
             }
           } else {
             // First visit - cache questions
             await cacheQuestions(civicsQuestions);
             setIsCached(true);
           }
         } catch (error) {
           console.error("Failed to initialize offline questions:", error);
           // Fallback to in-memory questions
         }
         setIsQuestionsLoaded(true);
       }

       initQuestions();
     }, []);

     const refreshCache = useCallback(async () => {
       await cacheQuestions(civicsQuestions);
       setIsCached(true);
     }, []);

     return (
       <OfflineContext.Provider
         value={{
           questions,
           isQuestionsLoaded,
           isCached,
           pendingSyncCount,
           refreshCache,
         }}
       >
         {children}
       </OfflineContext.Provider>
     );
   }

   export function useOffline(): OfflineContextValue {
     const context = useContext(OfflineContext);
     if (!context) {
       throw new Error("useOffline must be used within OfflineProvider");
     }
     return context;
   }
   ```

2. Create src/components/pwa/ directory.

3. Create src/components/pwa/OnlineStatusIndicator.tsx:
   ```typescript
   import React from "react";
   import { useOnlineStatus } from "@/hooks/useOnlineStatus";

   export function OnlineStatusIndicator() {
     const isOnline = useOnlineStatus();

     return (
       <div
         className="relative flex items-center justify-center"
         title={isOnline ? "Online" : "Offline"}
         aria-label={isOnline ? "Online" : "Offline"}
       >
         {/* Status dot */}
         <span
           className={`h-2.5 w-2.5 rounded-full ${
             isOnline ? "bg-green-500" : "bg-orange-500"
           }`}
           aria-hidden="true"
         />
       </div>
     );
   }
   ```

Per user decision: icon-only (no text label), green dot = online, orange dot = offline.
  </action>
  <verify>
    pnpm run typecheck passes
    pnpm run lint passes
  </verify>
  <done>
    OfflineContext caches questions on mount, OnlineStatusIndicator shows colored dot
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into AppShell and AppNavigation</name>
  <files>
    src/AppShell.tsx
    src/components/AppNavigation.tsx
  </files>
  <action>
1. Modify src/AppShell.tsx to wrap app with OfflineProvider:
   - Import OfflineProvider from "@/contexts/OfflineContext"
   - Add OfflineProvider as outer wrapper (outside ThemeProvider and AuthProvider)
   - Order: OfflineProvider > ThemeProvider > AuthProvider > Router

2. Modify src/components/AppNavigation.tsx to include OnlineStatusIndicator:
   - Import OnlineStatusIndicator from "@/components/pwa/OnlineStatusIndicator"
   - Add OnlineStatusIndicator to the header, positioned in the right side near other controls
   - Place it before the theme toggle or user menu (visible but not prominent)
   - The indicator should be visible on all screen sizes
  </action>
  <verify>
    pnpm run build succeeds
    pnpm run dev shows indicator in header
    Toggling network in DevTools changes dot color
  </verify>
  <done>
    OfflineProvider wraps app, OnlineStatusIndicator visible in header, color changes with network status
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm run build` and `pnpm start`
2. Open app in browser, check header for status dot (should be green when online)
3. Open DevTools > Application > IndexedDB - should see "civic-prep-questions" database
4. Toggle DevTools Network to "Offline" - dot should turn orange
5. Refresh page while offline - questions should still display (from cache)
6. Check console for any errors
</verification>

<success_criteria>
- IndexedDB stores questions under "civic-prep-questions" database
- Questions load from cache on subsequent visits (no network request for questions)
- Online status indicator shows green dot when online
- Online status indicator shows orange dot when offline (test via DevTools)
- No TypeScript or lint errors
- Status indicator is visible but unobtrusive in header
</success_criteria>

<output>
After completion, create `.planning/phases/02-pwa-offline/02-02-SUMMARY.md`
</output>
