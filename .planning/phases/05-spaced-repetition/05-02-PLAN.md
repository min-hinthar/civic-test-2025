---
phase: 05-spaced-repetition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema.sql
  - src/lib/srs/srsSync.ts
autonomous: true

must_haves:
  truths:
    - "Supabase srs_cards table exists with RLS policies for per-user access"
    - "SRS card state can be pushed to and pulled from Supabase"
    - "Offline review events queue and sync when connectivity returns"
  artifacts:
    - path: "supabase/schema.sql"
      provides: "srs_cards table DDL with RLS, indexes"
      contains: "create table if not exists public.srs_cards"
    - path: "src/lib/srs/srsSync.ts"
      provides: "Supabase sync operations for SRS cards"
      exports: ["pushSRSCards", "pullSRSCards", "queueSRSReview", "syncPendingSRSReviews"]
  key_links:
    - from: "src/lib/srs/srsSync.ts"
      to: "supabase"
      via: "supabase.from('srs_cards')"
      pattern: "from\\('srs_cards'\\)"
    - from: "src/lib/srs/srsSync.ts"
      to: "idb-keyval"
      via: "dedicated sync queue store"
      pattern: "createStore\\('civic-prep-srs-sync'"
---

<objective>
Create the Supabase srs_cards table schema and the sync layer that connects IndexedDB to Supabase for cross-device SRS state.

Purpose: Enables SRS data persistence in the cloud for cross-device access, with offline queuing for reviews done without connectivity.
Output: Updated schema.sql with srs_cards table, and srsSync.ts for push/pull/queue operations.
</objective>

<execution_context>
@C:\Users\minkk\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\minkk\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-spaced-repetition/05-RESEARCH.md
@supabase/schema.sql
@src/lib/pwa/syncQueue.ts
@src/lib/pwa/offlineDb.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add srs_cards table to Supabase schema</name>
  <files>supabase/schema.sql</files>
  <action>
    Append to the end of `supabase/schema.sql` the srs_cards table DDL exactly as specified in RESEARCH.md Pattern 3:

    ```sql
    -- SRS (Spaced Repetition) card state per user per question
    create table if not exists public.srs_cards (
      id uuid primary key default gen_random_uuid(),
      user_id uuid not null references public.profiles (id) on delete cascade,
      question_id text not null,
      -- FSRS Card state fields
      due timestamptz not null default now(),
      stability float8 not null default 0,
      difficulty float8 not null default 0,
      scheduled_days integer not null default 0,
      learning_steps integer not null default 0,
      reps integer not null default 0,
      lapses integer not null default 0,
      state smallint not null default 0,  -- 0=New, 1=Learning, 2=Review, 3=Relearning
      last_review timestamptz,
      -- Metadata
      added_at timestamptz not null default now(),
      updated_at timestamptz not null default now(),
      -- Prevent duplicate cards per user
      unique (user_id, question_id)
    );

    alter table public.srs_cards enable row level security;

    create policy "Users can read their own SRS cards"
      on public.srs_cards for select using (auth.uid() = user_id);
    create policy "Users can insert their own SRS cards"
      on public.srs_cards for insert with check (auth.uid() = user_id);
    create policy "Users can update their own SRS cards"
      on public.srs_cards for update using (auth.uid() = user_id);
    create policy "Users can delete their own SRS cards"
      on public.srs_cards for delete using (auth.uid() = user_id);

    -- Index for due-card queries
    create index if not exists srs_cards_due_idx
      on public.srs_cards (user_id, due);
    create index if not exists srs_cards_question_idx
      on public.srs_cards (user_id, question_id);
    ```

    NOTE: This SQL is for documentation and manual Supabase dashboard execution. The app uses Supabase hosted -- there is no local migration runner. The executor should note this in the summary.
  </action>
  <verify>
    - The SQL appended to schema.sql parses without syntax errors
    - Table has unique(user_id, question_id) constraint
    - All 4 RLS policies (select, insert, update, delete) present
  </verify>
  <done>
    - srs_cards table DDL appended to supabase/schema.sql
    - RLS policies enforce per-user access
    - Indexes on (user_id, due) and (user_id, question_id) for efficient queries
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SRS sync layer with offline queue</name>
  <files>src/lib/srs/srsSync.ts</files>
  <action>
    Create `src/lib/srs/srsSync.ts` following the pattern from `src/lib/pwa/syncQueue.ts`:

    1. Import supabase client from `@/lib/supabaseClient`
    2. Import `createStore, get, set, del, keys` from `idb-keyval`
    3. Import types from `./srsTypes` (SRSCardRecord, SupabaseSRSRow, cardToRow, rowToCard)

    4. Create dedicated sync queue store: `const srsSyncDb = createStore('civic-prep-srs-sync', 'pending-reviews')`

    5. Define `PendingSRSSync` interface: `{ questionId: string; card: Card; reviewedAt: string; action: 'upsert' | 'delete' }`

    6. Implement functions:

    **queueSRSSync(sync: PendingSRSSync): Promise<void>**
    - Key: `srs-${sync.questionId}-${Date.now()}`
    - Store in srsSyncDb
    - This queues changes when offline or when user is not logged in

    **syncPendingSRSReviews(userId: string): Promise<{ synced: number; failed: number }>**
    - Get all keys from srsSyncDb
    - For each pending sync:
      - If action === 'upsert': use `supabase.from('srs_cards').upsert(cardToRow(...), { onConflict: 'user_id,question_id' })`
      - If action === 'delete': use `supabase.from('srs_cards').delete().eq('user_id', userId).eq('question_id', questionId)`
      - On success: delete from srsSyncDb
      - On error: log and continue (no retry in this pass -- will retry next sync)
    - Return counts

    **pushSRSCards(userId: string, cards: SRSCardRecord[]): Promise<void>**
    - Batch upsert all local cards to Supabase
    - Use `supabase.from('srs_cards').upsert(rows, { onConflict: 'user_id,question_id' })`
    - Handles initial sync when user first logs in

    **pullSRSCards(userId: string): Promise<SRSCardRecord[]>**
    - Fetch all SRS cards from Supabase for the user
    - `supabase.from('srs_cards').select('*').eq('user_id', userId)`
    - Convert rows to SRSCardRecord using rowToCard
    - Returns the remote deck for merging

    **mergeSRSDecks(local: SRSCardRecord[], remote: SRSCardRecord[]): SRSCardRecord[]**
    - Last-write-wins based on updated_at/lastReviewedAt (per user decision on conflict resolution)
    - For each questionId present in either deck:
      - If only in local: keep local
      - If only in remote: keep remote
      - If in both: keep whichever has a more recent lastReviewedAt (or addedAt if neither reviewed)
    - Returns merged deck

    IMPORTANT: Use the existing supabase client pattern from src/lib/supabaseClient.ts. Do NOT create a new client.
    Add srsSync exports to the barrel index.ts file (append `export * from './srsSync'`).
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - srsSync.ts imports resolve correctly
    - Barrel index re-exports sync functions
  </verify>
  <done>
    - Offline queue stores pending SRS reviews in dedicated IndexedDB store
    - Push/pull operations connect local IDB to Supabase srs_cards table
    - Last-write-wins merge resolves cross-device conflicts silently (per user decision)
    - Pattern follows existing syncQueue.ts convention
  </done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- supabase/schema.sql contains valid srs_cards DDL at the end
- srsSync.ts properly imports from supabaseClient and idb-keyval
- All sync functions exported via barrel index
</verification>

<success_criteria>
- Supabase srs_cards schema documented in schema.sql with RLS
- Sync layer supports: queue offline reviews, push local deck, pull remote deck, merge with last-write-wins
- Offline sync queue uses dedicated IndexedDB store separate from main SRS store
- Silent conflict resolution (no user-facing toast for conflicts, per user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/05-spaced-repetition/05-02-SUMMARY.md`
</output>
