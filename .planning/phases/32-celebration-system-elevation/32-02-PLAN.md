---
phase: 32-celebration-system-elevation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/audio/soundEffects.ts
  - src/lib/audio/celebrationSounds.ts
autonomous: true
requirements:
  - CELB-07
  - CELB-08

must_haves:
  truths:
    - "Existing oscillator sounds (playCorrect, playIncorrect, playLevelUp, etc.) sound noticeably warmer and fuller with harmonics"
    - "playCelebrationSequence schedules multi-stage sounds with sample-accurate Web Audio timing"
    - "Sound respects isSoundMuted() -- all new functions check mute state before playing"
    - "Rising pitch on consecutive correct answers creates ascending momentum"
    - "Fail state has a distinct soft, warm, encouraging tone"
  artifacts:
    - path: "src/lib/audio/soundEffects.ts"
      provides: "Harmonics-enhanced playNote and existing sound functions"
      contains: "playNoteWarm"
    - path: "src/lib/audio/celebrationSounds.ts"
      provides: "Multi-stage choreography sound scheduling"
      exports: ["playCelebrationSequence", "playCountUpTick", "playConfettiBurst", "playXPDing", "playErrorSoft"]
  key_links:
    - from: "src/lib/audio/celebrationSounds.ts"
      to: "src/lib/audio/soundEffects.ts"
      via: "imports getContext and playNoteWarm"
      pattern: "import.*soundEffects"
---

<objective>
Add warm harmonics to all existing oscillator sounds and create a new celebrationSounds module for multi-stage choreography timing.

Purpose: CELB-07 transforms thin single-oscillator beeps into warm, game-like tones. CELB-08 provides the sound scheduling layer needed for TestResultsScreen choreography -- count-up ticks, confetti pop, pass/fail reveal, XP dings, and fail tones.
Output: Enhanced soundEffects.ts with harmonics, new celebrationSounds.ts with choreography-aware sound functions.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-celebration-system-elevation/32-RESEARCH.md

@src/lib/audio/soundEffects.ts
@src/lib/audio/audioPlayer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add harmonics to soundEffects.ts</name>
  <files>src/lib/audio/soundEffects.ts</files>
  <action>
Enhance the existing `playNote` function and all sound functions with warm harmonics (CELB-07):

1. Create a new `playNoteWarm` function alongside existing `playNote`:
   ```
   function playNoteWarm(
     ctx: AudioContext,
     freq: number,
     delay: number,
     duration: number,
     gain: number,
     waveType: OscillatorWaveType = 'sine',
     harmonics?: { multiplier: number; gainRatio: number }[]
   ): void
   ```
   Default harmonics: `[{ multiplier: 2, gainRatio: 0.3 }, { multiplier: 3, gainRatio: 0.15 }]`
   Implementation: call `playNote` for fundamental, then for each harmonic, call `playNote` with `freq * multiplier` and `gain * gainRatio`.

2. Export `getContext` (currently private) so celebrationSounds.ts can use it. Rename internal function to keep it clean -- or export the lazy creator.

3. Update ALL existing sound functions to use `playNoteWarm` instead of `playNote`:
   - `playCorrect()`: C5 + E5 with harmonics -- brighter, fuller ding
   - `playIncorrect()`: E4 + C4 with harmonics -- warmer, gentler
   - `playLevelUp()`: C5 + E5 + G5 arpeggio with harmonics
   - `playMilestone()`: Chord + C6 with harmonics -- richer, more celebratory
   - `playStreak()`: E5 + G5 + C6 with harmonics
   - `playMasteryComplete()`: Full chord with harmonics -- most dramatic
   - `playCountdownTick()`, `playCountdownGo()`: Keep harmonics subtle (lower gainRatio: 0.15/0.08)
   - `playSkip()`, `playKnow()`, `playDontKnow()`: Harmonics at standard levels
   - `playPanelReveal()`, `playCompletionSparkle()`, `playFling()`: Custom sweep functions -- add a second oscillator at 2x frequency with 0.2 gain for sweep functions (not playNoteWarm, since those use frequency ramps)
   - `playTimerWarningTick()`: Subtle harmonics

4. Keep the existing `playNote` function as-is for backward compatibility but mark with a comment that `playNoteWarm` is preferred.

5. Export `playNoteWarm`, `getContext`, and the `OscillatorWaveType` type for use in celebrationSounds.ts.

IMPORTANT: Do NOT change the module-level AudioContext singleton pattern. Do NOT create additional AudioContext instances. All new oscillators must connect to the same `ctx.destination`.
  </action>
  <verify>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. All existing sound function signatures unchanged (backward compatible)
4. `getContext` and `playNoteWarm` are exported
  </verify>
  <done>
- Every existing oscillator sound function uses playNoteWarm with 2nd and 3rd harmonics
- Sweep-based sounds (fling, panelReveal, completionSparkle) have parallel harmonic oscillator
- getContext and playNoteWarm exported for celebrationSounds.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create celebrationSounds.ts with multi-stage choreography sounds</name>
  <files>src/lib/audio/celebrationSounds.ts</files>
  <action>
Create `src/lib/audio/celebrationSounds.ts` implementing CELB-08 -- sound functions for multi-stage celebration choreography:

1. Import `getContext`, `playNoteWarm`, `isSoundMuted` from `./soundEffects`.

2. `playCountUpTick(index: number, total: number)`:
   - Rapid ticking that accelerates with the count, like a slot machine
   - Base frequency 800 Hz, duration 40ms, gain 0.12
   - As `index/total` increases, decrease delay between ticks (already handled by caller scheduling)
   - Pitch rises slightly as count progresses: `800 + (index / total) * 200` Hz
   - Very short notes (40ms) with minimal harmonics (gainRatio 0.15 for 2nd only, no 3rd)

3. `playConfettiBurst()`:
   - Satisfying 'pop' sound: quick noise burst using oscillator at 1200 Hz for 30ms + rapid frequency sweep down to 300 Hz
   - Followed by gentle sparkle: 3 quick high-pitched notes (2000, 2400, 2800 Hz) at 20ms each, staggered by 60ms, gain 0.08
   - Uses Web Audio API `ctx.currentTime + offset` for sample-accurate timing

4. `playPassReveal()`:
   - Triumphant ascending chord: C5+E5+G5 simultaneous (0.3s), then C6 (0.2s), then E6 (0.15s)
   - Use `playNoteWarm` with full harmonics for rich, warm tone
   - Total duration ~0.7s

5. `playFailReveal()`:
   - Soft, warm, encouraging tone per user decision
   - Low C4 sine with harmonics, gentle volume (0.12), 0.5s duration
   - NOT a buzzer -- gentle, low-pitched, brief 'bonk' feel
   - Descending two notes: D4 (294 Hz) -> C4 (262 Hz), 0.2s each

6. `playXPDing(consecutiveCorrect: number)`:
   - Coin collect style: short bright note
   - Rising pitch on consecutive correct answers: base 880 Hz (A5) + `consecutiveCorrect * 50` Hz
   - Cap at 1320 Hz (E6) to prevent ear-piercing
   - Duration 80ms, gain 0.2
   - Triangle wave for coin-like timbre

7. `playErrorSoft()`:
   - Brief, low, gentle 'bonk' -- NOT a buzzer
   - 200 Hz triangle wave, 100ms, gain 0.12
   - Slight pitch bend down: 200 Hz -> 150 Hz over 100ms

8. `playPracticeComplete()`:
   - Quick chime: C5 + E5 rapid (80ms each, 50ms gap), gain 0.15
   - Lighter than playMilestone -- practice is lower stakes

9. `playUltimateFanfare()`:
   - Unique victory fanfare for 100% perfect score
   - Multi-note ascending sequence: C5 (0.15s) -> E5 (0.15s) -> G5 (0.15s) -> C6 chord (C6+E6+G6 simultaneous, 0.4s)
   - Full harmonics, gain 0.35
   - Final chord has a slight reverb effect: duplicate notes at 0.02s delay with 0.5 gain ratio

10. `playCelebrationSequence(stage: 'card-enter' | 'count-up-tick' | 'count-up-land' | 'pass-reveal' | 'fail-reveal' | 'confetti' | 'buttons-enter')`:
    - Central dispatch function that plays the appropriate sound for each choreography stage
    - Accepts optional `{ consecutiveIndex?: number; total?: number }` for count-up tick context
    - Maps each stage to the appropriate function above
    - All functions check `isSoundMuted()` at the top -- return immediately if muted

All functions follow the existing pattern: try/catch wrapping, silent failure, `isSoundMuted()` guard at top, module-level `getContext()` for AudioContext.
  </action>
  <verify>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. All functions are exported and have correct type signatures
4. Every function checks `isSoundMuted()` before playing
5. No new AudioContext created -- uses shared `getContext()` from soundEffects.ts
  </verify>
  <done>
- celebrationSounds.ts exports all multi-stage sound functions
- playCelebrationSequence dispatches to correct sound per stage
- Rising XP ding pitch on consecutive correct answers
- Soft error tone is gentle bonk, not buzzer
- 100% fanfare is unique and dramatic
- All sounds respect mute state
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck && npm run lint && npm run build` all pass
- All existing sound functions still work (backward compatible)
- New celebrationSounds.ts compiles and exports all required functions
- No duplicate AudioContext instances (single shared module-level context)
</verification>

<success_criteria>
- Existing sounds are noticeably warmer with 2nd/3rd harmonics
- celebrationSounds.ts provides all stage-specific sounds for choreography
- Rising XP ding pitch, soft error tone, unique 100% fanfare all implemented
- All sound functions respect mute state and fail silently
</success_criteria>

<output>
After completion, create `.planning/phases/32-celebration-system-elevation/32-02-SUMMARY.md`
</output>

