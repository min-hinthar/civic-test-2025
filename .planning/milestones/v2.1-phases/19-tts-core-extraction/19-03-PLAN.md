---
phase: 19-tts-core-extraction
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/contexts/TTSContext.tsx
  - src/hooks/useTTS.ts
  - src/hooks/useTTSSettings.ts
autonomous: true

must_haves:
  truths:
    - "TTSContext provider creates and owns a shared engine instance, renders children immediately (optimistic)"
    - "useTTS() hook returns the full engine+state API (speak, cancel, pause, resume, isSpeaking, isPaused, isSupported, error, voices, settings, updateSettings)"
    - "useTTSSettings() hook returns lightweight settings-only access (settings + updateSettings)"
    - "Provider migrates from old 'civic-prep-speech-rate' localStorage key to new 'civic-prep-tts-settings' key silently"
    - "Named rate mapping ('slow'->0.7, 'normal'->0.98, 'fast'->1.3) lives in provider"
  artifacts:
    - path: "src/contexts/TTSContext.tsx"
      provides: "TTSProvider context with shared engine, settings persistence, lazy-loaded"
      exports: ["TTSProvider"]
    - path: "src/hooks/useTTS.ts"
      provides: "Main TTS hook wrapping shared engine with reactive state"
      exports: ["useTTS"]
    - path: "src/hooks/useTTSSettings.ts"
      provides: "Lightweight settings-only hook for future Settings page"
      exports: ["useTTSSettings"]
  key_links:
    - from: "src/contexts/TTSContext.tsx"
      to: "src/lib/ttsCore.ts"
      via: "creates engine with createTTSEngine"
      pattern: "createTTSEngine"
    - from: "src/hooks/useTTS.ts"
      to: "src/contexts/TTSContext.tsx"
      via: "useContext to access shared engine"
      pattern: "useContext.*TTSContext"
    - from: "src/contexts/TTSContext.tsx"
      to: "localStorage"
      via: "settings persistence with migration"
      pattern: "civic-prep-tts-settings"
---

<objective>
Create the React context provider and hooks that bridge ttsCore to React consumers, handling settings persistence, engine lifecycle, and reactive state updates.

Purpose: Provide the `useTTS()` hook that all consumer components (SpeechButton, InterviewSession, InterviewResults) will use, plus a lightweight `useTTSSettings()` for future Settings page. The provider manages engine creation, settings migration, and deferred voice loading.

Output: Three files -- `src/contexts/TTSContext.tsx` (provider), `src/hooks/useTTS.ts` (main hook), `src/hooks/useTTSSettings.ts` (settings hook).
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-01-SUMMARY.md
@src/lib/ttsCore.ts
@src/lib/ttsTypes.ts
@src/contexts/ThemeContext.tsx
@src/contexts/LanguageContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TTSContext provider with engine lifecycle and settings persistence</name>
  <files>src/contexts/TTSContext.tsx</files>
  <action>
Create `src/contexts/TTSContext.tsx` following existing context patterns (ThemeContext, LanguageContext).

**Constants:**
- `SETTINGS_KEY = 'civic-prep-tts-settings'` (new unified key)
- `OLD_RATE_KEY = 'civic-prep-speech-rate'` (old key for migration)
- `RATE_MAP: Record<'slow' | 'normal' | 'fast', number>` = `{ slow: 0.7, normal: 0.98, fast: 1.3 }`
- `DEFAULT_SETTINGS: TTSSettings` = `{ rate: 'normal', pitch: 1.02, lang: 'en-US', preferredVoice: null }`

**Context shape (`TTSContextValue`):**
```ts
{
  engine: TTSEngine | null;
  state: TTSState;
  voices: SpeechSynthesisVoice[];
  isSupported: boolean;
  error: string | null;
  settings: TTSSettings;
  updateSettings: (partial: Partial<TTSSettings>) => void;
  rateToNumeric: (rate: 'slow' | 'normal' | 'fast') => number;
}
```

**TTSProvider component:**

1. **Settings state:** `useState<TTSSettings>` initialized from a function that:
   - Reads `SETTINGS_KEY` from localStorage. If found, parse and return.
   - If not found, check `OLD_RATE_KEY` for migration. If found: read old rate string, build new TTSSettings with that rate, write to `SETTINGS_KEY`, delete `OLD_RATE_KEY`. No console output (silent migration per locked decision).
   - If neither found, return DEFAULT_SETTINGS.

2. **Engine state:** `useState<TTSEngine | null>(null)` -- null on server and initial render.

3. **TTS state:** `useState<TTSState>({ isSpeaking: false, isPaused: false, currentText: null })`.

4. **Voices state:** `useState<SpeechSynthesisVoice[]>([])`.

5. **Error state:** `useState<string | null>(null)`.

6. **Engine creation effect (useEffect, []):**
   - If typeof window === 'undefined', return (SSR guard).
   - Create engine: `const eng = createTTSEngine({ rate: RATE_MAP[settings.rate], pitch: settings.pitch, lang: settings.lang })`.
   - Subscribe to state changes: `const unsub = eng.onStateChange(setState)`.
   - Set engine state.
   - Schedule deferred voice loading: use `requestIdleCallback` with `setTimeout(0)` fallback. In callback: call `loadVoices()`, set voices state, optionally find preferred voice.
   - Return cleanup: `unsub(); eng.destroy();`

7. **updateSettings callback:** `useCallback((partial) => { ... })` that merges partial into settings, persists to localStorage under `SETTINGS_KEY`, and calls `engine.setDefaults()` with numeric rate conversion.

8. **isSupported:** Derived from engine -- `engine?.isSupported() ?? true` (optimistic default per locked decision, avoids hydration mismatch).

9. **rateToNumeric:** Simple lookup function exposed for consumers.

10. **Render:** `<TTSContext.Provider value={contextValue}>{children}</TTSContext.Provider>` -- render children immediately, no loading gate.

**Code splitting:** Export a lazy-loaded wrapper:
```ts
import dynamic from 'next/dynamic';
export const LazyTTSProvider = dynamic(
  () => import('./TTSContext').then(m => ({ default: m.TTSProvider })),
  { ssr: false }
);
```
Wait -- this is a context file. The lazy-load should be handled at the AppShell import site, not in the context file itself. Instead, just export `TTSProvider` normally from this file. The Plan 06 (AppShell wiring) will handle the dynamic import at the consumer site.

Export: `TTSProvider`, `TTSContext` (for hooks to access).
  </action>
  <verify>Run `npx tsc --noEmit`. Zero type errors. Run `npm run lint`. Zero lint errors.</verify>
  <done>TTSContext.tsx exports TTSProvider with shared engine, settings persistence, migration, and deferred voice loading. Follows ThemeContext/LanguageContext patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Create useTTS and useTTSSettings hooks</name>
  <files>src/hooks/useTTS.ts, src/hooks/useTTSSettings.ts</files>
  <action>
**`src/hooks/useTTS.ts`:**

Create the main `useTTS` hook that wraps the shared engine from TTSContext with reactive state.

**Parameters:** `options?: { isolated?: boolean }`

**Implementation:**
1. `useContext(TTSContext)` -- throw Error if null ("useTTS must be used within TTSProvider").
2. Destructure: `{ engine, state, voices, isSupported, error, settings, updateSettings, rateToNumeric }`.
3. **If `isolated: true`**: Create a local engine via `createTTSEngine()` in a `useRef` (created once). Subscribe to its state changes via `useState`. Cleanup on unmount: `engine.destroy()`. The isolated engine still reads `settings` from provider context.
4. **Wrap `speak`**: Create a memoized `speak` function that:
   - Calls engine.speak(text, overrides) with rate converted from named to numeric if settings.rate is used.
   - Catches errors and sets error state.
   - Clears error on success.
5. **Auto-cancel on unmount**: `useEffect` cleanup calls `engine.cancel()`.
6. **Return shape** (matches locked decision exactly):
```ts
{
  speak: (text: string, overrides?: SpeakOptions) => Promise<void>,
  cancel: () => void,
  pause: () => void,
  resume: () => void,
  isSpeaking: boolean,     // from state
  isPaused: boolean,       // from state
  isSupported: boolean,
  error: string | null,
  voices: SpeechSynthesisVoice[],
  refreshVoices: () => Promise<void>,
  settings: TTSSettings,
  updateSettings: (partial: Partial<TTSSettings>) => void,
}
```

Export as named export `useTTS`.

**`src/hooks/useTTSSettings.ts`:**

Lightweight hook for settings-only access (future Settings page, Phase 22).

1. `useContext(TTSContext)` -- throw Error if null.
2. Return `{ settings, updateSettings }` only.

Export as named export `useTTSSettings`.

**React Compiler compatibility notes:**
- Do NOT use `useMemo<Type>()` generic syntax -- use `const x: Type = useMemo()` instead.
- Do NOT access ref `.current` during render -- only in effects/handlers.
- For the isolated engine, use `useRef` but only access `.current` inside useEffect cleanup and event handlers, not during render. Store the engine in state if render-time access is needed.
  </action>
  <verify>Run `npx tsc --noEmit`. Zero type errors. Run `npm run lint`. Zero lint errors. Verify useTTS return shape matches the locked decision interface.</verify>
  <done>useTTS.ts provides full engine+state hook. useTTSSettings.ts provides lightweight settings access. Both typecheck and lint clean. Auto-cancel on unmount is implemented.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes with zero errors
3. TTSProvider creates engine client-side only, renders children immediately
4. Settings migration from old key works (manually verify by checking migration code path)
5. useTTS return shape matches locked decision interface exactly
6. useTTSSettings returns only settings + updateSettings
</verification>

<success_criteria>
- TTSProvider follows existing context patterns (ThemeContext, LanguageContext)
- Provider placement documented for AppShell wiring (after LanguageProvider, before StateProvider)
- Settings persistence uses new unified key 'civic-prep-tts-settings'
- Old key migration is silent (no console output)
- Named rate mapping ('slow'->0.7, 'normal'->0.98, 'fast'->1.3) in provider
- useTTS auto-cancels on unmount
- Both hooks throw descriptive error when used outside provider
- All files compile and lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-03-SUMMARY.md`
</output>

