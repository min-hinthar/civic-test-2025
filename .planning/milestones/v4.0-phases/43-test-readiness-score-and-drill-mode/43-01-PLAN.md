---
phase: 43-test-readiness-score-and-drill-mode
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/readiness/types.ts
  - src/lib/readiness/readinessEngine.ts
  - src/lib/readiness/readinessEngine.test.ts
  - src/lib/readiness/drillSelection.ts
  - src/lib/readiness/drillSelection.test.ts
  - src/lib/readiness/index.ts
  - src/lib/srs/fsrsEngine.ts
autonomous: true
requirements: [RDNS-01, RDNS-02, RDNS-03, RDNS-04, RDNS-05]

must_haves:
  truths:
    - "calculateReadiness returns 0-100 score from accuracy, coverage, consistency inputs"
    - "Score is capped at 60 when any of the 3 main USCIS categories has zero coverage"
    - "Consistency dimension uses FSRS retrievability (0-1) averaged across reviewed cards"
    - "Accuracy dimension is weighted average of per-category mastery"
    - "Coverage dimension is percentage of 128 questions attempted"
    - "getTierLabel returns correct bilingual label for each of the 4 tiers"
    - "selectDrillQuestions returns weakest questions shuffled, fills with medium-mastery if fewer weak than count"
    - "selectDrillQuestions supports both weak-all and category-specific modes"
  artifacts:
    - path: "src/lib/readiness/readinessEngine.ts"
      provides: "calculateReadiness, calculateAccuracy, calculateCoverage, calculateConsistency, getTierLabel, findZeroCoverageCategories"
      exports: ["calculateReadiness", "getTierLabel"]
    - path: "src/lib/readiness/readinessEngine.test.ts"
      provides: "Unit tests for readiness formula, cap logic, tier labels, dimensions"
      min_lines: 80
    - path: "src/lib/readiness/drillSelection.ts"
      provides: "selectDrillQuestions for weak-all and category-specific drill modes"
      exports: ["selectDrillQuestions"]
    - path: "src/lib/readiness/drillSelection.test.ts"
      provides: "Unit tests for drill question selection"
      min_lines: 40
    - path: "src/lib/readiness/types.ts"
      provides: "ReadinessInput, DimensionScore, ReadinessResult, DrillConfig types"
      exports: ["ReadinessInput", "DimensionScore", "ReadinessResult", "DrillConfig"]
    - path: "src/lib/readiness/index.ts"
      provides: "Barrel exports for readiness module"
    - path: "src/lib/srs/fsrsEngine.ts"
      provides: "Exported FSRS singleton for retrievability projection"
      exports: ["fsrsInstance"]
  key_links:
    - from: "src/lib/readiness/readinessEngine.ts"
      to: "src/lib/srs/fsrsEngine.ts"
      via: "fsrsInstance.get_retrievability(card, now, false)"
      pattern: "get_retrievability"
    - from: "src/lib/readiness/drillSelection.ts"
      to: "src/lib/mastery/index.ts"
      via: "calculateQuestionAccuracy for scoring questions"
      pattern: "calculateQuestionAccuracy"
---

<objective>
Build the readiness scoring engine and drill question selection as pure, testable functions using TDD.

Purpose: The readiness engine is the algorithmic foundation for the entire phase -- Dashboard card, dimension breakdown, cap warnings, and drill question selection all depend on these pure functions. TDD ensures the formula is correct before any UI work begins.

Output: Tested `src/lib/readiness/` module with readiness scoring and drill selection functions.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-test-readiness-score-and-drill-mode/43-CONTEXT.md
@.planning/phases/43-test-readiness-score-and-drill-mode/43-RESEARCH.md
@src/lib/mastery/index.ts
@src/lib/mastery/categoryMapping.ts
@src/lib/mastery/calculateMastery.ts
@src/lib/srs/fsrsEngine.ts
@src/lib/srs/srsTypes.ts
@src/lib/srs/srsStore.ts
@src/lib/practice/questionSelection.ts
</context>

<feature>
  <name>Readiness Engine and Drill Selection</name>
  <files>
    src/lib/readiness/types.ts
    src/lib/readiness/readinessEngine.ts
    src/lib/readiness/readinessEngine.test.ts
    src/lib/readiness/drillSelection.ts
    src/lib/readiness/drillSelection.test.ts
    src/lib/readiness/index.ts
    src/lib/srs/fsrsEngine.ts
  </files>
  <behavior>
    Readiness Engine (readinessEngine.ts):
    - calculateReadiness(input: ReadinessInput) -> ReadinessResult
    - Input: categoryMasteries (Record of 3 main USCIS category mastery %), totalQuestions (128), attemptedQuestionIds (Set of IDs), srsCards (array of {questionId, card})
    - Accuracy dimension (40% weight): weighted average of per-category mastery from categoryMasteries (weighted by question count per category)
    - Coverage dimension (30% weight): (attemptedQuestionIds.size / totalQuestions) * 100
    - Consistency dimension (30% weight): average FSRS retrievability across reviewed cards (card.reps > 0), multiplied by 100. Return 0 if no reviewed cards
    - Uncapped score: Math.round(accuracy * 0.4 + coverage * 0.3 + consistency * 0.3)
    - 60% cap: if any of the 3 main USCIS categories (American Government, American History, Integrated Civics) has zero coverage (no questions attempted from that category's sub-categories), cap score at min(uncapped, 60)
    - Zero-coverage check: for each main category, check if attemptedQuestionIds intersects with that category's question IDs
    - getTierLabel(score): 0-25 -> "Getting Started"/"စတင်နေပါသည်", 26-50 -> "Building Up"/"တည်ဆောက်နေပါသည်", 51-75 -> "Almost Ready"/"အဆင်သင့်နီးပါပြီ", 76-100 -> "Test Ready"/"စာမေးပွဲ အဆင်သင့်!"
    - Result includes: score, uncapped, isCapped, cappedCategories[], dimensions {accuracy, coverage, consistency}, tierLabel {en, my}

    FSRS singleton export:
    - Export existing `f` singleton from fsrsEngine.ts as `fsrsInstance` (add one line: `export { f as fsrsInstance }`)
    - Readiness engine uses fsrsInstance.get_retrievability(card, now, false) returning 0-1

    Test cases for readinessEngine.test.ts:
    - Empty input (no answers, no SRS cards) -> score 0, all dimensions 0
    - Full coverage, 100% accuracy, high consistency -> score near 100
    - Partial coverage, mixed accuracy -> score between 30-70
    - Zero coverage in one main category -> isCapped true, score <= 60
    - Zero coverage in all categories -> score 0, capped
    - Only SRS cards with reps=0 (new) -> consistency 0
    - Tier label boundaries: 0, 25, 26, 50, 51, 75, 76, 100
    - Division safety: totalQuestions=0 -> coverage 0 (not NaN)

    Drill Selection (drillSelection.ts):
    - selectDrillQuestions(pool: Question[], count: number, answerHistory: StoredAnswer[]) -> Question[]
    - Scores each question by accuracy (via calculateQuestionAccuracy)
    - Sorts weakest first
    - Takes up to `count` questions
    - If fewer questions exist than count, returns all available
    - Shuffles result with fisherYatesShuffle
    - Category-specific mode: caller passes pre-filtered pool (only that category's questions)
    - Weak-all mode: caller passes allQuestions as pool

    Test cases for drillSelection.test.ts:
    - Empty pool -> empty result
    - Pool smaller than count -> returns all, shuffled
    - Pool larger than count -> returns count questions, weakest first (then shuffled)
    - Questions with no history get accuracy 0 (treated as weak)
    - Mixed history: questions with low accuracy selected over high accuracy ones
  </behavior>
  <implementation>
    RED phase:
    1. Create src/lib/readiness/types.ts with ReadinessInput, DimensionScore, ReadinessResult, DrillConfig interfaces
    2. Create src/lib/readiness/readinessEngine.test.ts with all test cases (importing from readinessEngine.ts which doesn't exist yet)
    3. Create src/lib/readiness/drillSelection.test.ts with all test cases
    4. Run tests -- all MUST fail (module not found)

    GREEN phase:
    1. Export FSRS singleton: add `export { f as fsrsInstance }` to src/lib/srs/fsrsEngine.ts
    2. Implement readinessEngine.ts: calculateReadiness with accuracy/coverage/consistency dimensions, 60% cap logic, getTierLabel. Use USCIS_CATEGORIES from categoryMapping for zero-coverage checks. Use fsrsInstance.get_retrievability for consistency. Coerce card.due to Date if string (IndexedDB pitfall).
    3. Implement drillSelection.ts: selectDrillQuestions using calculateQuestionAccuracy from mastery module + fisherYatesShuffle
    4. Create index.ts barrel exports
    5. Run tests -- all MUST pass

    REFACTOR phase (if needed):
    - Extract helper functions, improve naming, add JSDoc
    - Run tests -- still pass

    IMPORTANT ANTI-PATTERNS TO AVOID:
    - Do NOT use `useMemo<Type>(() => ...)` syntax (React Compiler ESLint breaks)
    - Do NOT create a new FSRS instance -- export and reuse the existing singleton
    - Guard all divisions with zero-check (totalQuestions, reviewedCount, etc.)
    - Coerce card.due to Date before passing to get_retrievability (IndexedDB serializes to string)
    - Use 3 main USCIS categories (not 7 sub-categories) for the 60% cap check
  </implementation>
</feature>

<verification>
  <automated>cd /c/Users/minkk/GitHub/civic-test-2025 && pnpm test:run src/lib/readiness/ -- --reporter=verbose</automated>
  <manual>Verify test output shows all cases passing for readinessEngine and drillSelection</manual>
</verification>

<success_criteria>
- readinessEngine.test.ts has 8+ test cases covering dimensions, cap, tiers, edge cases -- all green
- drillSelection.test.ts has 5+ test cases covering selection logic -- all green
- calculateReadiness returns correct scores for edge cases (empty, full, capped)
- fsrsInstance exported from fsrsEngine.ts
- No new dependencies installed (all libraries already in project)
- `pnpm build` still succeeds (no type errors introduced)
</success_criteria>

<output>
After completion, create `.planning/phases/43-test-readiness-score-and-drill-mode/43-01-SUMMARY.md`
</output>
