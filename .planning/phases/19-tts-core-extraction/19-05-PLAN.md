---
phase: 19-tts-core-extraction
plan: 05
type: execute
wave: 3
depends_on: ["19-03"]
files_modified:
  - src/components/interview/InterviewSession.tsx
  - src/components/interview/InterviewResults.tsx
autonomous: true

must_haves:
  truths:
    - "InterviewSession uses useTTS() and safeSpeak() instead of useInterviewTTS()"
    - "InterviewSession has 4 named handler functions: handleGreeting, handleReading, handleGrading, handleReplay"
    - "Handlers use safeSpeak() with async/await and check result === 'completed' before state transitions"
    - "InterviewResults uses useTTS() shared engine (not isolated) instead of useInterviewTTS()"
    - "useTTS() handles all cleanup -- no manual cancel in InterviewSession unmount effects"
  artifacts:
    - path: "src/components/interview/InterviewSession.tsx"
      provides: "Interview session component migrated to useTTS + safeSpeak"
    - path: "src/components/interview/InterviewResults.tsx"
      provides: "Interview results component migrated to useTTS shared engine"
  key_links:
    - from: "src/components/interview/InterviewSession.tsx"
      to: "src/hooks/useTTS.ts"
      via: "useTTS() hook"
      pattern: "useTTS"
    - from: "src/components/interview/InterviewSession.tsx"
      to: "src/lib/ttsCore.ts"
      via: "safeSpeak() helper for async sequencing"
      pattern: "safeSpeak"
    - from: "src/components/interview/InterviewResults.tsx"
      to: "src/hooks/useTTS.ts"
      via: "useTTS() hook"
      pattern: "useTTS"
---

<objective>
Migrate both interview consumer components (InterviewSession, InterviewResults) from useInterviewTTS to the new useTTS hook with safeSpeak-based async sequencing.

Purpose: Replace the callback-driven speakWithCallback pattern with clean async/await using safeSpeak(). The 4 handler function pattern makes the interview flow explicit and readable. useTTS handles all cleanup automatically.

Output: Migrated InterviewSession.tsx and InterviewResults.tsx -- both import from useTTS, zero references to useInterviewTTS.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-03-SUMMARY.md
@src/components/interview/InterviewSession.tsx
@src/components/interview/InterviewResults.tsx
@src/hooks/useTTS.ts
@src/lib/ttsCore.ts
@src/lib/ttsTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate InterviewSession to useTTS with 4 handler functions</name>
  <files>src/components/interview/InterviewSession.tsx</files>
  <action>
Migrate InterviewSession from `useInterviewTTS()` to `useTTS()` with `safeSpeak()` helper.

**Import changes:**
- Remove: `import { useInterviewTTS } from '@/hooks/useInterviewTTS';`
- Add: `import { useTTS } from '@/hooks/useTTS';`
- Add: `import { safeSpeak } from '@/lib/ttsCore';`

**Hook usage:**
Replace:
```ts
const { speakWithCallback, cancel: cancelTTS, isSpeaking } = useInterviewTTS();
```
With:
```ts
const { speak, cancel: cancelTTS, isSpeaking } = useTTS();
```

Note: `speak` is needed for the engine reference that `safeSpeak` requires. Actually, `safeSpeak` takes a `TTSEngine` -- but useTTS returns the wrapped speak function, not the raw engine. Two options:
- Option A: useTTS also exposes the raw engine so safeSpeak can use it.
- Option B: Create a local safeSpeak wrapper that uses the useTTS speak function.

Per the locked decision, safeSpeak takes `(engine, text, options)`. But the useTTS hook wraps the engine. The simplest approach: since `safeSpeak` just wraps `engine.speak()` in try/catch, create a local async helper that does the same with the hook's speak function:

```ts
const safeSpeakLocal = useCallback(async (text: string, options?: SpeakOptions) => {
  try {
    await speak(text, options);
    return 'completed' as const;
  } catch (err) {
    if (err instanceof TTSCancelledError) return 'cancelled' as const;
    return 'error' as const;
  }
}, [speak]);
```

Or, better: expose `engine` from useTTS context so safeSpeak can be used directly. Check if Plan 03 exposes engine -- the TTSContextValue has `engine: TTSEngine | null`. So useTTS can expose it. If not already exposed, the executor should add it. But let's use the local pattern to avoid coupling.

Actually, the simplest per the locked decision: the context value already has `engine`. The useTTS hook can expose it. But the hook's locked return shape doesn't include `engine`. So use the local wrapper approach.

**4 named handler functions (defined INSIDE the component, per locked decision):**

Replace the useEffect-based phase transitions with handler functions called from state setters:

```ts
// GREETING: called when component mounts / phase is 'greeting'
const handleGreeting = useCallback(async (greetingText: string) => {
  const result = await safeSpeakLocal(greetingText);
  if (result === 'completed') {
    transitionTimerRef.current = setTimeout(() => {
      setQuestionPhase('chime');
    }, 1000);
  }
}, [safeSpeakLocal]);

// READING: called when phase transitions to 'reading'
const handleReading = useCallback(async (questionText: string) => {
  const result = await safeSpeakLocal(questionText);
  if (result === 'completed') {
    setTextVisible(true);
    if (micPermission) startRecording();
    setQuestionPhase('responding');
  }
}, [safeSpeakLocal, micPermission, startRecording]);

// GRADING: called when phase transitions to 'grading'
const handleGrading = useCallback(async (answerText: string) => {
  await safeSpeakLocal(answerText);
  // Don't transition -- grading phase stays until user grades
}, [safeSpeakLocal]);

// REPLAY: called when user clicks replay
const handleReplay = useCallback(async (questionText: string) => {
  if (replaysUsed >= MAX_REPLAYS) return;
  stopRecording();
  setReplaysUsed(prev => prev + 1);

  // 1s pause before replay
  await new Promise(resolve => setTimeout(resolve, 1000));
  const result = await safeSpeakLocal(questionText);
  if (result === 'completed' && micPermission) {
    startRecording();
  }
}, [replaysUsed, stopRecording, safeSpeakLocal, micPermission, startRecording]);
```

**Phase effect rewiring:**

The current code uses useEffect watching `questionPhase` to trigger TTS. Replace with:

- GREETING effect: Still uses useEffect (runs on mount). Calls `handleGreeting(getRandomGreeting())`.
- CHIME effect: Keep as-is (playChime + setTimeout -> 'reading'). When transitioning to 'reading', call `handleReading(currentQuestion.question_en)` instead of using a separate useEffect.
- READING: Remove the useEffect. Instead, at the end of the chime effect's timeout callback, call handleReading directly.
- GRADING effect: Replace useEffect with calling handleGrading from the phase setter.

Wait -- the locked decision says "Triggered by calling handlers from state setters (not useEffect watching phase)". This means:

Instead of:
```ts
useEffect(() => { if (questionPhase === 'reading') { speakWithCallback(...) } }, [questionPhase, ...]);
```

Do:
```ts
// When transitioning to chime (from greeting or from transition):
setQuestionPhase('chime');
// In chime handler (still needs effect for playChime):
useEffect(() => {
  if (questionPhase !== 'chime') return;
  playChime();
  transitionTimerRef.current = setTimeout(() => {
    setQuestionPhase('reading');
    if (currentQuestion) handleReading(currentQuestion.question_en);
  }, 200);
}, [questionPhase, currentQuestion, handleReading]);
```

Actually, this creates a React Compiler issue -- calling async handlers directly from state transitions inside effects. Let's keep the useEffect pattern but replace speakWithCallback with the async handler calls. The key change is:

1. **greeting effect**: calls `handleGreeting()` instead of `speakWithCallback` with onEnd callback.
2. **chime effect**: stays the same (playChime + timer), but transitions to reading phase AND calls handleReading.
3. **reading effect**: REMOVED -- handleReading is called from chime effect timer callback.
4. **grading effect**: calls `handleGrading()` instead of `speakWithCallback`.

The handleReplay replaces the existing handleReplay callback entirely.

**Cleanup simplification:**
Remove the manual cleanup effect:
```ts
// REMOVE THIS:
useEffect(() => {
  return () => {
    cancelTTS();
    cleanupRecorder();
    if (transitionTimerRef.current) clearTimeout(transitionTimerRef.current);
  };
}, [cancelTTS, cleanupRecorder]);
```
Keep the recorder cleanup but remove `cancelTTS()` -- useTTS handles TTS cleanup on unmount automatically (per locked decision). Keep the transition timer cleanup though:
```ts
useEffect(() => {
  return () => {
    cleanupRecorder();
    if (transitionTimerRef.current) clearTimeout(transitionTimerRef.current);
  };
}, [cleanupRecorder]);
```

**handleQuit update:** Replace `cancelTTS()` call with `cancel()` (same function, just renamed via destructuring). Actually the destructuring already aliases it as `cancelTTS`, so keep that.

Import TTSCancelledError from ttsTypes for the local safeSpeakLocal helper.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run lint`. Grep for `useInterviewTTS` in InterviewSession.tsx -- should return zero matches. Verify all 4 handler functions exist: handleGreeting, handleReading, handleGrading, handleReplay.</verify>
  <done>InterviewSession uses useTTS() with 4 async handler functions. safeSpeak pattern for sequencing. No useInterviewTTS references. useTTS handles cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate InterviewResults to useTTS shared engine</name>
  <files>src/components/interview/InterviewResults.tsx</files>
  <action>
Migrate InterviewResults from `useInterviewTTS()` to `useTTS()`. This is a simpler migration since InterviewResults only uses TTS for the closing statement.

**Import changes:**
- Remove: `import { useInterviewTTS } from '@/hooks/useInterviewTTS';`
- Add: `import { useTTS } from '@/hooks/useTTS';`

**Hook usage:**
Replace:
```ts
const { speakWithCallback, cancel: cancelTTS, isSpeaking } = useInterviewTTS();
```
With:
```ts
const { speak, cancel: cancelTTS, isSpeaking } = useTTS();
```

Uses **shared engine** (not isolated) per locked decision.

**TTS closing statement effect:**
Replace `speakWithCallback(closing)` with `speak(closing)`:
```ts
useEffect(() => {
  const timer = setTimeout(() => {
    const closing = getClosingStatement(passed);
    speak(closing);  // speak returns Promise<void> -- fire-and-forget here (no need to await)
  }, 1000);

  return () => {
    clearTimeout(timer);
    cancelTTS();
  };
}, [passed, speak, cancelTTS]);
```

The `speak` function from useTTS is already memoized, so it's safe in the dependency array.

Note: The cleanup still calls `cancelTTS()` here because this is an intentional cancellation on unmount (navigating away from results). useTTS auto-cancel handles the hook-level cleanup, but this effect-level cleanup is still valid for navigating away mid-speech.

Everything else in InterviewResults stays the same -- no other TTS interactions.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run lint`. Grep for `useInterviewTTS` in InterviewResults.tsx -- should return zero matches.</verify>
  <done>InterviewResults uses useTTS() shared engine for closing statement. Zero references to useInterviewTTS. All other functionality unchanged.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run lint` passes
3. `grep -r "useInterviewTTS" src/components/interview/` returns zero matches
4. InterviewSession has 4 named handlers: handleGreeting, handleReading, handleGrading, handleReplay
5. All handlers use async/await with safeSpeakLocal pattern
6. InterviewResults uses useTTS() shared engine
7. No manual cancelTTS in InterviewSession unmount cleanup (useTTS handles it)
</verification>

<success_criteria>
- Both interview components use useTTS() instead of useInterviewTTS()
- InterviewSession has 4 explicit handler functions per locked decision
- Handlers use safeSpeak pattern: `const result = await safeSpeakLocal(text); if (result === 'completed') ...`
- InterviewResults uses shared engine (not isolated)
- useTTS handles TTS cleanup on unmount -- no manual cancel needed
- All existing behavior preserved (greeting -> chime -> reading -> responding -> grading flow)
- Replays still work with 1s pause and recording restart
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-05-SUMMARY.md`
</output>
