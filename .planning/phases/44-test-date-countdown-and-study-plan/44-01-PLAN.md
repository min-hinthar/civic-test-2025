---
phase: 44-test-date-countdown-and-study-plan
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/studyPlan/studyPlanTypes.ts
  - src/lib/studyPlan/studyPlanEngine.ts
  - src/lib/studyPlan/studyPlanEngine.test.ts
  - src/lib/studyPlan/index.ts
  - src/hooks/useTestDate.ts
  - src/hooks/useStudyPlan.ts
autonomous: true
requirements: [RDNS-07, RDNS-09, RDNS-10]

must_haves:
  truths:
    - "computeStudyPlan returns correct SRS review count matching srsDueCount input"
    - "computeStudyPlan distributes unpracticed questions evenly across remaining days"
    - "computeStudyPlan caps daily targets at reasonable maximums (15 new, 20 SRS)"
    - "computeStudyPlan recommends drill for weakest category below 50%"
    - "computeStudyPlan recommends mock test when none taken in 3+ days and mastery >= 40%"
    - "computeStudyPlan returns pace status (ahead/on-track/behind/null) based on readiness vs time fraction"
    - "computeStudyPlan works in no-date mode with null testDate using default pacing"
    - "computeStudyPlan returns daysRemaining=null when testDate is null"
    - "computeStudyPlan handles edge cases: test date today, test date in past, zero days remaining"
    - "useTestDate reads/writes test date to localStorage under civic-prep-test-date key"
    - "useStudyPlan composes existing hooks and feeds into computeStudyPlan via useMemo"
  artifacts:
    - path: "src/lib/studyPlan/studyPlanTypes.ts"
      provides: "StudyPlanInput, DailyPlan, PaceStatus type definitions"
      exports: ["StudyPlanInput", "DailyPlan", "PaceStatus"]
    - path: "src/lib/studyPlan/studyPlanEngine.ts"
      provides: "Pure function computing daily study targets from learning state"
      exports: ["computeStudyPlan"]
    - path: "src/lib/studyPlan/studyPlanEngine.test.ts"
      provides: "Unit tests covering all study plan engine behaviors"
      min_lines: 80
    - path: "src/lib/studyPlan/index.ts"
      provides: "Barrel export for studyPlan module"
      exports: ["computeStudyPlan", "StudyPlanInput", "DailyPlan", "PaceStatus"]
    - path: "src/hooks/useTestDate.ts"
      provides: "localStorage hook for test date persistence"
      exports: ["useTestDate"]
    - path: "src/hooks/useStudyPlan.ts"
      provides: "Composition hook bridging data hooks to study plan engine"
      exports: ["useStudyPlan"]
  key_links:
    - from: "src/lib/studyPlan/studyPlanEngine.ts"
      to: "src/lib/studyPlan/studyPlanTypes.ts"
      via: "imports StudyPlanInput, DailyPlan types"
      pattern: "import.*StudyPlanInput.*DailyPlan"
    - from: "src/hooks/useStudyPlan.ts"
      to: "src/lib/studyPlan/studyPlanEngine.ts"
      via: "calls computeStudyPlan in useMemo"
      pattern: "computeStudyPlan"
    - from: "src/hooks/useStudyPlan.ts"
      to: "src/hooks/useTestDate.ts"
      via: "reads testDate from useTestDate"
      pattern: "useTestDate"
    - from: "src/hooks/useStudyPlan.ts"
      to: "src/hooks/useReadinessScore.ts"
      via: "reads readiness score for gap calculation"
      pattern: "useReadinessScore"
---

<objective>
Build the study plan engine (TDD) and test date persistence hook.

Purpose: Create the pure-function core that computes daily study targets from learning state and optional test date. This is the foundation all UI cards consume. TDD ensures the algorithm handles edge cases correctly (zero days remaining, no-date mode, capped targets, pace status).

Output: Tested studyPlanEngine.ts, useTestDate hook, useStudyPlan composition hook.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/44-test-date-countdown-and-study-plan/44-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/readiness/types.ts:
```typescript
export interface ReadinessResult {
  score: number;        // 0-100, after 60% cap
  uncapped: number;     // 0-100, before cap
  isCapped: boolean;
  cappedCategories: string[];
  dimensions: {
    accuracy: DimensionScore;
    coverage: DimensionScore;
    consistency: DimensionScore;
  };
  tierLabel: TierLabel;
}
```

From src/lib/nba/nbaTypes.ts:
```typescript
export interface NBAInput {
  currentStreak: number;
  activityDates: string[];
  srsDueCount: number;
  overallMastery: number;
  categoryMasteries: Record<string, number>;
  testHistory: { date: string; score: number; totalQuestions: number }[];
  interviewHistory: { date: string; passed: boolean }[];
  uniqueQuestionsPracticed: number;
  totalQuestions: number;
}
```

From src/hooks/useReadinessScore.ts:
```typescript
export interface ReadinessScoreData {
  readiness: ReadinessResult | null;
  isLoading: boolean;
  subCategoryMasteries: Record<string, number>;
}
export function useReadinessScore(): ReadinessScoreData;
```

From src/hooks/useSRSWidget.ts:
```typescript
export function useSRSWidget(): {
  dueCount: number;
  reviewStreak: number;
  categoryBreakdown: CategoryBreakdownEntry[];
  isEmpty: boolean;
  isAllCaughtUp: boolean;
  nextDueText: { en: string; my: string } | null;
  isLoading: boolean;
};
```

From src/hooks/useCategoryMastery.ts:
```typescript
export function useCategoryMastery(): {
  categoryMasteries: Record<string, number>;
  subCategoryMasteries: Record<string, number>;
  overallMastery: number;
  isLoading: boolean;
};
```

From src/hooks/useStreak.ts:
```typescript
export function useStreak(): {
  currentStreak: number;
  longestStreak: number;
  freezesAvailable: number;
  freezesUsed: string[];
  activityDates: string[];
  isLoading: boolean;
  refresh: () => void;
};
```

From src/lib/nba/determineNBA.ts (date helpers pattern):
```typescript
function toDateString(d: Date): string {
  return d.toISOString().slice(0, 10);
}
function daysBetween(dateStr: string, now: Date): number {
  const date = new Date(dateStr + 'T00:00:00Z');
  const today = new Date(toDateString(now) + 'T00:00:00Z');
  return Math.round((today.getTime() - date.getTime()) / (24 * 60 * 60 * 1000));
}
```

From src/constants/questions.ts:
```typescript
export const totalQuestions: number; // 128
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Study plan engine types and pure function (TDD)</name>
  <files>src/lib/studyPlan/studyPlanTypes.ts, src/lib/studyPlan/studyPlanEngine.ts, src/lib/studyPlan/studyPlanEngine.test.ts, src/lib/studyPlan/index.ts</files>
  <behavior>
    - computeStudyPlan({ srsDueCount: 8, ... }) returns srsReviewCount: 8 (always reflects actual due count, not averaged)
    - computeStudyPlan with 60 unpracticed, 10 days remaining returns newQuestionTarget: 6 (ceil(60/10))
    - computeStudyPlan with 60 unpracticed, 2 days remaining returns newQuestionTarget: 15 (capped at max 15)
    - computeStudyPlan with 3 unpracticed, 30 days remaining returns newQuestionTarget: 3 (minimum 3 when any unpracticed exist)
    - computeStudyPlan with srsDueCount: 25 returns srsReviewCount: 20 (capped at max 20)
    - computeStudyPlan with weakCategories containing { name: "American History", mastery: 30 } returns drillRecommendation with that category
    - computeStudyPlan with no weak categories returns drillRecommendation: null
    - computeStudyPlan with lastMockTestDate 5 days ago and overallMastery 50 returns mockTestRecommended: true
    - computeStudyPlan with lastMockTestDate 1 day ago returns mockTestRecommended: false
    - computeStudyPlan with testDate null returns paceStatus: null, daysRemaining: null
    - computeStudyPlan with testDate and readiness 80, target 90, 50% time elapsed returns paceStatus: "ahead"
    - computeStudyPlan with testDate and readiness 30, target 90, 50% time elapsed returns paceStatus: "behind"
    - computeStudyPlan with daysRemaining <= 0 returns daysRemaining: 0 with all targets clamped (triggers post-test prompt in UI)
    - estimatedMinutes = srsReviewCount * 0.5 + newQuestionTarget * 1.0 + drill count * 1.0 + (mock ? 12 : 0), rounded, min 1
    - No-date mode (testDate: null): newQuestionTarget uses default pacing of ~10/day, SRS due always shown, drill weakest if any below 50%
  </behavior>
  <action>
    **Types file (studyPlanTypes.ts):**
    Create the following types:
    ```typescript
    export type PaceStatus = 'ahead' | 'on-track' | 'behind';

    export interface StudyPlanInput {
      readinessScore: number;           // 0-100 from calculateReadiness
      readinessTarget: number;          // Fixed at 90
      srsDueCount: number;              // From useSRSWidget
      unpracticedCount: number;         // totalQuestions - uniqueQuestionsPracticed
      weakCategories: { name: string; mastery: number }[];  // Below 50% threshold
      testDate: string | null;          // YYYY-MM-DD or null
      lastMockTestDate: string | null;  // YYYY-MM-DD of most recent mock test
      overallMastery: number;           // 0-100 from useCategoryMastery
      now?: Date;                       // Injectable for testing
    }

    export interface DailyPlan {
      srsReviewCount: number;
      newQuestionTarget: number;
      drillRecommendation: { category: string; count: number } | null;
      mockTestRecommended: boolean;
      estimatedMinutes: number;
      paceStatus: PaceStatus | null;    // null when no test date
      daysRemaining: number | null;     // null when no test date
    }
    ```

    **Engine file (studyPlanEngine.ts):**
    Pure function `computeStudyPlan(input: StudyPlanInput): DailyPlan` following these rules:

    1. **Days remaining:** Use UTC-normalized date math (same pattern as determineNBA.ts `daysBetween`). When testDate is null, daysRemaining = null. When <= 0, clamp to 0.

    2. **SRS reviews:** `min(srsDueCount, 20)` -- always show actual due cards, capped at 20.

    3. **New questions:**
       - With date: `clamp(ceil(unpracticedCount / max(daysRemaining, 1)), 3, 15)` when unpracticedCount > 0, else 0.
       - No date: `clamp(unpracticedCount, 0, 10)` as default daily pacing (min 3 if any remain, max 10).
       - When unpracticedCount is 0, return 0.

    4. **Drill recommendation:** Find weakest category from weakCategories array (lowest mastery). If found, recommend 5-10 questions (clamp to available). One drill per day.

    5. **Mock test:** Recommend if lastMockTestDate is null OR >= 3 days ago, AND overallMastery >= 40.

    6. **Estimated time:** `round(srsReviewCount * 0.5 + newQuestionTarget * 1.0 + (drill ? drill.count * 1.0 : 0) + (mock ? 12 : 0))`, min 1.

    7. **Pace status (only when testDate is set):**
       - Calculate time fraction: `elapsedDays / totalDays` where totalDays is from test date set point. Since we don't store start date, use simplified comparison: `readinessFraction = readinessScore / readinessTarget` vs `timeFraction = (totalDays - daysRemaining) / totalDays`. Approximate totalDays as `max(daysRemaining + 14, daysRemaining * 2)` when unknown (conservative estimate that user set date ~2 weeks ago or halfway through).
       - Simpler approach per research: compare `readinessScore / readinessTarget` to `(1 - daysRemaining / max(daysRemaining + 14, 30))`. If readiness fraction > time fraction + 0.05: "ahead". If < time fraction - 0.05: "behind". Else: "on-track".
       - When daysRemaining is 0, return null (post-test state).

    **Barrel export (index.ts):**
    Re-export computeStudyPlan and all types from studyPlanTypes.ts.

    **Test file (studyPlanEngine.test.ts):**
    Write RED tests first covering all behaviors listed above, then implement GREEN. Use injectable `now` parameter for deterministic tests.
  </action>
  <verify>
    <automated>pnpm vitest run src/lib/studyPlan/studyPlanEngine.test.ts -x</automated>
  </verify>
  <done>All unit tests pass. computeStudyPlan is a pure function with zero React dependencies. Handles test-date mode, no-date mode, edge cases (0 days, past dates, capped targets), and pace status calculation.</done>
</task>

<task type="auto">
  <name>Task 2: useTestDate localStorage hook and useStudyPlan composition hook</name>
  <files>src/hooks/useTestDate.ts, src/hooks/useStudyPlan.ts</files>
  <action>
    **useTestDate.ts:**
    Create a custom hook following the LanguageContext/ThemeContext localStorage pattern:

    ```typescript
    const TEST_DATE_KEY = 'civic-prep-test-date';
    const POST_TEST_ACTION_KEY = 'civic-prep-test-date-passed-action';

    export type PostTestAction = 'pending' | 'passed' | 'rescheduled';

    export function useTestDate() {
      // State with SSR-safe initializer reading from localStorage
      const [testDate, setTestDateState] = useState<string | null>(() => {
        if (typeof window === 'undefined') return null;
        return localStorage.getItem(TEST_DATE_KEY);
      });

      const [postTestAction, setPostTestActionState] = useState<PostTestAction>(() => {
        if (typeof window === 'undefined') return 'pending';
        return (localStorage.getItem(POST_TEST_ACTION_KEY) as PostTestAction) ?? 'pending';
      });

      // setTestDate writes to both state and localStorage
      const setTestDate = useCallback((date: string | null) => {
        setTestDateState(date);
        if (date) {
          localStorage.setItem(TEST_DATE_KEY, date);
          // Clear post-test action when new date is set
          localStorage.removeItem(POST_TEST_ACTION_KEY);
          setPostTestActionState('pending');
        } else {
          localStorage.removeItem(TEST_DATE_KEY);
        }
      }, []);

      const setPostTestAction = useCallback((action: PostTestAction) => {
        setPostTestActionState(action);
        localStorage.setItem(POST_TEST_ACTION_KEY, action);
        if (action === 'passed') {
          // Clear test date on pass
          localStorage.removeItem(TEST_DATE_KEY);
          setTestDateState(null);
        }
      }, []);

      return { testDate, setTestDate, postTestAction, setPostTestAction };
    }
    ```

    **useStudyPlan.ts:**
    Composition hook bridging existing data hooks to computeStudyPlan, following the useNextBestAction pattern:

    - Import and call: useTestDate, useReadinessScore, useSRSWidget, useCategoryMastery, useAuth (for testHistory -> lastMockTestDate), useNextBestAction's uniqueQuestionsCount pattern (getAnswerHistory from IndexedDB).
    - Wait for all loading states to resolve.
    - Use useMemo to call computeStudyPlan with assembled input.
    - Return `{ dailyPlan: DailyPlan | null, testDate, setTestDate, postTestAction, setPostTestAction, isLoading }`.
    - For weakCategories: filter categoryMasteries entries where mastery < 50, map to `{ name, mastery }` array.
    - For lastMockTestDate: derive from user.testHistory by sorting descending and taking [0].date, or null.
    - For unpracticedCount: load from getAnswerHistory (same pattern as Dashboard.tsx and useNextBestAction.ts -- cancelled async effect).
    - IMPORTANT: Use the USCIS_CATEGORIES keys (3 main categories) for weak category detection, NOT sub-categories. This matches the readiness engine pattern.
  </action>
  <verify>
    <automated>pnpm vitest run src/lib/studyPlan/ -x && pnpm tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>useTestDate persists test date in localStorage under civic-prep-test-date key. useStudyPlan composes 5+ data sources into computeStudyPlan via useMemo, returning typed DailyPlan. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
1. `pnpm vitest run src/lib/studyPlan/studyPlanEngine.test.ts -x` -- all engine unit tests pass
2. `pnpm tsc --noEmit` -- no TypeScript errors across the project
3. `pnpm vitest run src/lib/studyPlan/ -x` -- all study plan module tests pass
</verification>

<success_criteria>
- computeStudyPlan is a pure function with injectable `now` and zero React dependencies
- All 15+ unit test cases pass covering: SRS due count pass-through, new question distribution and capping, drill recommendation, mock test recommendation, estimated time calculation, pace status (ahead/on-track/behind), no-date mode, edge cases (0 days, past date)
- useTestDate reads/writes localStorage with SSR guard
- useStudyPlan composes useReadinessScore + useSRSWidget + useCategoryMastery + useAuth + IndexedDB data into a single DailyPlan via useMemo
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/44-test-date-countdown-and-study-plan/44-01-SUMMARY.md`
</output>
