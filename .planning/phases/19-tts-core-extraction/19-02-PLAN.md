---
phase: 19-tts-core-extraction
plan: 02
type: tdd
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/lib/ttsCore.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests cover all standalone exports: findVoice, estimateDuration, loadVoices, getPreferredVoice, safeSpeak"
    - "Unit tests cover engine lifecycle: createTTSEngine speak/cancel/pause/resume/destroy"
    - "Unit tests cover error paths: TTSCancelledError, TTSUnsupportedError, retry logic"
    - "Unit tests cover Chrome 15-second bug workaround (chunking behavior)"
    - "All tests pass via npx vitest run"
  artifacts:
    - path: "src/lib/ttsCore.test.ts"
      provides: "Comprehensive unit test suite for ttsCore module"
      min_lines: 300
  key_links:
    - from: "src/lib/ttsCore.test.ts"
      to: "src/lib/ttsCore.ts"
      via: "imports all public exports"
      pattern: "import.*from.*ttsCore"
    - from: "src/lib/ttsCore.test.ts"
      to: "src/lib/ttsTypes.ts"
      via: "imports error classes and types for assertions"
      pattern: "import.*TTSCancelledError|TTSUnsupportedError.*from.*ttsTypes"
---

<objective>
Write comprehensive unit tests for the ttsCore module covering all public exports, engine lifecycle, error handling, and cross-browser workaround behavior.

Purpose: Ensure the foundation module is rock-solid before building hooks and consumers on top. Catch regressions early. Verify all 12 cross-browser pitfalls are properly handled.

Output: `src/lib/ttsCore.test.ts` with ~35-40 test cases, all passing.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-RESEARCH.md
@.planning/phases/19-tts-core-extraction/19-01-SUMMARY.md
@src/lib/ttsCore.ts
@src/lib/ttsTypes.ts
@src/__tests__/shuffle.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manual speechSynthesis mock and test infrastructure</name>
  <files>src/lib/ttsCore.test.ts</files>
  <action>
Create `src/lib/ttsCore.test.ts` (co-located with source per locked decision).

**Mock setup (top of file, in beforeEach):**
Create a manual mock `speechSynthesis` object on `globalThis.speechSynthesis` with:
- `speak(utterance)`: Store utterance, schedule `onend` callback via `setTimeout(0)` to simulate async completion (async by default per locked decision). Track calls.
- `cancel()`: If stored utterance, fire `onend` (or `onerror` with 'canceled' for Safari test). Clear state.
- `pause()`: Set paused flag.
- `resume()`: Clear paused flag.
- `getVoices()`: Return mock voice array (simulate delayed voiceschanged for some tests).
- `onvoiceschanged`: Property (not addEventListener -- matching real Safari behavior).
- `speaking`: Boolean getter.
- `paused`: Boolean getter.
- `pending`: Boolean getter.

**Mock voice factory:** Helper function `createMockVoice(overrides)` returning `SpeechSynthesisVoice`-shaped object with defaults: `{ name: 'Samantha', lang: 'en-US', voiceURI: 'samantha', localService: true, default: false }`.

**Mock SpeechSynthesisUtterance:** Mock `globalThis.SpeechSynthesisUtterance` as a class with `text`, `lang`, `rate`, `pitch`, `voice`, `volume` properties and `onend`, `onerror`, `onstart`, `onpause`, `onresume` event handlers.

Use `vi.useFakeTimers()` for timeout-related tests. Reset in afterEach. Clean up globalThis mocks in afterAll.
  </action>
  <verify>File structure is valid. No syntax errors.</verify>
  <done>Test infrastructure is in place with comprehensive speechSynthesis mocking.</done>
</task>

<task type="auto">
  <name>Task 2: Write all test suites (~35-40 test cases)</name>
  <files>src/lib/ttsCore.test.ts</files>
  <action>
Add the following test suites to the file created in Task 1:

**Suite: `findVoice`** (~7 tests)
- Returns null for empty voice array
- Finds preferred voice by name
- Falls back to Apple US voices in priority order
- Falls back to Android US voices
- Falls back to Edge voices (new EDGE_VOICES constant)
- Falls back to enhanced/premium hints
- Normalizes Android underscore lang format (`en_US` -> `en-US` matching)
- `preferLocal: true` prefers local voices over remote
- Firefox fallback: returns any English voice when no known names match, then any voice

**Suite: `estimateDuration`** (~3 tests)
- Correct formula: short text at normal rate
- Correct formula: long text at fast rate
- Returns at least 3000ms buffer for any input

**Suite: `loadVoices`** (~4 tests)
- Returns cached voices on second call
- Polls and resolves when voices become available after delay
- Resolves with empty array after max retries
- Uses onvoiceschanged property (not addEventListener)

**Suite: `createTTSEngine`** (~12 tests)
- `isSupported()` returns true when speechSynthesis exists
- `isSupported()` returns false when speechSynthesis missing
- `speak()` resolves when speech completes (onend fires)
- `speak()` auto-cancels previous active speech
- `speak()` rejects with TTSUnsupportedError when not supported
- `cancel()` causes active speak() to reject with TTSCancelledError
- State updates: isSpeaking true during speech, false after
- State updates: isPaused toggles with pause/resume
- `onStateChange` callback fires on state transitions, returns unsubscribe function
- `setDefaults()` updates engine defaults for subsequent speak calls
- `destroy()` cancels speech and prevents future speak() calls
- Timeout fallback resolves promise when onend never fires (use fake timers to advance past estimated duration)

**Suite: `Chrome 15s workaround`** (~3 tests)
- Text over 30 words is chunked into multiple utterances
- All chunks speak sequentially (second chunk starts after first ends)
- Single promise resolves only after all chunks complete

**Suite: `safeSpeak`** (~4 tests)
- Returns 'completed' on successful speech
- Returns 'cancelled' when speech is cancelled
- Returns 'error' on TTSUnsupportedError
- Returns 'error' on unexpected errors (never throws)

**Suite: `error handling`** (~4 tests)
- Safari cancel error ('canceled'/'interrupted') treated as TTSCancelledError, not generic error
- One automatic retry on non-cancellation failure
- Double-fire guard: promise settles exactly once even if both onend and timeout fire
- TTSCancelledError and TTSUnsupportedError are proper Error subclasses (instanceof checks)

**Test patterns:**
- Use `vi.useFakeTimers()` for timeout and retry tests. Call `vi.advanceTimersByTime()` to trigger timeouts.
- For async speech completion, mock onend firing via `setTimeout(() => utterance.onend?.(), 0)` in the mock speak().
- For chunking tests, provide text with 40+ words and verify multiple speak() calls on the mock.
- Use `vi.spyOn()` where needed for call counting.
- Wrap async tests in proper `async/await` with `await vi.runAllTimersAsync()` for timer-dependent tests.
  </action>
  <verify>Run `npx vitest run src/lib/ttsCore.test.ts`. All tests pass. Zero failures, zero skips.</verify>
  <done>~35-40 test cases all pass. Full coverage of standalone utilities, engine lifecycle, error paths, chunking, and safeSpeak.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/lib/ttsCore.test.ts` -- all tests pass
2. Test count is in the 35-40 range
3. No skipped tests (`.skip` or `.todo`)
4. Coverage of all public exports verified by grep of import statements
</verification>

<success_criteria>
- All ~35-40 test cases pass green
- Tests cover: findVoice (7+), estimateDuration (3+), loadVoices (4+), createTTSEngine (12+), Chrome 15s (3+), safeSpeak (4+), error handling (4+)
- Manual speechSynthesis mock is async by default (simulates real browser behavior)
- Chunking workaround has dedicated test cases
- Error subclass instanceof assertions verify proper error hierarchy
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-02-SUMMARY.md`
</output>
