---
phase: 38-security-analysis-fixes-and-codebase-refactoring-based-on-learnings-and-error-history
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/async/withRetry.ts
  - src/lib/async/withRetry.test.ts
  - src/lib/async/safeAsync.ts
  - src/lib/async/safeAsync.test.ts
  - src/lib/async/index.ts
autonomous: true
requirements: [CONTEXT-withRetry-utility, CONTEXT-safeAsync-utility, CONTEXT-silent-retry]

must_haves:
  truths:
    - "withRetry retries failed async operations up to 3 times with exponential backoff"
    - "withRetry does NOT retry non-retryable errors (401, 400, QuotaExceededError)"
    - "safeAsync catches errors and returns a result tuple without throwing"
    - "safeAsync reports errors to Sentry via captureError"
    - "Both utilities are exported from a clean barrel file"
  artifacts:
    - path: "src/lib/async/withRetry.ts"
      provides: "Generic retry wrapper with exponential backoff"
      exports: ["withRetry", "isRetryableError"]
    - path: "src/lib/async/withRetry.test.ts"
      provides: "Comprehensive tests for retry behavior"
      min_lines: 50
    - path: "src/lib/async/safeAsync.ts"
      provides: "Safe async wrapper with Sentry reporting"
      exports: ["safeAsync"]
    - path: "src/lib/async/safeAsync.test.ts"
      provides: "Tests for safe async error handling"
      min_lines: 30
    - path: "src/lib/async/index.ts"
      provides: "Barrel export"
      exports: ["withRetry", "safeAsync", "isRetryableError"]
  key_links:
    - from: "src/lib/async/safeAsync.ts"
      to: "src/lib/sentry.ts"
      via: "captureError import"
      pattern: "import.*captureError.*from.*sentry"
---

<objective>
Build the shared withRetry and safeAsync utilities using TDD — the foundation for standardizing error handling across all async operations.

Purpose: The codebase has 12+ catch blocks that swallow errors with console.error only. These utilities provide the standard patterns that Plan 04 will wire into contexts and hooks.
Output: Tested withRetry and safeAsync utilities ready for integration
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-security-analysis-fixes-and-codebase-refactoring-based-on-learnings-and-error-history/38-RESEARCH.md
@src/lib/sentry.ts
</context>

<feature>
  <name>withRetry — Generic Async Retry Utility</name>
  <files>src/lib/async/withRetry.ts, src/lib/async/withRetry.test.ts</files>
  <behavior>
    withRetry wraps an async function and retries it on failure with exponential backoff.

    Cases:
    - fn succeeds first try → returns result immediately, no delay
    - fn fails once then succeeds → retries after baseDelayMs, returns result
    - fn fails 3 times → throws the last error after all attempts exhausted
    - fn throws TypeError('Failed to fetch') → retries (network error)
    - fn throws 401 Response error → does NOT retry (auth failure)
    - fn throws DOMException('QuotaExceededError') → does NOT retry
    - fn throws with !navigator.onLine → retries
    - Custom shouldRetry returns false → does NOT retry
    - onRetry callback is called with (attempt, error) on each retry
    - Delay doubles each attempt: 1000, 2000, 4000 (with baseDelayMs=1000)

    Interface:
    ```typescript
    interface RetryOptions {
      maxAttempts?: number;      // Default: 3
      baseDelayMs?: number;      // Default: 1000
      onRetry?: (attempt: number, error: unknown) => void;
      shouldRetry?: (error: unknown) => boolean;
    }
    function withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>;
    function isRetryableError(error: unknown): boolean;
    ```
  </behavior>
  <implementation>
    Create `src/lib/async/withRetry.ts` per the RESEARCH.md pattern.
    Export both `withRetry` and `isRetryableError` (the latter for reuse in other modules).
    Use `vi.useFakeTimers()` in tests to avoid real delays.
  </implementation>
</feature>

<feature>
  <name>safeAsync — Error-Catching Async Wrapper</name>
  <files>src/lib/async/safeAsync.ts, src/lib/async/safeAsync.test.ts</files>
  <behavior>
    safeAsync wraps an async function, catches all errors, reports to Sentry, and returns a result tuple.

    Cases:
    - fn succeeds → returns [result, null]
    - fn throws Error → returns [null, Error], reports to Sentry with context
    - fn throws string → returns [null, Error] (wraps string in Error), reports to Sentry
    - fn throws with context string → Sentry receives { operation: context }
    - fn throws without context → Sentry receives undefined extras

    Interface:
    ```typescript
    type SafeResult<T> = [T, null] | [null, Error];
    function safeAsync<T>(fn: () => Promise<T>, context?: string): Promise<SafeResult<T>>;
    ```
  </behavior>
  <implementation>
    Create `src/lib/async/safeAsync.ts` per the RESEARCH.md pattern.
    Import `captureError` from `@/lib/sentry` — check actual export name in sentry.ts first.
    If sentry.ts doesn't export `captureError`, use `Sentry.captureException` directly from `@sentry/nextjs`.
    Mock Sentry in tests via `vi.mock`.
    Create `src/lib/async/index.ts` barrel exporting both utilities.
  </implementation>
</feature>

<verification>
- `npm run test:run -- src/lib/async/` — all tests pass
- `npm run typecheck` — no type errors
- `npm run lint` — no lint errors
</verification>

<success_criteria>
- withRetry retries network errors with exponential backoff and throws on non-retryable errors
- safeAsync catches all errors, reports to Sentry, and returns result tuples
- All test cases from behavior specs pass
- Both utilities exported from barrel file
</success_criteria>

<output>
After completion, create `.planning/phases/38-security-analysis-fixes-and-codebase-refactoring-based-on-learnings-and-error-history/38-02-SUMMARY.md`
</output>
