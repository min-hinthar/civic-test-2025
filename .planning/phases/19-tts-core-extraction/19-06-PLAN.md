---
phase: 19-tts-core-extraction
plan: 06
type: execute
wave: 4
depends_on: ["19-04", "19-05"]
files_modified:
  - src/AppShell.tsx
  - src/styles/globals.css
  - src/__tests__/tts.integration.test.tsx
  - src/hooks/useInterviewTTS.ts
  - src/lib/useSpeechSynthesis.ts
autonomous: true

must_haves:
  truths:
    - "TTSProvider is wired into AppShell after LanguageProvider and before StateProvider"
    - "Integration test renders SpeechButton inside TTSProvider and verifies speak() plumbing"
    - "Old hooks (useInterviewTTS.ts, useSpeechSynthesis.ts) are deleted entirely"
    - "Zero references to useInterviewTTS or useSpeechSynthesis remain in the codebase (grep clean)"
    - "Project builds successfully (npm run build) and all tests pass (npx vitest run)"
  artifacts:
    - path: "src/__tests__/tts.integration.test.tsx"
      provides: "Integration tests for TTSProvider + SpeechButton plumbing"
      min_lines: 40
    - path: "src/AppShell.tsx"
      provides: "Updated app shell with TTSProvider in provider tree"
  key_links:
    - from: "src/AppShell.tsx"
      to: "src/contexts/TTSContext.tsx"
      via: "dynamic import for lazy-loaded TTSProvider"
      pattern: "TTSProvider|LazyTTSProvider"
    - from: "src/__tests__/tts.integration.test.tsx"
      to: "src/contexts/TTSContext.tsx"
      via: "renders TTSProvider in test"
      pattern: "TTSProvider"
    - from: "src/__tests__/tts.integration.test.tsx"
      to: "src/components/ui/SpeechButton.tsx"
      via: "renders SpeechButton and verifies interactions"
      pattern: "SpeechButton"
---

<objective>
Wire TTSProvider into the app, write integration tests, delete old hooks, and perform a full codebase cleanup to ensure zero references to the old TTS system remain.

Purpose: This is the final "tie it all together" plan. Provider wiring makes the new TTS system live. Integration tests verify end-to-end plumbing. Old hook deletion and grep cleanup ensure no stale code remains. The build and test verification confirms zero regressions.

Output: Updated AppShell.tsx, integration test file, deleted old hooks, clean build.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-03-SUMMARY.md
@.planning/phases/19-tts-core-extraction/19-04-SUMMARY.md
@.planning/phases/19-tts-core-extraction/19-05-SUMMARY.md
@src/AppShell.tsx
@src/contexts/TTSContext.tsx
@src/hooks/useTTS.ts
@src/components/ui/SpeechButton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire TTSProvider into AppShell and add TTS CSS custom properties</name>
  <files>src/AppShell.tsx, src/styles/globals.css</files>
  <action>
**AppShell.tsx updates:**

1. Add import (using dynamic import for code splitting per locked decision):
```ts
import dynamic from 'next/dynamic';
const TTSProvider = dynamic(
  () => import('@/contexts/TTSContext').then(m => ({ default: m.TTSProvider })),
  { ssr: false }
);
```

2. Insert TTSProvider into the provider tree at the correct position: **after LanguageProvider, before StateProvider** (per locked decision).

Current provider nesting order in AppShell:
```
ErrorBoundary > LanguageProvider > ThemeProvider > ToastProvider > OfflineProvider > AuthProvider > SocialProvider > SRSProvider > StateProvider > Router > ...
```

Insert TTSProvider after ThemeProvider (needs theme for color) and before StateProvider:
```
ErrorBoundary > LanguageProvider > ThemeProvider > TTSProvider > ToastProvider > OfflineProvider > AuthProvider > SocialProvider > SRSProvider > StateProvider > Router > ...
```

Wait -- the locked decision says "after LanguageProvider, before StateProvider". ThemeProvider is between them. TTSProvider needs to be anywhere in that range. Put it after ThemeProvider so it has access to theme context for potential future use:

```tsx
<LanguageProvider>
  <ThemeProvider>
    <TTSProvider>      {/* NEW */}
      <ToastProvider>
        <OfflineProvider>
          <AuthProvider>
            <SocialProvider>
              <SRSProvider>
                <StateProvider>
                  ...
```

Since TTSProvider is lazy-loaded with `ssr: false`, it will render null on server and children immediately on client (the dynamic import returns a component that renders children while loading the actual provider). This matches the locked decision of "render children immediately (optimistic)".

**NOTE on dynamic import:** `next/dynamic` with `ssr: false` renders nothing on server. But TTSProvider needs to render children on server for SSR/hydration. The solution: use a simple wrapper that renders children immediately and only creates the engine client-side (this is already handled in the TTSProvider implementation from Plan 03). So we might not need `dynamic` at all -- the provider itself has SSR guards.

Actually, the simplest approach: just import TTSProvider normally and let its internal SSR guards handle it. The "lazy-load provider only" locked decision means the provider module itself should be lazy. But with Next.js Pages Router, the entire AppShell is client-only (`isClient` gate). So just import normally:

```ts
import { TTSProvider } from '@/contexts/TTSContext';
```

This is sufficient since AppShell already has a client-only gate (`if (!isClient) return null`).

**globals.css updates:**

Add TTS color custom properties and pulse animation:

```css
/* TTS speaking state color */
:root {
  --color-tts: 250 70% 55%;
}

.dark {
  --color-tts: 250 80% 70%;
}

/* TTS speaking pulse animation */
@keyframes pulse-subtle {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.animate-pulse-subtle {
  animation: pulse-subtle 2s ease-in-out infinite;
}
```

Also add Tailwind utility classes for the TTS color. Check if the project uses `tailwind.config` extend -- if so, add `tts: 'hsl(var(--color-tts))'` to the colors. Otherwise, SpeechButton can use `text-[hsl(var(--color-tts))]` / `border-[hsl(var(--color-tts))]` arbitrary value syntax.

Check tailwind.config.ts and add `tts` color if extend pattern is used. If the project uses CSS variables directly (check globals.css for pattern), add the utility classes there.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run build`. The build must succeed -- this confirms the provider is wired correctly and no import cycles exist.</verify>
  <done>TTSProvider wired into AppShell provider tree. TTS color custom properties and pulse animation added to globals.css. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests and delete old hooks</name>
  <files>src/__tests__/tts.integration.test.tsx, src/hooks/useInterviewTTS.ts, src/lib/useSpeechSynthesis.ts</files>
  <action>
**Integration test (`src/__tests__/tts.integration.test.tsx`):**

Create integration test that renders SpeechButton inside TTSProvider and verifies the plumbing works end-to-end.

Mock setup: Same speechSynthesis mock as unit tests (can import a shared helper or duplicate minimal mock).

Test cases (~5-6):
1. **SpeechButton renders and is enabled** -- render `<TTSProvider><SpeechButton text="Hello" label="Listen" /></TTSProvider>`, verify button is not disabled.
2. **Click triggers speech** -- click button, verify `speechSynthesis.speak` was called with correct text.
3. **Click while speaking cancels** -- click once (starts speaking), set isSpeaking mock, click again, verify `speechSynthesis.cancel` called.
4. **Button disabled when no text** -- render with `text=""`, verify button is disabled.
5. **Button shows correct aria-label** -- verify `aria-label` is "Listen" by default, changes when speaking.
6. **Provider renders children without engine** -- render provider, verify children mount immediately even before engine is ready.

Use `@testing-library/react` `render`, `screen`, `fireEvent` / `userEvent`.

Remember to mock `SpeechSynthesisUtterance` on globalThis as well.

**Delete old hooks:**

1. Delete `src/hooks/useInterviewTTS.ts` entirely.
2. Delete `src/lib/useSpeechSynthesis.ts` entirely.

**Full codebase grep cleanup:**

After deletion, run these checks to ensure no stale references:
- `grep -r "useInterviewTTS" src/` -- must return zero (excluding planning files)
- `grep -r "useSpeechSynthesis" src/` -- must return zero (excluding planning files)
- `grep -r "from.*useInterviewTTS" src/` -- zero
- `grep -r "from.*useSpeechSynthesis" src/` -- zero
- `grep -r "SPEECH_RATE_KEY" src/` -- zero (old constant, now handled by provider migration)
- `grep -r "civic-prep-speech-rate" src/` -- only in TTSContext.tsx migration code

If any stale references found, fix them by updating imports to use `useTTS` or `ttsCore` as appropriate.

**Final verification:**
- `npx tsc --noEmit` -- zero type errors (confirms no broken imports from deleted files)
- `npm run lint` -- zero lint errors
- `npx vitest run` -- ALL tests pass (unit + integration)
- `npm run build` -- clean build
  </action>
  <verify>
Run all four checks in sequence:
1. `npx tsc --noEmit` -- zero errors
2. `npm run lint` -- zero errors
3. `npx vitest run` -- all tests pass
4. `npm run build` -- clean build
Then grep for old hook names to confirm zero stale references.
  </verify>
  <done>Integration tests pass. Old hooks deleted. Zero stale references to useInterviewTTS or useSpeechSynthesis in source code. Full build and test suite green.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run lint` passes
3. `npx vitest run` -- ALL tests pass (unit + integration, including existing 14 test files)
4. `npm run build` -- clean build with zero errors
5. `grep -r "useInterviewTTS\|useSpeechSynthesis" src/ --include="*.ts" --include="*.tsx"` returns zero matches
6. `src/hooks/useInterviewTTS.ts` does not exist
7. `src/lib/useSpeechSynthesis.ts` does not exist
8. TTSProvider is in AppShell provider tree
9. Integration tests verify SpeechButton + TTSProvider end-to-end
</verification>

<success_criteria>
- TTSProvider wired into AppShell after LanguageProvider/ThemeProvider, before StateProvider
- TTS CSS custom properties added (color + animation)
- Integration tests pass: SpeechButton renders, clicks trigger speech, toggle works, ARIA correct
- Old hooks deleted: useInterviewTTS.ts and useSpeechSynthesis.ts removed from disk
- Zero stale references to old hooks anywhere in src/
- All existing tests still pass (no regressions)
- Clean build (npm run build succeeds)
- This plan completes the full phase -- all TTS logic consolidated
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-06-SUMMARY.md`
</output>
