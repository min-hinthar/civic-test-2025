---
phase: 32-celebration-system-elevation
plan: 05
type: execute
wave: 2
depends_on:
  - 32-01
  - 32-02
  - 32-03
files_modified:
  - src/hooks/useCelebration.ts
  - src/components/celebrations/CelebrationOverlay.tsx
  - src/components/celebrations/index.ts
  - src/AppShell.tsx
autonomous: true
requirements:
  - CELB-02
  - CELB-05

must_haves:
  truths:
    - "Calling celebrate(level) from any component triggers correct intensity of confetti, sound, and haptics via single hook API"
    - "Multiple simultaneous celebrations queue and play sequentially with ~300ms gap"
    - "A tiny queue counter pill shows remaining celebrations"
    - "Haptic patterns fire at celebration peaks synchronized with confetti and sound"
    - "Brief blocking overlay during peak (~1-2s), then non-blocking for fade-out"
    - "First-time milestone occurrences get elevated celebrations"
    - "Reduced motion: no confetti, no scale, no DotLottie -- only color changes and sound"
  artifacts:
    - path: "src/hooks/useCelebration.ts"
      provides: "celebrate() function and CelebrationLevel types via DOM CustomEvents"
      exports: ["celebrate", "useCelebrationListener", "CelebrationLevel", "CelebrationDetail"]
    - path: "src/components/celebrations/CelebrationOverlay.tsx"
      provides: "Global overlay rendering queued celebrations with confetti, DotLottie, sound, haptics"
      contains: "useCelebrationListener"
    - path: "src/AppShell.tsx"
      provides: "CelebrationOverlay mounted at app root"
      contains: "CelebrationOverlay"
  key_links:
    - from: "src/hooks/useCelebration.ts"
      to: "window.dispatchEvent"
      via: "DOM CustomEvent dispatch"
      pattern: "CustomEvent.*civic:celebrate"
    - from: "src/components/celebrations/CelebrationOverlay.tsx"
      to: "src/hooks/useCelebration.ts"
      via: "useCelebrationListener for event subscription"
      pattern: "useCelebrationListener"
    - from: "src/components/celebrations/CelebrationOverlay.tsx"
      to: "src/components/celebrations/Confetti.tsx"
      via: "Renders Confetti component for visual effect"
      pattern: "Confetti"
    - from: "src/components/celebrations/CelebrationOverlay.tsx"
      to: "src/lib/audio/celebrationSounds.ts"
      via: "Plays celebration sounds at peak"
      pattern: "playCelebrationSequence"
    - from: "src/components/celebrations/CelebrationOverlay.tsx"
      to: "src/lib/haptics.ts"
      via: "Fires haptics at celebration peaks"
      pattern: "haptic"
---

<objective>
Build the useCelebration hook with DOM CustomEvents and CelebrationOverlay with queued celebration playback, combining confetti, DotLottie, sound, and haptics.

Purpose: CELB-02 creates the central orchestration layer -- a single `celebrate(level)` call from any component triggers a coordinated multi-sensory celebration. CELB-05 wires haptic patterns into the celebration stages. This is the connective tissue between all individual celebration pieces built in Wave 1.
Output: useCelebration.ts hook, CelebrationOverlay.tsx component mounted in AppShell.
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-celebration-system-elevation/32-RESEARCH.md

@.planning/phases/32-celebration-system-elevation/32-01-SUMMARY.md
@.planning/phases/32-celebration-system-elevation/32-02-SUMMARY.md
@.planning/phases/32-celebration-system-elevation/32-03-SUMMARY.md

@src/AppShell.tsx
@src/hooks/useCelebration.ts
@src/components/celebrations/Confetti.tsx
@src/components/celebrations/index.ts
@src/lib/audio/celebrationSounds.ts
@src/lib/haptics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useCelebration hook with DOM CustomEvent bus</name>
  <files>src/hooks/useCelebration.ts</files>
  <action>
Create `src/hooks/useCelebration.ts` implementing the DOM CustomEvent celebration bus (CELB-02):

1. **Types**:
   ```typescript
   export type CelebrationLevel = 'sparkle' | 'burst' | 'celebration' | 'ultimate';

   export interface CelebrationDetail {
     level: CelebrationLevel;
     source: string;           // "streak-5", "test-pass", "badge-earned", "100-percent", etc.
     isFirstTime?: boolean;    // First occurrence gets elevated celebration
     isDarkMode?: boolean;     // For color palette selection in confetti
     metadata?: Record<string, unknown>; // Extra data (category for star burst, etc.)
   }
   ```

2. **Event constant**: `const CELEBRATION_EVENT = 'civic:celebrate';`

3. **celebrate() function** (module-level, not a hook):
   ```typescript
   export function celebrate(detail: CelebrationDetail): void {
     window.dispatchEvent(
       new CustomEvent(CELEBRATION_EVENT, { detail })
     );
   }
   ```
   This is called from components like: `celebrate({ level: 'burst', source: 'test-pass' })`.

4. **useCelebrationListener hook**:
   ```typescript
   export function useCelebrationListener(
     callback: (detail: CelebrationDetail) => void
   ): void {
     useEffect(() => {
       const handler = (e: Event) => {
         callback((e as CustomEvent<CelebrationDetail>).detail);
       };
       window.addEventListener(CELEBRATION_EVENT, handler);
       return () => window.removeEventListener(CELEBRATION_EVENT, handler);
     }, [callback]);
   }
   ```

5. **First-time tracking** helper:
   ```typescript
   const FIRST_TIME_KEY = 'civic-first-celebrations';

   export function isFirstTimeCelebration(source: string): boolean {
     try {
       const stored = JSON.parse(localStorage.getItem(FIRST_TIME_KEY) ?? '{}');
       if (stored[source]) return false;
       stored[source] = true;
       localStorage.setItem(FIRST_TIME_KEY, JSON.stringify(stored));
       return true;
     } catch {
       return false;
     }
   }
   ```
   The CelebrationOverlay checks `isFirstTime` and applies elevated celebration if true.

NOTE: This is NOT a Context provider -- it's a plain module with CustomEvent dispatch. No provider nesting required. The CelebrationOverlay listens globally.
  </action>
  <verify>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. `celebrate` and `useCelebrationListener` are exported
4. No React Context created -- pure CustomEvent pattern
  </verify>
  <done>
- celebrate() dispatches CustomEvent with typed CelebrationDetail
- useCelebrationListener subscribes to events with cleanup
- isFirstTimeCelebration tracks first occurrences in localStorage
- No Context provider added to provider tree
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CelebrationOverlay with queue, confetti, DotLottie, sound, and haptics</name>
  <files>src/components/celebrations/CelebrationOverlay.tsx, src/components/celebrations/index.ts, src/AppShell.tsx</files>
  <action>
Create `CelebrationOverlay.tsx` that orchestrates all celebration sensory channels (CELB-02 + CELB-05):

1. **Queue management**:
   - `const [queue, setQueue] = useState<CelebrationDetail[]>([])` for pending celebrations
   - `const [current, setCurrent] = useState<CelebrationDetail | null>(null)` for active celebration
   - `useCelebrationListener(useCallback((detail) => { ... }, []))` to enqueue incoming celebrations
   - When `current` is null and queue has items, dequeue the first item into `current`
   - When current celebration completes, wait 300ms, then dequeue next (or clear if empty)
   - Show a tiny "N more" pill when `queue.length > 0` during active celebration (positioned bottom-right corner, small text, semi-transparent background)

2. **Celebration orchestration** per level:
   Map `current.level` to intensity:
   - `sparkle`: Confetti intensity="sparkle" + hapticLight() + no DotLottie
   - `burst`: Confetti intensity="burst" + hapticMedium() + DotLottie checkmark (if available) + playConfettiBurst()
   - `celebration`: Confetti intensity="celebration" + hapticHeavy() + DotLottie trophy + playPassReveal()
   - `ultimate`: Confetti intensity="celebration" (with gold accent colors) + hapticHeavy() (x2, 200ms apart) + DotLottie trophy + playUltimateFanfare() + subtle screen shake (100-200ms via CSS transform on wrapper)

   For `isFirstTime` celebrations: increase one tier (sparkle->burst, burst->celebration). Ultimate stays ultimate.

3. **Blocking overlay**:
   - During peak moment (first ~1-2 seconds), render a fixed full-screen overlay with `pointer-events: auto` and subtle dark backdrop (`bg-black/10`)
   - After peak, switch to `pointer-events: none` for fade-out (confetti settling)
   - Use `setTimeout` to switch from blocking to non-blocking after the peak duration
   - Peak durations by level: sparkle=800ms, burst=1200ms, celebration=2000ms, ultimate=2500ms

4. **Confetti rendering**:
   - Render the upgraded `Confetti` component from Plan 01
   - Pass `isDarkMode` from detail for color palette selection
   - `fire={current !== null}` with `intensity` mapped from level
   - `onComplete` triggers celebration complete flow

5. **DotLottie rendering** (if available):
   - Conditionally render `DotLottieAnimation` for burst/celebration/ultimate
   - Position: fixed centered, 200px for trophy/star-burst, 80px for checkmark
   - `onComplete` is NOT blocking -- if DotLottie fails to load, celebration continues

6. **Sound + Haptics firing** (CELB-05):
   - Fire at celebration start (peak moment):
     - `sparkle`: hapticLight()
     - `burst`: hapticMedium() + playConfettiBurst()
     - `celebration`: hapticHeavy() + playPassReveal()
     - `ultimate`: hapticHeavy() + 200ms later hapticHeavy() again + playUltimateFanfare()
   - Sound and haptics fire simultaneously (same tick, per user decision)
   - All haptic calls from event handlers / callbacks (React Compiler safe)

7. **Screen shake for ultimate** (100% perfect score only):
   - Apply CSS animation to the overlay wrapper: `@keyframes shake { ... }` with translateX(-2px/2px) for 100-200ms
   - Only for `ultimate` level
   - Respect reduced motion: skip shake

8. **Reduced motion**:
   - No Confetti render, no DotLottie render, no scale animations, no screen shake
   - Sound still plays (per user decision)
   - Haptics still fire
   - Brief text-based acknowledgment (optional, or just skip visual entirely)

9. **Surprise variations** (per user decision for 2-3 rare elements):
   - 5% chance: confetti includes a single flag emoji shape via `shapeFromText`
   - 5% chance: celebration sound includes an extra sparkle note at the end
   - These are small Easter eggs that keep celebrations fresh

10. **Mount in AppShell.tsx**:
    - Add `<CelebrationOverlay />` inside the provider tree but OUTSIDE NavigationShell (so it overlays everything)
    - Position it after the main app content, before the closing providers
    - It's a singleton -- only one instance in the entire app

Update `src/components/celebrations/index.ts` to export `CelebrationOverlay`.

IMPORTANT: No new Context provider. CelebrationOverlay is a self-contained component that listens for DOM events.

IMPORTANT: Use `useCallback` for the celebration listener to avoid re-subscribing on every render.

IMPORTANT: The `setTimeout` for blocking -> non-blocking transition should use `useRef` to store the timeout ID for cleanup on unmount.
  </action>
  <verify>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. `npm run build` succeeds
4. CelebrationOverlay is rendered in AppShell.tsx
5. No new Context provider in provider tree
6. Queue management works: multiple celebrations play sequentially
7. Haptics fire at celebration peaks
  </verify>
  <done>
- CelebrationOverlay renders globally in AppShell
- Queue system plays celebrations sequentially with 300ms gap
- "N more" pill shows during queued celebrations
- Each level triggers correct combination of confetti + sound + haptics + DotLottie
- First-time celebrations get elevated intensity
- Brief blocking overlay during peak, then non-blocking fade
- Ultimate has screen shake (reduced motion: skipped)
- 2-3 rare surprise variations for freshness
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck && npm run lint && npm run build` all pass
- CelebrationOverlay is in AppShell provider tree
- `celebrate()` can be called from any component
- Multiple simultaneous celebrations queue properly
- Haptics synchronized with confetti and sound at peaks
</verification>

<success_criteria>
- Single celebrate(level) API triggers coordinated confetti + sound + haptics
- Celebration queue prevents overlapping effects
- First-time milestones get elevated celebration
- Blocking overlay during peak, non-blocking for fade
- No new Context provider -- pure CustomEvent bus
</success_criteria>

<output>
After completion, create `.planning/phases/32-celebration-system-elevation/32-05-SUMMARY.md`
</output>
