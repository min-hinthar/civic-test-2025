---
phase: 19-tts-core-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ttsTypes.ts
  - src/lib/ttsCore.ts
autonomous: true

must_haves:
  truths:
    - "A ttsTypes.ts file exports all TTS type definitions, error classes, voice constants, and the TTSEngine interface"
    - "A ttsCore.ts file exports createTTSEngine() factory, findVoice(), estimateDuration(), loadVoices(), getPreferredVoice(), and safeSpeak()"
    - "createTTSEngine().speak() returns Promise<void> that resolves on completion and rejects with typed errors"
    - "Engine handles Chrome 15-second bug transparently via sentence-aware chunking + pause/resume cycling (with Android exception)"
    - "safeSpeak() returns Promise<'completed' | 'cancelled' | 'error'> and never throws"
  artifacts:
    - path: "src/lib/ttsTypes.ts"
      provides: "TTS type system: interfaces, error classes, voice constants"
      exports: ["TTSEngine", "TTSState", "TTSSettings", "SpeakOptions", "TTSCancelledError", "TTSUnsupportedError", "APPLE_US_VOICES", "ANDROID_US_VOICES", "EDGE_VOICES", "ENHANCED_HINTS"]
    - path: "src/lib/ttsCore.ts"
      provides: "TTS engine factory and standalone utilities"
      exports: ["createTTSEngine", "findVoice", "estimateDuration", "loadVoices", "getPreferredVoice", "safeSpeak"]
  key_links:
    - from: "src/lib/ttsCore.ts"
      to: "src/lib/ttsTypes.ts"
      via: "imports all types and constants"
      pattern: "import.*from.*ttsTypes"
    - from: "src/lib/ttsCore.ts"
      to: "window.speechSynthesis"
      via: "browser Speech API"
      pattern: "speechSynthesis\\.(speak|cancel|pause|resume|getVoices)"
---

<objective>
Create the foundational TTS types file and core engine module that all other TTS code will build upon.

Purpose: Establish the complete ttsCore API surface (factory + standalone utilities) with all cross-browser workarounds, error handling, and promise-based speech. This is the single source of truth that eliminates duplicated voice-finding logic across the codebase.

Output: Two files -- `src/lib/ttsTypes.ts` (types, error classes, voice constants) and `src/lib/ttsCore.ts` (engine factory + utilities).
</objective>

<execution_context>
@C:/Users/minkk/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/minkk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-tts-core-extraction/19-CONTEXT.md
@.planning/phases/19-tts-core-extraction/19-RESEARCH.md
@src/hooks/useInterviewTTS.ts
@src/lib/useSpeechSynthesis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TTS types, error classes, and voice constants</name>
  <files>src/lib/ttsTypes.ts</files>
  <action>
Create `src/lib/ttsTypes.ts` with the following exports:

**Error classes (custom Error subclasses):**
- `TTSCancelledError` extends Error -- thrown when `cancel()` interrupts active speech. Constructor sets `name = 'TTSCancelledError'`.
- `TTSUnsupportedError` extends Error -- thrown when speechSynthesis is unavailable. Constructor sets `name = 'TTSUnsupportedError'`.

**Voice constant arrays (string arrays, all lowercase):**
- `APPLE_US_VOICES`: `['samantha', 'siri', 'ava', 'allison', 'alex', 'victoria', 'karen']`
- `ANDROID_US_VOICES`: `['google us english', 'google en-us', 'english united states']`
- `EDGE_VOICES`: `['microsoft zira', 'microsoft david', 'microsoft mark', 'microsoft jenny']` (NEW - per locked decision)
- `ENHANCED_HINTS`: `['enhanced', 'premium']`

**Interfaces/types:**
- `TTSState`: `{ isSpeaking: boolean; isPaused: boolean; currentText: string | null }`
- `TTSSettings`: `{ rate: 'slow' | 'normal' | 'fast'; pitch: number; lang: string; preferredVoice: string | null }`
- `SpeakOptions`: `{ lang?: string; rate?: number; pitch?: number; voice?: SpeechSynthesisVoice; onProgress?: (event: SpeechSynthesisEvent) => void }`
- `TTSEngineDefaults`: `{ lang?: string; rate?: number; pitch?: number }`
- `FindVoicePreferences`: `{ preferredVoiceName?: string; preferLocal?: boolean }`
- `SafeSpeakOptions`: `SpeakOptions & { swallow?: Array<'cancelled' | 'unsupported' | 'error'> }`
- `TTSEngine` interface with methods: `speak(text: string, overrides?: SpeakOptions) => Promise<void>`, `cancel() => void`, `pause() => void`, `resume() => void`, `setDefaults(defaults: Partial<TTSEngineDefaults>) => void`, `getVoices() => SpeechSynthesisVoice[]`, `refreshVoices() => Promise<SpeechSynthesisVoice[]>`, `isSupported() => boolean`, `onStateChange(cb: (state: TTSState) => void) => () => void`, `destroy() => void`

Use `export` on every item. No default export.
  </action>
  <verify>Run `npx tsc --noEmit src/lib/ttsTypes.ts` (or equivalent typecheck). File compiles with zero errors.</verify>
  <done>ttsTypes.ts exports all specified types, error classes, voice constants, and the TTSEngine interface. No implementation code -- pure types and constants.</done>
</task>

<task type="auto">
  <name>Task 2: Create TTS core engine module with all cross-browser workarounds</name>
  <files>src/lib/ttsCore.ts</files>
  <action>
Create `src/lib/ttsCore.ts` importing all types from `./ttsTypes`. This is the main implementation file (~300-400 lines).

**Module-level state:**
- `let voiceCache: SpeechSynthesisVoice[] | null = null` -- global voice cache shared by all engines
- `let currentUtterance: SpeechSynthesisUtterance | null = null` -- strong reference to prevent GC (Pitfall 1 from research)

**Standalone exports:**

1. `loadVoices(): Promise<SpeechSynthesisVoice[]>` -- Returns cached voices or polls (8 retries x 250ms) + `onvoiceschanged` property (NOT addEventListener -- Safari compat per Pitfall 7). Resolves with empty array if no voices found. Uses `voiceCache` module-level variable.

2. `findVoice(voices: SpeechSynthesisVoice[], lang: string, preferences?: FindVoicePreferences): SpeechSynthesisVoice | null` -- Hybrid: known names + heuristic fallback. Search order: (a) preferred voice name match, (b) APPLE_US_VOICES, (c) ANDROID_US_VOICES, (d) EDGE_VOICES, (e) ENHANCED_HINTS match, (f) if `preferLocal` then local service first, (g) first lang match, (h) any voice. Normalize `voice.lang` by replacing underscores with hyphens (Pitfall 9 -- Android locale format). Firefox fallback: try any English voice first, then first available voice.

3. `estimateDuration(text: string, rate: number): number` -- Formula: `(words / 2.5) / rate * 1000 + 3000` (keep current from useInterviewTTS).

4. `getPreferredVoice(lang?: string, preferences?: FindVoicePreferences): Promise<SpeechSynthesisVoice | null>` -- Convenience: calls loadVoices() then findVoice().

5. `safeSpeak(engine: TTSEngine, text: string, options?: SafeSpeakOptions): Promise<'completed' | 'cancelled' | 'error'>` -- Wraps engine.speak() in try/catch. Returns `'completed'` on success, `'cancelled'` on TTSCancelledError, `'error'` on other errors. The `swallow` option controls which error types are swallowed (default: all). Never throws.

**Factory function:**

`createTTSEngine(defaults?: TTSEngineDefaults): TTSEngine` -- Creates a new engine instance. Implementation details:

- **Internal state:** `isSpeaking`, `isPaused`, `currentText`, `isDestroyed`, `cancelRequested`, mutable defaults object, state change subscribers Set.
- **`speak(text, overrides?)`:**
  - If destroyed or typeof window === 'undefined' or !window.speechSynthesis, reject with TTSUnsupportedError.
  - Auto-cancel previous speech (call internal cancel, wait 100ms for Firefox -- Pitfall 2).
  - Chunk text via sentence-aware chunking if > 30 words (Chrome 15s defense -- Pitfall 4).
  - For each chunk: create NEW SpeechSynthesisUtterance (never reuse -- Pitfall 10), set voice via findVoice(), set lang/rate/pitch from overrides then defaults.
  - Store utterance in module-level `currentUtterance` (strong reference -- Pitfall 1).
  - Set up `onend`, `onerror` handlers with double-fire guard (`settled` boolean).
  - In `onerror`: treat `'canceled'` and `'interrupted'` as TTSCancelledError (Safari -- Pitfall 3). Other errors: one automatic retry after 500ms delay, then reject.
  - Timeout fallback via estimateDuration() -- resolve if onend never fires (Chrome/Android -- Pitfall 4).
  - Start pause/resume keep-alive interval (14s) BUT only when NOT on Android (`navigator.userAgent` check for 'Android' -- Pitfall 5; this is the documented EXCEPTION to the no-UA-sniffing rule).
  - Notify state subscribers on start/end.
  - Chain chunks sequentially (each chunk's onend triggers next chunk's speak).
  - Return a single Promise that resolves when ALL chunks complete.
- **`cancel()`:** Set cancelRequested flag, clear keep-alive interval, clear timeout fallback, call speechSynthesis.cancel(), update state, notify subscribers.
- **`pause()`:** Call speechSynthesis.pause(), update isPaused state.
- **`resume()`:** Call speechSynthesis.resume(), update isPaused state.
- **`setDefaults(partial)`:** Merge into defaults object.
- **`getVoices()`:** Return voiceCache or empty array.
- **`refreshVoices()`:** Clear voiceCache, call loadVoices(), return result.
- **`isSupported()`:** Return `typeof window !== 'undefined' && 'speechSynthesis' in window`.
- **`onStateChange(cb)`:** Add to subscribers set. Return unsubscribe function that removes from set.
- **`destroy()`:** Cancel active speech, clear all intervals/timeouts, clear subscribers, set isDestroyed flag. Safe to call multiple times.

**Internal helper: `chunkForSpeech(text: string, maxWords?: number): string[]`** -- Split on sentence boundaries (`/(?<=[.!?])\s+/`), accumulate until exceeding maxWords (default 30). Return array of chunks. If text has no sentence boundaries or is under maxWords, return `[text]`.

**Key implementation notes:**
- Do NOT use class syntax -- use plain closure-based factory function.
- All workarounds run universally EXCEPT pause/resume cycling which skips Android.
- Every speak() call estimates duration and sets a timeout fallback.
- The promise settles exactly once (double-fire guard).
- Strong utterance reference maintained at module level.
  </action>
  <verify>Run `npx tsc --noEmit` to verify the full project typechecks. Run `npm run lint` to verify no lint errors.</verify>
  <done>ttsCore.ts exports createTTSEngine factory and all 5 standalone utilities. All 12 cross-browser pitfalls from the research are addressed. The module compiles cleanly and passes lint.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes with zero errors
3. Manual review: ttsTypes.ts has all specified exports (TTSEngine, TTSState, TTSSettings, SpeakOptions, error classes, voice constants)
4. Manual review: ttsCore.ts has createTTSEngine, findVoice, estimateDuration, loadVoices, getPreferredVoice, safeSpeak exports
5. grep confirms no duplicate voice-finding logic (findVoice only defined in ttsCore.ts)
</verification>

<success_criteria>
- ttsTypes.ts compiles and exports all types/interfaces/constants/error classes per locked decisions
- ttsCore.ts compiles and exports the full API surface (factory + 5 standalone functions)
- All 12 cross-browser pitfalls from research are handled in the implementation
- No lint errors, no type errors
- Code uses plain functions (not class), closure-based factory per locked decision
</success_criteria>

<output>
After completion, create `.planning/phases/19-tts-core-extraction/19-01-SUMMARY.md`
</output>

